<html>
<head>
    <meta charset="utf-8"/>
<meta name="description" content=""/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SpringBoot（一） | Kohath</title>
<link rel="shortcut icon" href="https://stormga.github.io//favicon.ico?v=1583840675267">
<link href="https://cdn.bootcss.com/font-awesome/5.11.2/css/all.css" rel="stylesheet">
<link rel="stylesheet" href="https://stormga.github.io//styles/main.css">
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css"
      integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">

<script src="https://cdn.bootcss.com/highlight.js/9.15.10/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/go.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>
<script src="https://code.jquery.com/jquery-3.4.1.slim.min.js"
        integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n"
        crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"
        integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo"
        crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js"
        integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6"
        crossorigin="anonymous"></script>

<!-- DEMO JS -->
<script src="media/scripts/index.js"></script>



    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <nav class="navbar navbar-expand-lg">
    <div class="navbar-brand">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            Kohath
        </div>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
                <div class="nav-item">
                    
                        <a href="/" class="menu gt-a-link">
                            首页
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/archives" class="menu gt-a-link">
                            归档
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/tags" class="menu gt-a-link">
                            标签
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/post/about" class="menu gt-a-link">
                            关于
                        </a>
                    
                </div>
            
        </div>
    </div>
</nav>
    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    SpringBoot（一）
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2020-03-09 ·
                    </time>
                    
                        <a href="https://stormga.github.io/tag/mGZMdwc9F/" class="post-tags">
                            # SpringBoot
                        </a>
                    
                </div>
                <div class="post-content">
                    <p>本文主要介绍了：Springboot的入门程序，springboot配置文件，日志模块，web开发，docker，数据访问，启动原理，自定义starter。</p>
<!-- more -->
<p><ul class="markdownIt-TOC">
<li><a href="#%E4%B8%80-spring-boot%E5%85%A5%E9%97%A8">一、Spring Boot入门</a>
<ul>
<li><a href="#1-spring-boot%E7%AE%80%E4%BB%8B">1、Spring Boot简介</a></li>
<li><a href="#2-%E5%BE%AE%E6%9C%8D%E5%8A%A1">2、微服务</a></li>
<li><a href="#3-%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87">3、环境准备</a>
<ul>
<li><a href="#1-maven%E8%AE%BE%E7%BD%AE">1、MAVEN设置</a></li>
<li><a href="#2-idea%E8%AE%BE%E7%BD%AE">2、IDEA设置</a></li>
</ul>
</li>
<li><a href="#4-spring-boot%E7%9A%84hello-world">4、Spring Boot的Hello World</a>
<ul>
<li><a href="#1-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAmaven%E5%B7%A5%E7%A8%8B">1、创建一个Maven工程</a></li>
<li><a href="#2-%E5%AF%BC%E5%85%A5spring-boot%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BE%9D%E8%B5%96">2、导入Spring Boot的相关依赖</a></li>
<li><a href="#3-%E7%BC%96%E5%86%99%E4%B8%AA%E4%B8%BB%E7%A8%8B%E5%BA%8F">3、编写个主程序</a></li>
<li><a href="#4-%E7%BC%96%E5%86%99%E7%9B%B8%E5%BA%94%E7%9A%84controller%E5%92%8Cservice">4、编写相应的Controller和Service</a></li>
<li><a href="#5-%E8%BF%90%E8%A1%8C%E4%B8%BB%E7%A8%8B%E5%BA%8F%E6%B5%8B%E8%AF%95">5、运行主程序测试</a></li>
<li><a href="#6-%E7%AE%80%E5%8C%96%E9%83%A8%E7%BD%B2">6、简化部署</a></li>
</ul>
</li>
<li><a href="#5-helloworld%E6%B7%B1%E5%BA%A6%E7%90%86%E8%A7%A3">5、HelloWorld深度理解</a>
<ul>
<li><a href="#1pomxml%E6%96%87%E4%BB%B6">1.POM.xml文件</a>
<ul>
<li><a href="#1-%E7%88%B6%E9%A1%B9%E7%9B%AE">1、父项目</a></li>
<li><a href="#2-%E5%90%AF%E5%8A%A8%E5%99%A8">2、启动器</a></li>
</ul>
</li>
<li><a href="#2-%E4%B8%BB%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3">2、主程序入口</a></li>
</ul>
</li>
<li><a href="#6-%E4%BD%BF%E7%94%A8spring-initializer%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%BF%AB%E9%80%9F%E5%90%91%E5%AF%BC">6、使用Spring Initializer创建一个快速向导</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">二、配置文件</a>
<ul>
<li><a href="#1-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">1、配置文件</a></li>
<li><a href="#2-yaml%E8%AF%AD%E6%B3%95">2、YAML语法</a>
<ul>
<li><a href="#1-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">1、基本语法</a></li>
<li><a href="#2-%E5%80%BC%E7%9A%84%E5%86%99%E6%B3%95">2、值的写法</a></li>
</ul>
</li>
<li><a href="#3-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%80%BC%E6%B3%A8%E5%85%A5">3、配置文件值注入</a>
<ul>
<li><a href="#1-configurationproperties">1、@ConfigurationProperties</a></li>
<li><a href="#2-value%E6%B3%A8%E8%A7%A3">2、@Value注解</a></li>
<li><a href="#3-%E5%85%B6%E4%BB%96%E6%B3%A8%E8%A7%A3">3、其他注解</a></li>
</ul>
</li>
<li><a href="#4-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8D%A0%E4%BD%8D%E7%AC%A6">4、配置文件占位符</a><br>
*
<ul>
<li><a href="#1-%E9%9A%8F%E6%9C%BA%E6%95%B0">1、随机数</a></li>
<li><a href="#2-%E8%8E%B7%E5%8F%96%E9%85%8D%E7%BD%AE%E5%80%BC">2、获取配置值</a></li>
</ul>
</li>
<li><a href="#5-profile">5、Profile</a>
<ul>
<li><a href="#1-%E5%A4%9Aprofile%E6%96%87%E4%BB%B6">1、多Profile文件</a></li>
<li><a href="#2-yaml%E6%96%87%E6%A1%A3%E5%9D%97">2、YAML文档块</a></li>
<li><a href="#3-%E6%BF%80%E6%B4%BB%E6%8C%87%E5%AE%9Aprofile">3、激活指定profile</a></li>
</ul>
</li>
<li><a href="#6-%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BD%8D%E7%BD%AE">6、加载配置文件位置</a></li>
<li><a href="#7%E5%BC%95%E5%85%A5%E5%A4%96%E9%83%A8%E9%85%8D%E7%BD%AE">7.引入外部配置</a></li>
<li><a href="#8-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE">8、自动配置</a>
<ul>
<li><a href="#1-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86">1、自动配置原理</a></li>
<li><a href="#2-%E6%89%80%E6%9C%89%E7%9A%84%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%BB%84%E4%BB%B6">2、所有的自动配置组件</a></li>
<li><a href="#3-%E7%B2%BE%E9%AB%93">3、精髓：</a></li>
<li><a href="#4-%E7%BB%86%E8%8A%82">4、细节</a>
<ul>
<li><a href="#1-conditional%E6%B4%BE%E7%94%9F%E6%B3%A8%E8%A7%A3">1、@Conditional派生注解</a></li>
<li><a href="#2-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E6%8A%A5%E5%91%8A">2、自动配置报告</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E6%97%A5%E5%BF%97">三、日志</a><br>
*
<ul>
<li><a href="#1-%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6">1、日志框架</a></li>
<li><a href="#2-slf4j%E4%BD%BF%E7%94%A8">2、SLF4J使用</a>
<ul>
<li><a href="#1-%E5%A6%82%E4%BD%95%E5%9C%A8%E7%B3%BB%E7%BB%9F%E4%B8%AD%E4%BD%BF%E7%94%A8slf4j">1、如何在系统中使用SLF4j</a></li>
<li><a href="#2-%E9%81%97%E7%95%99%E9%97%AE%E9%A2%98">2、遗留问题</a></li>
</ul>
</li>
<li><a href="#3-spingboot%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90">3、SpingBoot日志框架解析</a></li>
<li><a href="#4-%E6%97%A5%E5%BF%97%E7%9A%84%E4%BD%BF%E7%94%A8">4、日志的使用</a>
<ul>
<li><a href="#1-%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE">1、默认配置</a></li>
<li><a href="#2-%E6%8C%87%E5%AE%9A%E9%85%8D%E7%BD%AE">2、指定配置</a></li>
</ul>
</li>
<li><a href="#3-%E5%88%87%E6%8D%A2%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6">3、切换日志框架</a>
<ul>
<li><a href="#1-log4j">1、log4j</a></li>
<li><a href="#2-log4j2">2、log4j2</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%9B%9B-web%E5%BC%80%E5%8F%91">四、web开发</a>
<ul>
<li><a href="#1-%E7%AE%80%E4%BB%8B">1、简介</a></li>
<li><a href="#2-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84%E8%A7%84%E5%88%99">2、静态资源文件映射规则</a>
<ul>
<li><a href="#1-webjar">1、webjar</a></li>
<li><a href="#2-%E6%9C%AC%E5%9C%B0%E8%B5%84%E6%BA%90">2、本地资源</a></li>
</ul>
</li>
<li><a href="#3-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E">3、模板引擎</a>
<ul>
<li><a href="#1-%E5%BC%95%E5%85%A5thymeleaf-3">1、引入thymeleaf 3</a></li>
<li><a href="#2-thymeleaf%E4%BD%BF%E7%94%A8%E5%92%8C%E8%AF%AD%E6%B3%95">2、Thymeleaf使用和语法</a></li>
<li><a href="#3-%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99">3、语法规则</a></li>
</ul>
</li>
<li><a href="#4-springmvc%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE">4、SpringMVC自动配置</a>
<ul>
<li><a href="#1-springmvc%E7%9A%84%E8%87%AA%E5%8A%A8%E5%AF%BC%E5%85%A5">1、SpringMVC的自动导入</a></li>
<li><a href="#2-%E6%89%A9%E5%B1%95springmvc">2、扩展SpringMVC</a></li>
<li><a href="#3-%E5%85%A8%E9%9D%A2%E6%8E%A5%E7%AE%A1mvc">3、全面接管mvc</a></li>
</ul>
</li>
<li><a href="#5-%E4%BF%AE%E6%94%B9springmvc%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE">5、修改SpringMVC默认配置</a></li>
<li><a href="#6-restfulcrud">6、RestfulCRUD</a>
<ul>
<li><a href="#1-%E9%BB%98%E8%AE%A4%E8%AE%BF%E9%97%AE%E9%A6%96%E9%A1%B5">1、默认访问首页</a></li>
<li><a href="#2-%E5%9B%BD%E9%99%85%E5%8C%96">2、国际化</a>
<ul>
<li><a href="#1-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%88%87%E6%8D%A2%E5%9B%BD%E9%99%85%E5%8C%96">1、浏览器切换国际化</a></li>
<li><a href="#2-%E7%82%B9%E5%87%BB%E9%93%BE%E6%8E%A5%E5%88%87%E6%8D%A2%E5%9B%BD%E9%99%85%E5%8C%96">2、点击链接切换国际化</a></li>
</ul>
</li>
<li><a href="#3-%E7%99%BB%E5%BD%95%E6%8B%A6%E6%88%AA%E5%99%A8">3、登录拦截器</a>
<ul>
<li><a href="#1-%E7%99%BB%E5%BD%95">1、登录</a></li>
</ul>
</li>
<li><a href="#4-%E6%8B%A6%E6%88%AA%E5%99%A8">4、拦截器</a></li>
<li><a href="#5-crud-%E5%91%98%E5%B7%A5%E5%88%97%E8%A1%A8">5、CRUD-员工列表</a>
<ul>
<li><a href="#1-%E5%85%AC%E5%85%B1%E9%A1%B5%E9%9D%A2%E6%8A%BD%E5%8F%96">1、公共页面抽取</a></li>
<li><a href="#2-%E5%88%97%E8%A1%A8%E9%AB%98%E4%BA%AE">2、列表高亮</a></li>
</ul>
</li>
<li><a href="#6-%E5%88%97%E8%A1%A8%E6%95%B0%E6%8D%AE%E6%98%BE%E7%A4%BA%E6%9F%A5">6、列表数据显示（查）</a>
<ul>
<li><a href="#1-%E4%BC%A0%E5%85%A5%E5%91%98%E5%B7%A5%E5%AF%B9%E8%B1%A1">1、传入员工对象</a></li>
<li><a href="#2-%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1">2、 遍历对象</a></li>
<li><a href="#3-%E6%95%88%E6%9E%9C%E6%98%BE%E7%A4%BA">3、效果显示</a></li>
</ul>
</li>
<li><a href="#7-%E5%91%98%E5%B7%A5%E6%B7%BB%E5%8A%A0%E5%A2%9E">7、员工添加（增）</a>
<ul>
<li><a href="#1-%E6%96%B0%E5%A2%9E%E9%A1%B5%E9%9D%A2">1、新增页面</a></li>
<li><a href="#2-%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC">2、页面跳转</a></li>
<li><a href="#3-%E6%B7%BB%E5%8A%A0%E5%8A%9F%E8%83%BD%E5%AE%8C%E6%88%90">3、添加功能完成</a></li>
</ul>
</li>
<li><a href="#8-%E5%91%98%E5%B7%A5%E7%BC%96%E8%BE%91%E6%94%B9">8、员工编辑（改）</a>
<ul>
<li><a href="#1-%E4%BF%AE%E6%94%B9%E6%8C%89%E9%92%AE">1、修改按钮</a></li>
<li><a href="#2-%E7%BC%96%E5%86%99%E8%B7%B3%E8%BD%AC%E9%A1%B5%E9%9D%A2">2、编写跳转页面</a></li>
<li><a href="#3-%E5%AF%B9%E9%A1%B5%E9%9D%A2%E4%BF%AE%E6%94%B9">3、对页面修改</a></li>
</ul>
</li>
<li><a href="#9-%E5%91%98%E5%B7%A5%E5%88%A0%E9%99%A4%E5%88%A0">9、员工删除（删）</a>
<ul>
<li><a href="#1-%E6%96%B0%E5%BB%BAcontoller">1、新建Contoller</a></li>
<li><a href="#2-%E4%BF%AE%E6%94%B9%E5%88%A0%E9%99%A4%E6%A0%87%E7%AD%BE">2、修改删除标签</a></li>
<li><a href="#3-%E5%86%99form%E8%A1%A8%E5%8D%95">3、写Form表单</a></li>
<li><a href="#4-%E5%86%99js%E6%8F%90%E4%BA%A4">4、写JS提交</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#7-%E9%94%99%E8%AF%AF%E6%9C%BA%E5%88%B6%E7%9A%84%E5%A4%84%E7%90%86">7、错误机制的处理</a>
<ul>
<li><a href="#1-%E9%BB%98%E8%AE%A4%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6">1、默认的错误处理机制</a></li>
<li><a href="#2-%E5%A6%82%E4%BD%95%E5%AE%9A%E5%88%B6%E9%94%99%E8%AF%AF%E5%93%8D%E5%BA%94">2、如何定制错误响应</a></li>
<li><a href="#3-%E5%A6%82%E4%BD%95%E5%AE%9A%E5%88%B6json%E6%95%B0%E6%8D%AE">3、如何定制Json数据</a>
<ul>
<li><a href="#1-%E4%BB%85%E5%8F%91%E9%80%81json%E6%95%B0%E6%8D%AE">1、仅发送json数据</a></li>
<li><a href="#2-%E8%BD%AC%E5%8F%91%E5%88%B0error%E8%87%AA%E9%80%82%E5%BA%94%E5%A4%84%E7%90%86">2、转发到error自适应处理</a></li>
<li><a href="#3-%E8%87%AA%E9%80%82%E5%BA%94%E5%92%8C%E5%AE%9A%E5%88%B6%E6%95%B0%E6%8D%AE%E4%BC%A0%E5%85%A5">3、自适应和定制数据传入</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#8-%E9%85%8D%E7%BD%AE%E5%B5%8C%E5%85%A5%E5%BC%8Fservlet%E5%AE%B9%E5%99%A8">8、配置嵌入式servlet容器</a>
<ul>
<li><a href="#1-%E5%AE%9A%E5%88%B6%E5%92%8C%E4%BF%AE%E6%94%B9servlet%E5%AE%B9%E5%99%A8">1、定制和修改Servlet容器</a></li>
<li><a href="#2-%E6%B3%A8%E5%86%8Cservlet%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6">2、注册Servlet三大组件</a>
<ul>
<li><a href="#servletregistrationbean">ServletRegistrationBean</a></li>
<li><a href="#filterregistrationbean">FilterRegistrationBean</a></li>
<li><a href="#servletlistenerregistrationbean">ServletListenerRegistrationBean</a></li>
</ul>
</li>
<li><a href="#3-%E5%88%87%E6%8D%A2%E5%85%B6%E4%BB%96%E7%9A%84servlet%E5%AE%B9%E5%99%A8">3、切换其他的Servlet容器</a></li>
<li><a href="#4-%E5%B5%8C%E5%85%A5%E5%BC%8Fservlet%E5%AE%B9%E5%99%A8%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86">4、嵌入式Servlet容器自动配置原理</a></li>
<li><a href="#5-%E5%B5%8C%E5%85%A5%E5%BC%8Fservlet%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86">5、嵌入式Servlet容器启动原理</a></li>
</ul>
</li>
<li><a href="#9-%E4%BD%BF%E7%94%A8%E5%A4%96%E7%BD%AE%E7%9A%84servlet%E5%AE%B9%E5%99%A8">9、使用外置的Servlet容器</a>
<ul>
<li><a href="#1-idea%E6%93%8D%E4%BD%9C%E5%A4%96%E9%83%A8servlet">1、IDEA操作外部Servlet</a></li>
<li><a href="#2-%E8%BF%90%E8%A1%8C%E4%B8%80%E4%B8%AA%E7%A4%BA%E4%BE%8B">2、运行一个示例</a></li>
<li><a href="#3-%E5%8E%9F%E7%90%86">3、原理</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%BA%94-docker">五、Docker</a>
<ul>
<li><a href="#1-%E7%AE%80%E4%BB%8B-2">1、简介</a></li>
<li><a href="#2-docker%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5">2、Docker的核心概念</a></li>
<li><a href="#3-%E5%AE%89%E8%A3%85docker">3、安装Docker</a>
<ul>
<li><a href="#1-%E5%AE%89%E8%A3%85linux">1、安装Linux</a></li>
<li><a href="#2-%E5%9C%A8linux%E4%B8%8A%E5%AE%89%E8%A3%85docker">2、在linux上安装docker</a></li>
</ul>
</li>
<li><a href="#4-docker%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C">4、docker的常用操作</a>
<ul>
<li><a href="#1-%E9%95%9C%E5%83%8F%E6%93%8D%E4%BD%9C">1、镜像操作</a></li>
<li><a href="#2-%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C">2、容器操作</a></li>
<li><a href="#3-%E5%AE%89%E8%A3%85mysql">3、安装Mysql</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%85%AD-%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE">六、数据访问</a>
<ul>
<li><a href="#1-%E6%95%B4%E5%90%88jdbc%E6%95%B0%E6%8D%AE%E6%BA%90">1、整合JDBC数据源</a>
<ul>
<li><a href="#1-datasource">1、DataSource</a></li>
<li><a href="#2-springboot%E9%BB%98%E8%AE%A4%E6%94%AF%E6%8C%81">2、SpringBoot默认支持</a></li>
<li><a href="#3-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E6%BA%90">3、自定义数据源</a></li>
<li><a href="#4-%E8%BF%90%E8%A1%8Csql%E5%BB%BA%E8%A1%A8">4、运行sql建表</a></li>
<li><a href="#5-%E6%93%8D%E4%BD%9Cjdbctemplate">5、操作JdbcTemplate</a></li>
</ul>
</li>
<li><a href="#2-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E6%BA%90">2、自定义数据源</a></li>
<li><a href="#3-%E6%95%B4%E5%90%88mybatis">3、整合Mybatis</a>
<ul>
<li><a href="#%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F">注解方式</a></li>
<li><a href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%96%B9%E5%BC%8F">配置文件方式</a></li>
</ul>
</li>
<li><a href="#4-jpa%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE">4、JPA数据访问</a></li>
</ul>
</li>
<li><a href="#%E4%B8%83-%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86">七、启动配置原理</a>
<ul>
<li><a href="#1-%E5%88%9B%E5%BB%BAspringapplicaiotn%E5%AF%B9%E8%B1%A1">1、创建SpringApplicaiotn对象</a></li>
<li><a href="#2-%E8%BF%90%E8%A1%8Crun%E6%96%B9%E6%B3%95">2、运行Run方法</a></li>
<li><a href="#3-%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6">3、事件监听机制</a></li>
</ul>
</li>
<li><a href="#%E5%85%AB-springboot%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89starter">八、SpringBoot的自定义starter</a><br>
*
<ul>
<li><a href="#%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AAstarter">新建一个starter</a>
<ul>
<li><a href="#1-%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%A9%BA%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B">1、新建一个空项目工程</a></li>
<li><a href="#2-%E7%BC%96%E5%86%99starter">2、编写starter</a>
<ul>
<li><a href="#autoconfigurer">autoconfigurer</a></li>
</ul>
</li>
<li><a href="#3-%E6%B5%8B%E8%AF%95">3、测试</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h1 id="一-spring-boot入门">一、Spring Boot入门</h1>
<h2 id="1-spring-boot简介">1、Spring Boot简介</h2>
<p>Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。</p>
<h2 id="2-微服务">2、微服务</h2>
<p>微服务：架构风格（服务微化）</p>
<p>一个应用应该是一组小型服务，可以通过HTTP的方式进行互通</p>
<p>单体应用：ALL IN ONE</p>
<p>微服务：每个功能元素最终都是一个可以独立替换和升级的软件单元</p>
<h2 id="3-环境准备">3、环境准备</h2>
<p>环境约束</p>
<ul>
<li>jdk1.8</li>
<li>maven 3.x :maven3.3以上</li>
<li>IDEA2017</li>
<li>SpringBoot 1.5.9RELEASE</li>
</ul>
<h3 id="1-maven设置">1、MAVEN设置</h3>
<pre><code class="language-xml">&lt;!-- 配置JDK版本 --&gt;
&lt;profile&gt;    
    &lt;id&gt;jdk18&lt;/id&gt;    
    &lt;activation&gt;    
        &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;    
        &lt;jdk&gt;1.8&lt;/jdk&gt;    
    &lt;/activation&gt;    
    &lt;properties&gt;    
        &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;    
        &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;    
        &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt;    
    &lt;/properties&gt;     
&lt;/profile&gt;
   &lt;!-- 当 nexus-aliyun 下不了的包，或许这个镜像能下，
        才开放它，这个实在太慢，而且要把它放在首位，即 nexus-aliyun 之前，做过测试。
        所以它的用途只有那么一瞬间，就是或许它能下载，可以通过 url 去查找确定一下
    --&gt;
    &lt;!-- &lt;mirror&gt;
        &lt;id&gt;spring-libs-milestone&lt;/id&gt;
        &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;
        &lt;name&gt;Spring Milestones&lt;/name&gt;
        &lt;url&gt;http://repo.spring.io/libs-milestone&lt;/url&gt;
    &lt;/mirror&gt; --&gt;

    &lt;!-- nexus-aliyun 首选，放第一位,有不能下载的包，再去做其他镜像的选择  --&gt;
    &lt;mirror&gt;
        &lt;id&gt;nexus-aliyun&lt;/id&gt;
        &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;
        &lt;name&gt;Nexus aliyun&lt;/name&gt;
        &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;
    &lt;/mirror&gt;

    &lt;!-- 备选镜像，也是可以通过 url 去查找确定一下，
        该镜像是否含有你想要的包，它比 spring-libs-milestone 快  --&gt;
    &lt;mirror&gt;
        &lt;id&gt;central-repository&lt;/id&gt;
        &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;
        typor&lt;name&gt;Central Repository&lt;/name&gt;
        &lt;url&gt;http://central.maven.org/maven2/&lt;/url&gt;
    &lt;/mirror&gt;  
</code></pre>
<h3 id="2-idea设置">2、IDEA设置</h3>
<p>​    配置IDEA的Maven，指定Setting的Maven目录和MAVEN的setting.xml文件</p>
<p>​	快捷键：</p>
<p>​	Ctrl+D 复制一行</p>
<p>​	Ctrl+Y 删除一行</p>
<p>​	Ctrl+P 参数提示</p>
<p>​	Ctrl+Alt+V 自动补齐方法</p>
<p>​	Ctrl+N 查找类方法</p>
<p>​	Alt+Ins 构造器、getter/setter toString</p>
<p>​	Ctrl+O 重载方法提示</p>
<p>​	Alt+Enter 提示导入类etc</p>
<p>​	Shift+F6 :文件重命名</p>
<h2 id="4-spring-boot的hello-world">4、Spring Boot的Hello World</h2>
<h3 id="1-创建一个maven工程">1、创建一个Maven工程</h3>
<h3 id="2-导入spring-boot的相关依赖">2、导入Spring Boot的相关依赖</h3>
<pre><code class="language-xml">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;
    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
&lt;/parent&gt;

&lt;properties&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
    &lt;java.version&gt;1.8&lt;/java.version&gt;
&lt;/properties&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

</code></pre>
<h3 id="3-编写个主程序">3、编写个主程序</h3>
<pre><code class="language-java">@SpringBootApplication
public class SpringBoot01HelloQuickApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringBoot01HelloQuickApplication.class, args);
    }
}
</code></pre>
<h3 id="4-编写相应的controller和service">4、编写相应的Controller和Service</h3>
<pre><code class="language-java">@Controller
public class HelloController {

    @ResponseBody
    @RequestMapping(&quot;/hello&quot;)
    public  String  hello(){
        return &quot;hello world&quot;;
    }
}
</code></pre>
<h3 id="5-运行主程序测试">5、运行主程序测试</h3>
<p>访问 localhost:8080/hello</p>
<h3 id="6-简化部署">6、简化部署</h3>
<p>在pom.xml文件中，导入build插件</p>
<pre><code class="language-xml">&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<h2 id="5-helloworld深度理解">5、HelloWorld深度理解</h2>
<h3 id="1pomxml文件">1.POM.xml文件</h3>
<h4 id="1-父项目">1、父项目</h4>
<pre><code class="language-xml">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;
    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
&lt;/parent&gt;
</code></pre>
<p>这个父项目<strong>spring-boot-starter-parent</strong>又依赖一个父项目</p>
<pre><code class="language-xml">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;
    &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;
    &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;
&lt;/parent&gt;
</code></pre>
<p>下面有个属性，定义了对应的版本号</p>
<pre><code class="language-xml">&lt;properties&gt;
    &lt;activemq.version&gt;5.15.3&lt;/activemq.version&gt;
    &lt;antlr2.version&gt;2.7.7&lt;/antlr2.version&gt;
    &lt;appengine-sdk.version&gt;1.9.63&lt;/appengine-sdk.version&gt;
    &lt;artemis.version&gt;2.4.0&lt;/artemis.version&gt;
    &lt;aspectj.version&gt;1.8.13&lt;/aspectj.version&gt;
    &lt;assertj.version&gt;3.9.1&lt;/assertj.version&gt;
    &lt;atomikos.version&gt;4.0.6&lt;/atomikos.version&gt;
    &lt;bitronix.version&gt;2.1.4&lt;/bitronix.version&gt;
    &lt;build-helper-maven-plugin.version&gt;3.0.0&lt;/build-helper-maven-plugin.version&gt;
    。。。。。。。
</code></pre>
<p>Spring Boot的版本仲裁中心 会自动导入对应的版本，不需要我们自己导入依赖，没有dependencies里面管理的依赖自己声明</p>
<h4 id="2-启动器">2、启动器</h4>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;

</code></pre>
<p>**spring-boot-starter-web:**帮我们导入web模块正常运行所依赖的组件</p>
<p><strong>spring boot</strong>将所有的功能场景都抽取出来，做成一个个的starter(启动器)，只需要在项目里引入这些starter相关场景的所有依赖都会被导入进来，要用什么功能就导入什么场景的启动器。</p>
<h3 id="2-主程序入口">2、主程序入口</h3>
<pre><code class="language-java">@SpringBootApplication
public class SpringBoot01HelloQuickApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringBoot01HelloQuickApplication.class, args);
    }
}

</code></pre>
<p><strong>@SpringBootApplication:</strong> 说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动应用</p>
<p>进入SpringBootApplication注解</p>
<pre><code class="language-java">@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(
    excludeFilters = {@Filter(
    type = FilterType.CUSTOM,
    classes = {TypeExcludeFilter.class}
), @Filter(
    type = FilterType.CUSTOM,
    classes = {AutoConfigurationExcludeFilter.class}
)}
)
public @interface SpringBootApplication {

</code></pre>
<p><strong>@SpringBootConfiguration</strong>：SpringBoot的配置类： 标准在某个类上，表示这是一个SpringBoot的配置类</p>
<p><strong>@Configuration</strong>:配置类上，来标注这个注解；<br>
配置类 ---- 配置文件，也是容器中的一个组件（@Component）<br>
<strong>@EnableAutoConfiguration</strong>:开启自动配置功能<br>
以前需要自动配置的东西，Spring Boot帮我们自动配置；@EnableAutoConfiguration告诉SpringBoot开启自动<br>
配置功能；这样自动配置才能生效。</p>
<pre><code class="language-java">@AutoConfigurationPackage
@Import({AutoConfigurationImportSelector.class})
public @interface EnableAutoConfiguration { 

</code></pre>
<p><strong>@AutoConfigurationPackage</strong>:自动配置包<br>
<strong>@Import({Registrar.class})</strong>：底层注解，给容器导入组件；<br>
将主配置类（@SpringBootApplication标注的类）的所在包及下面所有的子包里面的所有组件扫描到Spring容器；</p>
<p><strong>@Import({AutoConfigurationImportSelector.class})：</strong><br>
给容器导入组件？</p>
<p>AutoConfigurationImportSelector：导入组件选择器</p>
<p>将所有需要导入的组件以及全类名的方式返回；这些组件将以字符串数组 String[] 添加到容器中；</p>
<p>会给容器非常多的自动配置类，（xxxAutoConfiguration）;就是给容器中导入这个场景需要的所有组件，并配置<br>
好这些组件。</p>
<figure data-type="image" tabindex="1"><img src="https://stormga.github.io//post-images/1.configuration.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-java">protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata,
AnnotationAttributes attributes) {
	List&lt;String&gt; configurations =
SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(),
this.getBeanClassLoader());
	Assert.notEmpty(configurations, &quot;No auto configuration classes found in META‐INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;);
	return configurations;
} 

</code></pre>
<p><code>SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(),</code><br>
<code>this.getBeanClassLoader());</code></p>
<p>Spring Boot在启动的时候从类路径下的META-INF/spring.factorys中获取的EnableAutoConfiguration指定的值；</p>
<p>将这些值作为自动配置类导入到容器中，自动配置就生效了。 <img src="https://stormga.github.io//post-images/2.factories.jpg" alt="" loading="lazy"></p>
<p>J2EE的整体解决方案</p>
<p>org\springframework\boot\spring-boot-autoconfigure\2.0.1.RELEASE\spring-boot-autoconfigure-2.0.1.RELEASE.jar</p>
<h2 id="6-使用spring-initializer创建一个快速向导">6、使用Spring Initializer创建一个快速向导</h2>
<p>1.IDE支持使用Spring Initializer</p>
<p>自己选择需要的组件:例如web</p>
<p>默认生成的SpringBoot项目</p>
<ul>
<li>
<p>主程序已经生成好了，我们只需要完成我们的逻辑</p>
</li>
<li>
<p>resources文件夹目录结构</p>
<ul>
<li>
<p>static:保存所有的静态文件；js css images</p>
</li>
<li>
<p>templates:保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat,默认不支持JSP）；可</p>
<p>以使用模板引擎（freemarker.thymeleaf）;</p>
</li>
<li>
<p>application.properties:Spring Boot的默认配置，例如 server.port=9000</p>
</li>
</ul>
</li>
</ul>
<h1 id="二-配置文件">二、配置文件</h1>
<h2 id="1-配置文件">1、配置文件</h2>
<p>Spring Boot使用全局配置文件，配置文件名是固定的；</p>
<ul>
<li>application.properties</li>
<li>application.yml</li>
</ul>
<p>配置文件作用：修改Spring Boot在底层封装好的默认值；</p>
<p>YAML（YAML AIN'T Markup Language）</p>
<p>是一个标记语言</p>
<p>又不是一个标记语言</p>
<p><strong>标记语言：</strong></p>
<p>以前的配置文件；大多数使用的是 xxx.xml文件；</p>
<p>以数据为中心，比json、xml等更适合做配置文件</p>
<p>YAML：配置例子</p>
<pre><code class="language-yaml">server:
	port: 9000 

</code></pre>
<p>XML:</p>
<pre><code class="language-xml">&lt;server&gt;
	&lt;port&gt;9000&lt;/port&gt;
&lt;/server&gt; 

</code></pre>
<h2 id="2-yaml语法">2、YAML语法</h2>
<h3 id="1-基本语法">1、基本语法</h3>
<p>k:(空格)v:表示一堆键值对（空格必须有）；</p>
<p>以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一层级的</p>
<pre><code class="language-yaml">server:
	port: 9000
	path: /hello 

</code></pre>
<p>属性和值也是大小写敏感</p>
<h3 id="2-值的写法">2、值的写法</h3>
<p><strong>字面量：普通的值（数字，字符串，布尔）</strong></p>
<p>k: v:字面直接来写；</p>
<p>字符串默认不用加上单引号或者双引号</p>
<p>&quot;&quot;:<strong>双引号</strong> 不会转义字符串里的特殊字符；特殊字符会作为本身想要表示的意思</p>
<p><code>name:&quot;zhangsan\n lisi&quot;</code> 输出：<code>zhangsan换行 lisi</code></p>
<p>'':<strong>单引号</strong> 会转义特殊字符，特殊字符最终只是一个普通的字符串数据</p>
<p><code>name:'zhangsan\n lisi'</code> 输出：<code>zhangsan\n lisi</code></p>
<p><strong>对象、Map（属性和值）键值对</strong></p>
<p>k :v ：在下一行来写对象的属性和值的关系；注意空格控制缩进</p>
<p>对象还是k:v的方式</p>
<pre><code class="language-yaml">frends:
	lastName: zhangsan
	age: 20 

</code></pre>
<p>行内写法</p>
<pre><code class="language-yaml">friends: {lastName: zhangsan,age: 18} 

</code></pre>
<p><strong>数组（List、Set）:</strong><br>
用-表示数组中的一个元素</p>
<pre><code class="language-yaml">pets:
 ‐ cat
 ‐ dog
 ‐ pig 

</code></pre>
<p>行内写法</p>
<pre><code class="language-yaml">pets: [cat,dog,pig] 

</code></pre>
<p><strong>组合变量</strong></p>
<p>多个组合到一起</p>
<h2 id="3-配置文件值注入">3、配置文件值注入</h2>
<h3 id="1-configurationproperties">1、@ConfigurationProperties</h3>
<p>1、application.yml 配置文件</p>
<pre><code class="language-yaml">person:
  age: 18
  boss: false
  birth: 2017/12/12
  maps: {k1: v1,k2: 12}
  lists:
   - lisi
   - zhaoliu
  dog:
    name: wangwang
    age: 2
  last-name: wanghuahua

</code></pre>
<p><code>application.properties</code> 配置文件（二选一）</p>
<pre><code class="language-properties">idea配置文件utf-8
properties 默认GBK
person.age=12
person.boss=false
person.last-name=张三
person.maps.k1=v1
person.maps.k2=v2
person.lists=a,b,c
person.dog.name=wanghuahu
person.dog.age=15

</code></pre>
<p>所以中文输出乱码，改进settings--&gt;file encoding --&gt;[property--&gt;utf-8 ,勾选转成ascii]</p>
<p>javaBean</p>
<pre><code class="language-java">/**
* 将配置文件的配置每个属性的值，映射到组件中
* @ConfigurationProperties:告诉SpringBoot将文本的所有属性和配置文件中的相关配置进行绑定；
* prefix = &quot;person&quot; 配置文件爱你的那个属性进行一一映射
* *
只有这个组件是容器中的组件，才能提供到容器中
*/
@Component
@ConfigurationProperties(prefix = &quot;person&quot;)
public class Person {
    private String lastName;
    private Integer age;
    private Boolean boss;
    private Map&lt;String,Object&gt; maps;
    private List&lt;Object&gt; lists;
    private Dog dog;

</code></pre>
<p>导入配置文件处理器，以后编写配置就有提示了</p>
<pre><code class="language-xml">&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
	&lt;artifactId&gt;spring‐boot‐configuration‐processor&lt;/artifactId&gt;
	&lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt; 

</code></pre>
<h3 id="2-value注解">2、@Value注解</h3>
<p>更改javaBean中的注解</p>
<pre><code class="language-java">@Component
public class Person {
    /**
     * &lt;bean class=&quot;Person&quot;&gt;
     *     &lt;property name=&quot;lastName&quot; value=&quot;字面量/${key}从环境变量/#{spEL}&quot;&gt;&lt;/property&gt;
     * &lt;/bean&gt;
     */
    @Value(&quot;${person.last-name}&quot;)
    private String lastName;
    @Value(&quot;#{11*2}&quot;)
    private Integer age;
    @Value(&quot;true&quot;)
    private Boolean boss;

</code></pre>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">@ConfigurationProperties</th>
<th style="text-align:center">@Value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">功能</td>
<td style="text-align:center">批量注入配置文件属性</td>
<td style="text-align:center">单个指定</td>
</tr>
<tr>
<td style="text-align:center">松散绑定(语法)</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">不支持</td>
</tr>
<tr>
<td style="text-align:center">spEL</td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">支持</td>
</tr>
<tr>
<td style="text-align:center">JSR303校验</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">不支持</td>
</tr>
<tr>
<td style="text-align:center">复杂类型</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">不支持</td>
</tr>
</tbody>
</table>
<blockquote>
<p>松散语法：javaBean中last-name(或者lastName) --&gt;application.properties中的last-name;</p>
<p>spEL语法：#{11*2}</p>
<p>JSR303：@Value会直接忽略，校验规则</p>
</blockquote>
<p>JSR303校验：</p>
<pre><code class="language-java">@Component
@ConfigurationProperties(prefix = &quot;person&quot;)
@Validated
public class Person {
    @Email
    private String lastName;

</code></pre>
<p>复杂类型栗子：</p>
<pre><code class="language-java">@Component
public class Person {
    /**
     * &lt;bean class=&quot;Person&quot;&gt;
     *     &lt;property name=&quot;lastName&quot; value=&quot;字面量/${key}从环境变量/#{spEL}&quot;&gt;&lt;/property&gt;
     * &lt;/bean&gt;
     */
    private String lastName;
    private Integer age;
    private Boolean boss;
   // @Value(&quot;${person.maps}&quot;)
    private Map&lt;String,Object&gt; maps;

</code></pre>
<p>以上会报错，不支持复杂类型</p>
<p><strong>使用场景分析</strong></p>
<p>​	如果说，我们只是在某个业务逻辑中获取一下配置文件的某一项值，使用@Value；</p>
<p>如果专门编写了一个javaBean和配置文件进行映射，我们直接使用@ConfigurationProperties</p>
<p>举栗子：</p>
<p>1、编写新的Controller文件</p>
<pre><code class="language-java">@RestController
public class HelloController {

    @Value(&quot;${person.last-name}&quot;)
    private String name;
    @RequestMapping(&quot;/hello&quot;)
    public  String sayHello(){
        return &quot;Hello&quot;+ name;
    }
}

</code></pre>
<p>2、配置文件</p>
<pre><code class="language-properties">person.age=12
person.boss=false
person.last-name=李四
person.maps.k1=v1
person.maps.k2=v2
person.lists=a,b,c
person.dog.name=wanghuahu
person.dog.age=15

</code></pre>
<p>3、测试运行</p>
<p>访问 localhost:9000/hello</p>
<p>结果为<code>Hello 李四</code></p>
<h3 id="3-其他注解">3、其他注解</h3>
<p><strong>@PropertySource</strong></p>
<p>作用：加载指定的properties配置文件</p>
<p>1、新建一个person.properties文件</p>
<pre><code class="language-properties">person.age=12
person.boss=false
person.last-name=李四
person.maps.k1=v1
person.maps.k2=v2
person.lists=a,b,c
person.dog.name=wanghuahu
person.dog.age=15

</code></pre>
<p>2、在javaBean中加入@PropertySource注解</p>
<pre><code class="language-java">@PropertySource(value = {&quot;classpath:person.properties&quot;})
@Component
@ConfigurationProperties(prefix = &quot;person&quot;)
public class Person {
    private String lastName;

</code></pre>
<p><strong>@ImportResource</strong></p>
<p>作用：导入Spring配置文件，并且让这个配置文件生效</p>
<p>1、新建一个Spring的配置文件，bean.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;HelloService&quot; class=&quot;com.wdjr.springboot.service.HelloService&quot;&gt;&lt;/bean&gt;
&lt;/beans&gt;

</code></pre>
<p>2、编写测试类，检查容器是否加载Spring配置文件写的bean</p>
<pre><code class="language-java">@Autowired
ApplicationContext ioc;

@Test
public void testHelloService(){
    boolean b = ioc.containsBean(&quot;HelloService&quot;);
    System.out.println(b);
}

</code></pre>
<blockquote>
<p>import org.springframework.context.ApplicationContext;</p>
</blockquote>
<p>3、运行检测</p>
<p>结果为false，没有加载配置的内容</p>
<p>4、使用@ImportResource注解</p>
<p>将@ImportResource标注在主配置类上</p>
<pre><code class="language-java">@ImportResource(locations={&quot;classpath:beans.xml&quot;})
@SpringBootApplication
public class SpringBoot02ConfigApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringBoot02ConfigApplication.class, args);
    }
}

</code></pre>
<p>5、再次运行检测</p>
<p>结果为true</p>
<p>缺点：每次指定xml文件太麻烦</p>
<p>SpringBoot推荐给容器添加组件的方式：</p>
<p>1、配置类=====Spring的xml配置文件（old）</p>
<p>2、全注解方式@Configuration+@Bean（new）</p>
<figure data-type="image" tabindex="2"><img src="https://stormga.github.io//post-images/4.MyAppConfig.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-java">/**
 * @Configuration：指明当前类是一个配置类；就是来代替之前的Spring配置文件
 *
 * 在配置文件中用&lt;bean&gt;&lt;/bean&gt;标签添加组件
 */

@Configuration
public class MyAppConfig {

    //将方法的返回值添加到容器中；容器这个组件id就是方法名
    @Bean
    public HelloService helloService01(){
        System.out.println(&quot;配置类给容器添加了HelloService组件&quot;);
        return new HelloService();
    }
}

</code></pre>
<pre><code class="language-java">@Autowired
ApplicationContext ioc;

@Test
public void testHelloService(){
    boolean b = ioc.containsBean(&quot;helloService01&quot;);
    System.out.println(b);
}

</code></pre>
<p><em>容器这个组件id就是方法名</em></p>
<h2 id="4-配置文件占位符">4、配置文件占位符</h2>
<h4 id="1-随机数">1、随机数</h4>
<pre><code class="language-properties">${random.value} 、${random.int}、${random.long}
${random.int(10)}、${random.int[100,200]}

</code></pre>
<h4 id="2-获取配置值">2、获取配置值</h4>
<pre><code class="language-properties">person.age=${random.int}
person.boss=false
person.last-name=张三${random.uuid}
person.maps.k1=v1
person.maps.k2=v2
person.lists=a,b,c
person.dog.name=${person.last-name}'s wanghuahu
person.dog.age=15

</code></pre>
<p>存在以下两种情况</p>
<p>没有声明<code>person.last-name</code>会报错，新声明的需要加默认值</p>
<pre><code class="language-properties">person.age=${random.int}
person.boss=false
person.last-name=张三${random.uuid}
person.maps.k1=v1
person.maps.k2=v2
person.lists=a,b,c
person.dog.name=${person.hello:hello}'s wanghuahu
person.dog.age=15

</code></pre>
<p>结果：输出<code>hello's wanghuahua</code></p>
<h2 id="5-profile">5、Profile</h2>
<h3 id="1-多profile文件">1、多Profile文件</h3>
<p>我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml</p>
<ul>
<li>application.properties</li>
<li>application-dev.properties</li>
<li>application-prod.properties</li>
</ul>
<p>默认使用application.properties</p>
<p>application.properties配置文件指定</p>
<pre><code class="language-properties">spring.profiles.active=dev

</code></pre>
<h3 id="2-yaml文档块">2、YAML文档块</h3>
<pre><code class="language-yaml">server:
  port: 8081
spring:
  profiles:
    active: dev

---

server:
  port: 9000
spring:
  profiles: dev

---
server:
  port: 80
spring:
  profiles: prod


</code></pre>
<h3 id="3-激活指定profile">3、激活指定profile</h3>
<p>1、在配置文件中激活</p>
<p>2、命令行：</p>
<p>--spring.profiles.active=dev</p>
<figure data-type="image" tabindex="3"><img src="https://stormga.github.io//post-images/5.comandLine.jpg" alt="" loading="lazy"></figure>
<p>优先级大于配置文件</p>
<p>打包 成jar后</p>
<p><code>java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar --spring.profiles.active=dev</code></p>
<p>虚拟机参数</p>
<p><code>-Dspring.profiles.active=dev</code></p>
<h2 id="6-加载配置文件位置">6、加载配置文件位置</h2>
<p>SpringBoot启动扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件</p>
<ul>
<li>file:./config/</li>
<li>file./</li>
<li>classpath:/config/</li>
<li>classpath:/</li>
</ul>
<p>优先级从高到低顺序，高优先级会覆盖低优先级的相同配置；互补配置</p>
<p>也可以通过spring.config.location来改变默认配置</p>
<blockquote>
<pre><code>server.servlet.context-path=/boot03

</code></pre>
</blockquote>
<p>注：spring boot1x 是server.context.path=/boot02</p>
<figure data-type="image" tabindex="4"><img src="https://stormga.github.io//post-images/7.priority.jpg" alt="" loading="lazy"></figure>
<p>还可以通过spring.config.location来改变配置文件的位置</p>
<p>项目打包好了以后，可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认的配置文件会共同起作用，互补配置</p>
<p><code>java -jar spring-boot-config-02-0.0.1-SNAPSHOT.jar --spring.config.location=E:/work/application.properties</code></p>
<p>运维比较有用，从外部加载，不用修改别的文件</p>
<h2 id="7引入外部配置">7.引入外部配置</h2>
<p><strong>SpringBoot也可以从以下位置加载配置；优先级从高到低；高优先级覆盖低优先级，可以互补</strong></p>
<ol>
<li>
<p>命令行参数</p>
<p>java -jar spring-boot-config-02-0.0.1-SNAPSHOT.jar --server.port=9005 --server.context-path=/abc</p>
<p>中间一个空格</p>
</li>
<li>
<p>来自java:comp/env的JNDI属性</p>
</li>
<li>
<p>java系统属性（System.getProperties()）</p>
</li>
<li>
<p>操作系统环境变量</p>
</li>
<li>
<p>RandomValuePropertySource配置的random.*属性值</p>
<p><strong>优先加载profile,    由jar包外到jar包内</strong></p>
</li>
<li>
<p><strong>jar包外部的application-{profile}.properties或application.yml(带Spring.profile)配置文件</strong></p>
</li>
<li>
<p><strong>jar包内部的application-{profile}.properties或application.yml(带Spring.profile)配置文件</strong></p>
</li>
<li>
<p><strong>jar包外部的application.properties或application.yml(带Spring.profile)配置文件</strong></p>
</li>
<li>
<p><strong>jar包内部的application.properties或application.yml(不带spring.profile)配置文件</strong></p>
</li>
<li>
<p>@Configuration注解类的@PropertySource</p>
</li>
<li>
<p>通过SpringApplication.setDefaultProperties指定的默认属性</p>
</li>
</ol>
<p><a href="https://docs.spring.io/spring-boot/docs/2.0.1.RELEASE/reference/htmlsingle/#boot-features-external-config">官方文档</a></p>
<h2 id="8-自动配置">8、自动配置</h2>
<p>配置文件到底怎么写？</p>
<p><a href="https://docs.spring.io/spring-boot/docs/2.0.1.RELEASE/reference/htmlsingle/#common-application-properties">Spring的所有配置参数</a></p>
<p>自动配置原理很关键</p>
<h3 id="1-自动配置原理">1、自动配置原理</h3>
<p>1）、SpringBoot启动的时候加载主配置类，开启自动配置功能，@EnableAutoConfiguration</p>
<p>2）、@EnableAutoConfiguration 作用：</p>
<ul>
<li>利用AutoConfigurationImportSelector给容器中导入一些组件？</li>
<li>可以查看selectImports()方法的内容</li>
<li>获取候选的配置</li>
</ul>
<pre><code class="language-java">List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes);

</code></pre>
<ul>
<li>扫描类路径下的</li>
</ul>
<pre><code class="language-java">  SpringFactoriesLoader.loadFactoryNames(）
  扫描所有jar包类路径下的 MATA-INF/spring.factories
  把扫描到的这些文件的内容包装成properties对象
  从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加到容器中

</code></pre>
<p>将类路径下 MATE-INF/spring.factories里面配置的所有的EnableAutoConfiguration的值加入到了容器中；</p>
<p>3）、每一个自动配置类进行自动配置功能；</p>
<p>4）、以<strong>HttpEncodingAutoConfiguration</strong> 为例</p>
<pre><code class="language-java">@Configuration //表示是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件
@EnableConfigurationProperties({HttpEncodingProperties.class})//启动指定类的Configurationproperties功能；将配置文件中的值和HttpEncodingProperties绑定起来了；并把HttpEncodingProperties加入ioc容器中
@ConditionalOnWebApplication//根据不同的条件，进行判断，如果满足条件，整个配置类里面的配置就会失效，判断是否为web应用；
(
    type = Type.SERVLET
)
@ConditionalOnClass({CharacterEncodingFilter.class})//判断当前项目有没有这个类，解决乱码的过滤器
@ConditionalOnProperty(
    prefix = &quot;spring.http.encoding&quot;,
    value = {&quot;enabled&quot;},
    matchIfMissing = true
)//判断配置文件是否存在某个配置 spring.http.encoding，matchIfMissing = true如果不存在也是成立，即使不配置也生效
public class HttpEncodingAutoConfiguration {
   //给容器添加组件，这个组件的值需要从properties属性中获取
    private final HttpEncodingProperties properties;
	//只有一个有参数构造器情况下，参数的值就会从容器中拿
    public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) {
        this.properties = properties;
    }

    @Bean
    @ConditionalOnMissingBean
    public CharacterEncodingFilter characterEncodingFilter() {
        CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();
        filter.setEncoding(this.properties.getCharset().name());
        filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpEncodingProperties.Type.REQUEST));
        filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpEncodingProperties.Type.RESPONSE));
        return filter;
    }


</code></pre>
<p>5）、所有在配置文件中能配置的属性都是在xxxProperties类中封装着；配置文件能配置什么就可以参照某个功能对应的这个属性类</p>
<pre><code class="language-java">@ConfigurationProperties(prefix = &quot;spring.http.encoding&quot;)//从配置文件中的值进行绑定和bean属性进行绑定
public class HttpEncodingProperties {

</code></pre>
<p>根据当前不同条件判断，决定这个配置类是否生效？</p>
<p>一旦这个配置类生效；这个配置类会给容器添加各种组件；这些组件的属性是从对应的properties中获取的，这些类里面的每个属性又是和配置文件绑定的</p>
<h3 id="2-所有的自动配置组件">2、所有的自动配置组件</h3>
<p>每一个xxxAutoConfiguration这样的类都是容器中的一个组件，都加入到容器中；</p>
<p>作用：用他们做自动配置</p>
<pre><code class="language-properties"># Auto Configure
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\
org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\
org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\
org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\
org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\
org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\
org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\
org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\
org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\
org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\
org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\
org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\
org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\
org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\
org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\
org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\
org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\
org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\
org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\
org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\
org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\
org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\
org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\
org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\
org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\
org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,\
org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,\
org.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,\
org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\
org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\
org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\
org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\
org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\
org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\
org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\
org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\
org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\
org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\
org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\
org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\
org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\
org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\
org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\
org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\
org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,\
org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\
org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\
org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\
org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\
org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\
org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\
org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\
org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\
org.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,\
org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\
org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\
org.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\
org.springframework.boot.autoconfigure.reactor.core.ReactorCoreAutoConfiguration,\
org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\
org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,\
org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,\
org.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,\
org.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,\
org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\
org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\
org.springframework.boot.autoconfigure.security.oauth2.client.OAuth2ClientAutoConfiguration,\
org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\
org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\
org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\
org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\
org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\
org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,\
org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration,\
org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,\
org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,\
org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\
org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,\
org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\
org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\
org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\
org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\
org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\
org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\
org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\
org.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,\
org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,\
org.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,\
org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration


</code></pre>
<h3 id="3-精髓">3、精髓：</h3>
<p>1）、SpringBoot启动会加载大量的自动配置类</p>
<p>2）、我们看我们需要的功能有没有SpringBoot默认写好的默认配置类；</p>
<p>3）、如果有在看这个自动配置类中配置了哪些组件；（只要我们要用的组件有，我们需要再来配置）</p>
<p>4）、给容器中自动配置添加组件的时候，会从properties类中获取属性。我们就可以在配置文件中指定这些属性的值</p>
<p>xxxAutoConfiguration:自动配置类；</p>
<p>给容器中添加组件</p>
<p>xxxProperties:封装配置文件中的属性；</p>
<p>跟之前的Person类一样，配置文件中值加入bean中</p>
<h3 id="4-细节">4、细节</h3>
<h4 id="1-conditional派生注解">1、@Conditional派生注解</h4>
<blockquote>
<p>利用Spring注解版原生的@Conditional作用</p>
</blockquote>
<p>作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；</p>
<table>
<thead>
<tr>
<th>@Conditional派生注解</th>
<th>作用（判断是否满足当前指定条件）</th>
</tr>
</thead>
<tbody>
<tr>
<td>@ConditionalOnJava</td>
<td>系统的java版本是否符合要求</td>
</tr>
<tr>
<td>@ConditionalOnBean</td>
<td>容器中存在指定Bean</td>
</tr>
<tr>
<td>@ConditionalOnMissBean</td>
<td>容器中不存在指定Bean</td>
</tr>
<tr>
<td>@ConditionalOnExpression</td>
<td>满足spEL表达式</td>
</tr>
<tr>
<td>@ConditionalOnClass</td>
<td>系统中有指定的类</td>
</tr>
<tr>
<td>@ConditionalOnMissClass</td>
<td>系统中没有指定的类</td>
</tr>
<tr>
<td>@ConditionalOnSingleCandidate</td>
<td>容器中只有一个指定的Bean,或者这个Bean是首选Bean</td>
</tr>
<tr>
<td>@ConditionalOnProperty</td>
<td>系统中指定的属性是否有指定的值</td>
</tr>
<tr>
<td>@ConditionalOnResource</td>
<td>类路径下是否存在指定的资源文件</td>
</tr>
<tr>
<td>@ConditionalOnWebApplication</td>
<td>当前是web环境</td>
</tr>
<tr>
<td>@ConditionalOnNotWebApplication</td>
<td>当前不是web环境</td>
</tr>
<tr>
<td>@ConditionalOnJndi</td>
<td>JNDI存在指定项</td>
</tr>
</tbody>
</table>
<h4 id="2-自动配置报告">2、自动配置报告</h4>
<p>自动配置类必须在一定条件下生效</p>
<p>我们可以通过启用debug=true属性，配置文件，打印自动配合报告，这样就可以知道自动配置类生效</p>
<pre><code class="language-properties">debug=true

</code></pre>
<p>自动配置报告</p>
<pre><code class="language-java">============================

CONDITIONS EVALUATION REPORT
============================


Positive matches:（启动的，匹配成功的）
-----------------

   CodecsAutoConfiguration matched:
      - @ConditionalOnClass found required class 'org.springframework.http.codec.CodecConfigurer'; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition)
        ......
        
 Negative matches:（没有启动的，没有匹配成功的）
-----------------

   ActiveMQAutoConfiguration:
      Did not match:
         - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' (OnClassCondition)
.....

</code></pre>
<h1 id="三-日志">三、日志</h1>
<blockquote>
<p>Spring Boot2对日志有更改</p>
</blockquote>
<h3 id="1-日志框架">1、日志框架</h3>
<p>小张：开发一个大型系统；</p>
<p>1、System.out.println(&quot;&quot;);将关键数据打印在控制台；去掉？卸载文件中</p>
<p>2、框架记录系统的一些运行信息；日志框架zhanglog.jar</p>
<p>3、高大上功能，异步模式？自动归档？xxx?zhanglog-good.jar?</p>
<p>4、将以前的框架卸下来？换上新的框架，重新修改之前的相关API;zhanglog-perfect.jar;</p>
<p>5、JDBC--数据库驱动；</p>
<p>​	写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar;</p>
<p>​	给项目中导入具体的日志实现就行；我们之前的日志框架都是实现的抽象层；</p>
<p>市面上的日志框架</p>
<table>
<thead>
<tr>
<th>日志抽象层</th>
<th>日志实现</th>
</tr>
</thead>
<tbody>
<tr>
<td><s>JCL(Jakarta Commons Logging)</s> SLF4j(Simple Logging Facade for Java) <s>jboss-logging</s></td>
<td>Log4j <s>JUL(java.util.logging)</s> Log4j2 Logback</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>左边的抽象，右边的实现</p>
<p>SLF4J  -- Logback</p>
<p>Spring Boot:底层是Spring框架，Spring默认框架是JCL；</p>
<p>​	SpringBoot选用SLF4J和logback</p>
<h3 id="2-slf4j使用">2、SLF4J使用</h3>
<h4 id="1-如何在系统中使用slf4j">1、如何在系统中使用SLF4j</h4>
<p>以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法；</p>
<p>应该给系统里面导入slf4j的jar包和logback的实现jar</p>
<pre><code class="language-java">import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class HelloWorld {
  public static void main(String[] args) {
    Logger logger = LoggerFactory.getLogger(HelloWorld.class);
    logger.info(&quot;Hello World&quot;);
  }
}

</code></pre>
<figure data-type="image" tabindex="5"><img src="https://stormga.github.io//post-images/8.slf4j.jpg" alt="" loading="lazy"></figure>
<p>每个日志框架的实现框架都有自己的配置文件。使用slf4j以后，<strong>配置文件还是做成日志实现框架本身的配置文件</strong>；</p>
<h4 id="2-遗留问题">2、遗留问题</h4>
<p>a系统(slf4j+logback)：Spring（commons-logging）、Hibernate（jboss-logging）、Mybatis</p>
<p>统一日志框架，即使是别的框架和我一起统一使用slf4j进行输出；</p>
<p>核心：</p>
<p>1、将系统中其他日志框架排除出去；</p>
<p>2、用中间包来替换原有的日志框架</p>
<p>3、导入slf4j的其他实现</p>
<h3 id="3-spingboot日志框架解析">3、SpingBoot日志框架解析</h3>
<p>打开IDEA ，打开pom文件的依赖图形化显示</p>
<figure data-type="image" tabindex="6"><img src="https://stormga.github.io//post-images/9.IDEAdependencies.jpg" alt="" loading="lazy"></figure>
<p>SpringBoot的基础框架</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;

</code></pre>
<p>SpringBoot的日志功能</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;
    &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;

</code></pre>
<figure data-type="image" tabindex="7"><img src="https://stormga.github.io//post-images/10.slf4jandlogback.jpg" alt="" loading="lazy"></figure>
<p>总结：</p>
<ol>
<li>
<p>SpringBoot底层也是使用SLF4J+log4jback</p>
</li>
<li>
<p>SpringBoot也把其他日志替换成了slf4j</p>
</li>
<li>
<p>起着commons.loggings的名字其实new的SLF4J替换中间包</p>
<p>SpringBoot2中改成了bridge</p>
</li>
<li>
<p>如果要引入其他框架？一定要把这个框架的日志依赖移除掉，而且底层</p>
</li>
</ol>
<h3 id="4-日志的使用">4、日志的使用</h3>
<h4 id="1-默认配置">1、默认配置</h4>
<p>trace-debug-info-warn-error</p>
<p>可以调整需要的日志级别进行输出，不用注释语句。</p>
<pre><code class="language-java">//记录器
Logger logger = LoggerFactory.getLogger(getClass());
@Test
public void contextLoads() {

    //日志的级别
    //从低到高
    //可以调整输出的日志级别；日志就只会在这个级别以后的高级别生效
    logger.trace(&quot;这是trace日志&quot;);
    logger.debug(&quot;这是debug信息&quot;);
    //SpringBoot默认给的是info级别，如果没指定就是默认的root级别
    logger.info(&quot;这是info日志&quot;);
    logger.warn(&quot;这是warn信息&quot;);
    logger.error(&quot;这是Error信息&quot;);
}

</code></pre>
<p>调整指定包的日志级别在配置文件中进行配置</p>
<pre><code class="language-properties">logging.level.cn.lkhcoding=trace

</code></pre>
<p>日志输出格式</p>
<pre><code class="language-properties">#控制台输出的日志格式 
#%d：日期
#%thread：线程号 
#%-5level：靠左 级别 
#%logger{50}：全类名50字符限制,否则按照句号分割
#%msg：消息+换行
#%n：换行
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n

</code></pre>
<p>SpringBoot修改日志的默认配置</p>
<pre><code class="language-properties">logging.level.com.wdjr=trace
#不指定path就是当前目录下生成springboot.log
#logging.file=springboot.log
#当前磁盘下根路径创建spring文件中log文件夹，使用spring.log作为默认
logging.path=/spring/log
#控制台输出的日志格式 日期 + 线程号 + 靠左 级别 +全类名50字符限制+消息+换行
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n
#指定文件中日志输出的格式
logging.pattern.file=xxx

</code></pre>
<h4 id="2-指定配置">2、指定配置</h4>
<p>给类路径下放上每个日志框架自己的配置框架；SpringBoot就不会使用自己默认的配置</p>
<table>
<thead>
<tr>
<th>logging System</th>
<th>Customization</th>
</tr>
</thead>
<tbody>
<tr>
<td>Logback</td>
<td>logback-spring.xml ,logback-spring.groovy,logback.xml or logback.groovy</td>
</tr>
<tr>
<td>Log4J2</td>
<td>log4j2-spring.xml or log4j2.xml</td>
</tr>
<tr>
<td>JDK(Java Util Logging)</td>
<td>logging.properties</td>
</tr>
</tbody>
</table>
<p>logback.xml直接被日志框架识别 ，logback-spring.xml日志框架就不直接加载日志配置项，由SpringBoot加载</p>
<pre><code class="language-xml">&lt;springProfile name=&quot;dev&quot;&gt;
	&lt;!-- 可以指定某段配置只在某个环境下生效 --&gt;
&lt;/springProfile&gt;
&lt;springProfile name!=&quot;dev&quot;&gt;
	&lt;!-- 可以指定某段配置只在某个环境下生效 --&gt;
&lt;/springProfile&gt;

</code></pre>
<p>如何调试开发环境,输入命令行参数</p>
<p>--spring.profiles.active=dev</p>
<p>如果不带后面的xx-spring.xml就会报错</p>
<h3 id="3-切换日志框架">3、切换日志框架</h3>
<p>可以根据slf4j的日志适配图，进行相关切换；</p>
<h4 id="1-log4j">1、log4j</h4>
<p>slf4j+log4j的方式；</p>
<figure data-type="image" tabindex="8"><img src="https://stormga.github.io//post-images/11.log4j.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
&lt;/dependency&gt;

</code></pre>
<p>不推荐使用仅作为演示</p>
<h4 id="2-log4j2">2、log4j2</h4>
<p>切换为log4j2</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;
&lt;/dependency&gt;

</code></pre>
<h1 id="四-web开发">四、web开发</h1>
<h2 id="1-简介">1、简介</h2>
<p>使用SpringBoot;</p>
<p>1)、创建SpringBoot应用，选中我们需要的模块；</p>
<p>2)、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来</p>
<p>3)、自己编写业务代码</p>
<p><strong>自动配置原理？</strong></p>
<p>这个场景的SpringBoot帮我们配置了什么？能不能修改？能修改那些配置？能不能扩展？xxx</p>
<pre><code class="language-java">xxxAutoConfiguration:帮我们给容器中自动配置组件
xxxProperties:配置类来封装配置文件的内容

</code></pre>
<h2 id="2-静态资源文件映射规则">2、静态资源文件映射规则</h2>
<pre><code class="language-java">@ConfigurationProperties(prefix = &quot;spring.resources&quot;, ignoreUnknownFields = false)
public class ResourceProperties implements ResourceLoaderAware, InitializingBean {
    //可以设置和静态资源相关的参数，缓存时间等

</code></pre>
<pre><code class="language-java">@Override
public void addResourceHandlers(ResourceHandlerRegistry registry) {
   if (!this.resourceProperties.isAddMappings()) {
      logger.debug(&quot;Default resource handling disabled&quot;);
      return;
   }
   Integer cachePeriod = this.resourceProperties.getCachePeriod();
   if (!registry.hasMappingForPattern(&quot;/webjars/**&quot;)) {
      customizeResourceHandlerRegistration(registry
            .addResourceHandler(&quot;/webjars/**&quot;)
            .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;)
            .setCachePeriod(cachePeriod));
   }
   String staticPathPattern = this.mvcProperties.getStaticPathPattern();
   if (!registry.hasMappingForPattern(staticPathPattern)) {
      customizeResourceHandlerRegistration(
            registry.addResourceHandler(staticPathPattern)
                  .addResourceLocations(
                        this.resourceProperties.getStaticLocations())
                  .setCachePeriod(cachePeriod));
   }
}

</code></pre>
<h3 id="1-webjar">1、webjar</h3>
<p>1)、所有的/webjars/**，都去classpath:/META-INF/resources/webjars/找资源；</p>
<p>​	webjars：以jar包的方式引入静态资源</p>
<p>http://www.webjars.org/</p>
<figure data-type="image" tabindex="9"><img src="https://stormga.github.io//post-images/12.jquery.jpg" alt="" loading="lazy"></figure>
<p>localhost:8080/webjars/jquery/3.3.1/jquery.js</p>
<h3 id="2-本地资源">2、本地资源</h3>
<pre><code>private String staticPathPattern = &quot;/**&quot;;

</code></pre>
<p>访问任何资源</p>
<p>2、会在这几文件夹下去找静态路径（静态资源文件夹）</p>
<pre><code>&quot;classpath:/META-INF/resources/&quot;, 
&quot;classpath:/resources/&quot;,
&quot;classpath:/static/&quot;, 
&quot;classpath:/public/&quot;,
&quot;/&quot;;当前项目的根路径

</code></pre>
<figure data-type="image" tabindex="10"><img src="https://stormga.github.io//post-images/13.static.jpg" alt="" loading="lazy"></figure>
<p>localhost:8080/abc ==&gt;去静态资源文件夹中找abc</p>
<figure data-type="image" tabindex="11"><img src="https://stormga.github.io//post-images/14.static-css.jpg" alt="" loading="lazy"></figure>
<p>3、index页面欢迎页，静态资源文件夹下所有的index.html页面；被“/**”映射；</p>
<p>localhost:8080/  --&gt;index页面</p>
<pre><code class="language-JAVA">@Bean
public WelcomePageHandlerMapping welcomePageHandlerMapping(
      ResourceProperties resourceProperties) {
   return new WelcomePageHandlerMapping(resourceProperties.getWelcomePage(),
         this.mvcProperties.getStaticPathPattern());
}

</code></pre>
<p>4、喜欢的图标，即网站title的图标favicon</p>
<pre><code class="language-java">@Configuration
@ConditionalOnProperty(value = &quot;spring.mvc.favicon.enabled&quot;, matchIfMissing = true)
public static class FaviconConfiguration {

   private final ResourceProperties resourceProperties;

   public FaviconConfiguration(ResourceProperties resourceProperties) {
      this.resourceProperties = resourceProperties;
   }

   @Bean
   public SimpleUrlHandlerMapping faviconHandlerMapping() {
      SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping();
      mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1);
       //把任何favicon的图标都在静态文件夹下找
      mapping.setUrlMap(Collections.singletonMap(&quot;**/favicon.ico&quot;,
            faviconRequestHandler()));
      return mapping;
   }

   @Bean
   public ResourceHttpRequestHandler faviconRequestHandler() {
      ResourceHttpRequestHandler requestHandler = new ResourceHttpRequestHandler();
      requestHandler
            .setLocations(this.resourceProperties.getFaviconLocations());
      return requestHandler;
   }

}

</code></pre>
<p>可以在配置文件配置静态资源文件夹</p>
<pre><code class="language-properties">spring.resources.static-locations=classpath:xxxx

</code></pre>
<h2 id="3-模板引擎">3、模板引擎</h2>
<p>将html和数据 结合到一起 输出组装处理好的新文件</p>
<p>SpringBoot推荐Thymeleaf;语法简单，功能强大</p>
<h3 id="1-引入thymeleaf-3">1、引入thymeleaf 3</h3>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
&lt;/dependency&gt;

</code></pre>
<p>默认导入thymeleaf2，版本太低 所以使用thymeleaf3.</p>
<p><a href="https://docs.spring.io/spring-boot/docs/1.5.12.RELEASE/reference/htmlsingle/#howto-use-thymeleaf-3">官方导入办法</a></p>
<pre><code class="language-xml">&lt;properties&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
    &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;!--thymeleaf 3的导入--&gt;
    &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt;
    &lt;!--布局功能支持 同时支持thymeleaf3主程序 layout2.0以上版本  --&gt;
    &lt;!--布局功能支持 同时支持thymeleaf2主程序 layout1.0以上版本  --&gt;
    &lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt;
&lt;/properties&gt;

</code></pre>
<h3 id="2-thymeleaf使用和语法">2、Thymeleaf使用和语法</h3>
<pre><code class="language-java">@ConfigurationProperties(prefix = &quot;spring.thymeleaf&quot;)
public class ThymeleafProperties {

   private static final Charset DEFAULT_ENCODING = Charset.forName(&quot;UTF-8&quot;);

   private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf(&quot;text/html&quot;);

   public static final String DEFAULT_PREFIX = &quot;classpath:/templates/&quot;;

   public static final String DEFAULT_SUFFIX = &quot;.html&quot;;
   //只要把HTML文件方法类路径下的template文件夹下，就会自动导入

</code></pre>
<p>只要把HTML页面放到classpath:/templates/,thymeleaf就能自动渲染；</p>
<p>使用：</p>
<p>1、导入thymeleaf的名称空间</p>
<pre><code class="language-html">&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;    

</code></pre>
<p>2、使用thymeleaf语法；</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;  xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;title&gt;success&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;success&lt;/h1&gt;
&lt;!--th:text 将div里面的文本内容设置为--&gt;
&lt;div th:text=&quot;${Lion}&quot;&gt;
前端数据
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<p>3、语法规则</p>
<p>1）、th:text=&quot;${hello}&quot;可以使用任意标签 替换原生的任何属性</p>
<p><strong>在SpringBoot的环境下</strong></p>
<pre><code class="language-html">&lt;div id=&quot;testid&quot; class=&quot;testcalss&quot; th:id=&quot;${Lion}&quot; th:class=&quot;${Lion}&quot; th:text=&quot;${Lion}&quot;&gt;
	前端数据
&lt;/div&gt;

</code></pre>
<figure data-type="image" tabindex="12"><img src="https://stormga.github.io//post-images/15.thtmeleaf-th01.jpg" alt="" loading="lazy"></figure>
<p><strong>直接访问HTML页面</strong></p>
<figure data-type="image" tabindex="13"><img src="https://stormga.github.io//post-images/15.thtmeleaf-th02.jpg" alt="" loading="lazy"></figure>
<p><strong>2)、内联写法注意需要在body上加上 th:inline=&quot;text&quot;敲黑板</strong></p>
<p>不然不起作用</p>
<pre><code class="language-html">&lt;body class=&quot;text-center&quot; th:inline=&quot;text&quot;&gt;&lt;/body&gt;

</code></pre>
<p>th标签的访问优先级</p>
<p>Order Feature Attributes</p>
<h3 id="3-语法规则">3、语法规则</h3>
<table>
<thead>
<tr>
<th></th>
<th>功能</th>
<th>标签</th>
<th>功能和jsp对比</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Fragment inclusion</td>
<td>th:insert th:replace</td>
<td>include(片段包含)</td>
</tr>
<tr>
<td>2</td>
<td>Fragment iteration</td>
<td>th:each</td>
<td>c:forEach(遍历)</td>
</tr>
<tr>
<td>3</td>
<td>Conditional evaluation</td>
<td>th:if th:unless th:switch th:case</td>
<td>c:if(条件判断)</td>
</tr>
<tr>
<td>4</td>
<td>Local variable definition</td>
<td>th:object  th:with</td>
<td>c:set(声明变量)</td>
</tr>
<tr>
<td>5</td>
<td>General attribute modification</td>
<td>th:attr th:attrprepend th:attrappend</td>
<td>属性修改支持前面和后面追加内容</td>
</tr>
<tr>
<td>6</td>
<td>Specific attribute modification</td>
<td>th:value th:href th:src ...</td>
<td>修改任意属性值</td>
</tr>
<tr>
<td>7</td>
<td>Text (tag body modification)</td>
<td>th:text th:utext</td>
<td>修改标签体内容utext：不转义字符<h1>大标题</td>
</tr>
<tr>
<td>8</td>
<td>Fragment specification</td>
<td>th:fragment</td>
<td>声明片段</td>
</tr>
<tr>
<td>9</td>
<td>Fragment removal</td>
<td>th:remove</td>
<td></td>
</tr>
</tbody>
</table>
<pre><code class="language-properties">Simple expressions:(表达式语法)
    Variable Expressions: ${...}
    	1、获取对象属性、调用方法
    	2、使用内置基本对象：
    	    #ctx : the context object.
            #vars: the context variables.
            #locale : the context locale.
            #request : (only in Web Contexts) the HttpServletRequest object.
            #response : (only in Web Contexts) the HttpServletResponse object.
            #session : (only in Web Contexts) the HttpSession object.
            #servletContext : (only in Web Contexts) the ServletContext object.
         3、内置一些工具对象
        	#execInfo : information about the template being processed.
        	#messages : methods for obtaining externalized messages inside variables expressions, in the same way as they
            would be obtained using #{…} syntax.
            #uris : methods for escaping parts of URLs/URIs
            #conversions : methods for executing the configured conversion service (if any).
            #dates : methods for java.util.Date objects: formatting, component extraction, etc.
            #calendars : analogous to #dates , but for java.util.Calendar objects.
            #numbers : methods for formatting numeric objects.
            #strings : methods for String objects: contains, startsWith, prepending/appending, etc.
            #objects : methods for objects in general.
            #bools : methods for boolean evaluation.
            #arrays : methods for arrays.
            #lists : methods for lists.
            #sets : methods for sets.
            #maps : methods for maps.
            #aggregates : methods for creating aggregates on arrays or collections.
            #ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration).
    Selection Variable Expressions: *{...} //选择表达式：和${}功能一样，补充功能
   # 配合th:object使用，object=${object} 以后获取就可以使用*{a}  相当于${object.a}
  	    &lt;div th:object=&quot;${session.user}&quot;&gt;
            &lt;p&gt;Name: &lt;span th:text=&quot;*{firstName}&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt;
            &lt;p&gt;Surname: &lt;span th:text=&quot;*{lastName}&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt;
            &lt;p&gt;Nationality: &lt;span th:text=&quot;*{nationality}&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt;
		&lt;/div&gt;
    Message Expressions: #{...} //获取国际化内容
    Link URL Expressions: @{...} //定义URL链接
    	#&lt;a href=&quot;details.html&quot; th:href=&quot;@{/order/details(orderId=${o.id})}&quot;&gt;view&lt;/a&gt;
    Fragment Expressions: ~{...}//片段文档
    
Literals（字面量）
    Text literals: 'one text' , 'Another one!' ,…
    Number literals: 0 , 34 , 3.0 , 12.3 ,…
    Boolean literals: true , false
    Null literal: null
    Literal tokens: one , sometext , main ,…
Text operations:(文本操作)
    String concatenation: +
    Literal substitutions: |The name is ${name}|
Arithmetic operations:（数学运算）
    Binary operators: + , - , * , / , %
    Minus sign (unary operator): -
Boolean operations:（布尔运算）
    Binary operators: and , or
    Boolean negation (unary operator): ! , not
Comparisons and equality:（比较运算）
    Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le )
    Equality operators: == , != ( eq , ne )
Conditional operators:（条件运算）
    If-then: (if) ? (then)
    If-then-else: (if) ? (then) : (else)
    Default: (value) ?: (defaultvalue)
Special tokens:（空操作）
	No-Operation: _

</code></pre>
<p>inline写法</p>
<pre><code class="language-html">[[]] --&gt;th:text
[()] --&gt;th:utext

</code></pre>
<h2 id="4-springmvc自动配置">4、SpringMVC自动配置</h2>
<h3 id="1-springmvc的自动导入">1、SpringMVC的自动导入</h3>
<p><a href="https://docs.spring.io/spring-boot/docs/1.5.12.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications">Spring框架</a></p>
<p>自动配置好了mvc：</p>
<p>以下是SpringBoot对SpringMVC的默认</p>
<p>Spring Boot provides auto-configuration for Spring MVC that works well with most applications.</p>
<p>The auto-configuration adds the following features on top of Spring’s defaults:</p>
<ul>
<li>
<p>Inclusion of <code>ContentNegotiatingViewResolver</code> and <code>BeanNameViewResolver</code> beans.</p>
<ul>
<li>自动配置了ViewResolver(视图解析器：根据方法的返回值得到视图对象（View）,视图对象决定如何渲染（转发？重定向？）)</li>
<li><code>ContentNegotiatingViewResolver</code>组合所有视图解析器</li>
<li>如何定制：我们可以自己给容器中添加一个视图解析器；自动将其整合进来</li>
</ul>
</li>
<li>
<p>Support for serving static resources, including support for WebJars (see below).静态资源</p>
</li>
<li>
<p>Static <code>index.html</code> support.</p>
</li>
<li>
<p>Custom <code>Favicon</code> support (see below).</p>
</li>
<li>
<p>自动注册 了<code>Converter</code>, <code>GenericConverter</code>, <code>Formatter</code> beans.</p>
<ul>
<li>
<p><code>Converter</code>：类型转换 文本转为字面量</p>
</li>
<li>
<p><code>Formatter</code> ：格式化器 转换后格式转换</p>
<pre><code class="language-java">@Bean
@ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;date-format&quot;)//在文件配置入职格式化的规则
public Formatter&lt;Date&gt; dateFormatter() {
   return new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件
}

</code></pre>
<p>自己添加的格式化转换器，只需要放在容器中即可</p>
</li>
</ul>
</li>
<li>
<p>Support for <code>HttpMessageConverters</code> (see below).</p>
<ul>
<li>
<p><code>HttpMessageConverters</code> ：转换HTTP转换和响应：User - json</p>
</li>
<li>
<p><code>HttpMessageConverters</code> ：是从容器中确定；获取所有的<code>HttpMessageConverters</code>  ，将自己的组件注册在容器中@Bean</p>
</li>
<li>
<p>If you need to add or customize converters you can use Spring Boot’s <code>HttpMessageConverters</code> class:</p>
<pre><code class="language-java">import org.springframework.boot.autoconfigure.web.HttpMessageConverters;
import org.springframework.context.annotation.*;
import org.springframework.http.converter.*;

@Configuration
public class MyConfiguration {

    @Bean
    public HttpMessageConverters customConverters() {
        HttpMessageConverter&lt;?&gt; additional = ...
        HttpMessageConverter&lt;?&gt; another = ...
        return new HttpMessageConverters(additional, another);
    }

}

</code></pre>
</li>
</ul>
</li>
<li>
<p>Automatic registration of <code>MessageCodesResolver</code> (see below).</p>
<ul>
<li>定义错误代码生成规则</li>
</ul>
</li>
<li>
<p>Automatic use of a <code>ConfigurableWebBindingInitializer</code> bean (see below).</p>
<ul>
<li>
<pre><code class="language-java">@Override
protected ConfigurableWebBindingInitializer getConfigurableWebBindingInitializer() {
   try {
      return this.beanFactory.getBean(ConfigurableWebBindingInitializer.class);
   }
   catch (NoSuchBeanDefinitionException ex) {
      return super.getConfigurableWebBindingInitializer();
   }
}

</code></pre>
<p>在beanFactory：中可以自己创建一个，初始化webDataBinder</p>
<p>请求数据 ==》javaBean</p>
</li>
</ul>
</li>
</ul>
<p>If you want to keep Spring Boot MVC features, and you just want to add additional <a href="https://docs.spring.io/spring/docs/4.3.16.RELEASE/spring-framework-reference/htmlsingle#mvc">MVC configuration</a> (interceptors, formatters, view controllers etc.) you can add your own <code>@Configuration</code> class of type <code>WebMvcConfigurerAdapter</code>, but <strong>without</strong> <code>@EnableWebMvc</code>. If you wish to provide custom instances of <code>RequestMappingHandlerMapping</code>, <code>RequestMappingHandlerAdapter</code> or <code>ExceptionHandlerExceptionResolver</code> you can declare a <code>WebMvcRegistrationsAdapter</code> instance providing such components.</p>
<p>If you want to take complete control of Spring MVC, you can add your own <code>@Configuration</code> annotated with <code>@EnableWebMvc</code>.</p>
<p>思想：修改默认配置</p>
<h3 id="2-扩展springmvc">2、扩展SpringMVC</h3>
<p>编写一个配置类，类型是WebMvcConfigurerAdapter(继承)，使用WebMvcConfigurerAdapter可以扩展，不能标注@EnableWebMvc;既保留了配置，也能拓展我们自己的应用</p>
<pre><code class="language-java">@Configuration
public class MyMvcConfig extends WebMvcConfigurerAdapter {

    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
//        super.addViewControllers(registry);
        //浏览器发送wdjr请求，也来到success页面
        registry.addViewController(&quot;/wdjr&quot;).setViewName(&quot;success&quot;);
    }
}

</code></pre>
<p>原理：</p>
<p>1）、WebMvcAutoConfiguration是SpringMVC的自动配置</p>
<p>2）、在做其他自动配置时会导入；@Import(EnableWebMvcConfiguration.class)</p>
<pre><code class="language-java">@Configuration
public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration {
    private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite();

	//从容器中获取所有webMVCconfigurer
	@Autowired(required = false)
	public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) {
		if (!CollectionUtils.isEmpty(configurers)) {
			this.configurers.addWebMvcConfigurers(configurers);
            
            	@Override
                protected void addViewControllers(ViewControllerRegistry registry) {
                    this.configurers.addViewControllers(registry);
                }
            //一个参考实现,将所有的webMVCconfigurer相关配置一起调用（包括自己的配置类）
            	@Override
               // public void addViewControllers(ViewControllerRegistry registry) {
                   // for (WebMvcConfigurer delegate : this.delegates) {
				 //delegate.addViewControllers(registry);
                    //}
                }
		}
	}
    

</code></pre>
<p>3）、自己的配置被调用</p>
<p>效果：SpringMVC的自动配置和我们的扩展配置都会起作用</p>
<h3 id="3-全面接管mvc">3、全面接管mvc</h3>
<p>不需要SpringBoot对SpringMVC的自动配置。</p>
<pre><code class="language-java">@EnableWebMvc
@Configuration
public class MyMvcConfig extends WebMvcConfigurerAdapter {

@Override
public void addViewControllers(ViewControllerRegistry registry) {


//        super.addViewControllers(registry);
        //浏览器发送wdjr请求，也来到success页面
        registry.addViewController(&quot;/wdjr&quot;).setViewName(&quot;success&quot;);
    }
}

</code></pre>
<p>例如静态资源访问，不推荐全面接管</p>
<p>原理：</p>
<p>为什么@EnableWebMvc注解，SpringBoot对SpringMVC的控制就失效了</p>
<p>1）、核心配置</p>
<pre><code class="language-java">@Import(DelegatingWebMvcConfiguration.class)
public @interface EnableWebMvc {
}

</code></pre>
<p>2）、DelegatingWebMvcConfiguration</p>
<pre><code class="language-java">@Configuration
public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport {

</code></pre>
<p>3）、WebMvcAutoConfiguration</p>
<pre><code class="language-java">@Configuration
@ConditionalOnWebApplication
@ConditionalOnClass({ Servlet.class, DispatcherServlet.class,
      WebMvcConfigurerAdapter.class })
//容器没有这个组件的时候，这个自动配置类才生效
@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
@AutoConfigureAfter({ DispatcherServletAutoConfiguration.class,
      ValidationAutoConfiguration.class })
public class WebMvcAutoConfiguration {

</code></pre>
<p>4）、@EnableWebMvc将WebMvcConfigurationSupport导入进来了；</p>
<p>5）、导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能</p>
<h2 id="5-修改springmvc默认配置">5、修改SpringMVC默认配置</h2>
<p>模式:</p>
<p>​	1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来；</p>
<p>​	2）、在SpringBoot中会有 xxxConfigurer帮助我们扩展配置。</p>
<h2 id="6-restfulcrud">6、RestfulCRUD</h2>
<h3 id="1-默认访问首页">1、默认访问首页</h3>
<p>在config/MyConfig.java中编写配置类</p>
<pre><code class="language-java">//所有的webMvcConfigurerAdapter组件会一起起作用
@Bean //註冊到容器去
public WebMvcConfigurerAdapter webMvcConfigurerAdapter(){
    WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() {
        @Override
        public void addViewControllers(ViewControllerRegistry registry) {
            registry.addViewController(&quot;/&quot;).setViewName(&quot;login&quot;);
            registry.addViewController(&quot;/login.html&quot;).setViewName(&quot;login&quot;);
        }
    };
    return adapter;
}

</code></pre>
<p>静态资源引用</p>
<pre><code class="language-html">&lt;link href=&quot;#&quot; th:href=&quot;@{/css/signin.css}&quot; rel=&quot;stylesheet&quot; /&gt;

</code></pre>
<h3 id="2-国际化">2、国际化</h3>
<p>1、编写国际化配置文件</p>
<p>2、使用ResourceBundleMessageSource管理国际化资源文件</p>
<p>3、在页面中使用fmt:message，取出国际化内容</p>
<h4 id="1-浏览器切换国际化">1、浏览器切换国际化</h4>
<p>步骤</p>
<p>1、编写国际化配置文件，抽取页面需要的显示的国际化消息</p>
<figure data-type="image" tabindex="14"><img src="https://stormga.github.io//post-images/16.national.jpg" alt="" loading="lazy"></figure>
<p>2、SpringBoot自动配置好了国际化配置的资源文件</p>
<pre><code class="language-java">@ConfigurationProperties(prefix = &quot;spring.messages&quot;)
public class MessageSourceAutoConfiguration {
    //我们的配置文件可以直接放在类路径下叫messages.properties
    private String basename = &quot;messages&quot;;
    @Bean
	public MessageSource messageSource() {
		ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();
		if (StringUtils.hasText(this.basename)) {
            //设置国际化文件的基础名，去掉语言国家代码
			messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray(
					StringUtils.trimAllWhitespace(this.basename)));
		}
		if (this.encoding != null) {
			messageSource.setDefaultEncoding(this.encoding.name());
		}
		messageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale);
		messageSource.setCacheSeconds(this.cacheSeconds);
		messageSource.setAlwaysUseMessageFormat(this.alwaysUseMessageFormat);
		return messageSource;
	}

</code></pre>
<p>3、对IDEA的编码进行设置</p>
<figure data-type="image" tabindex="15"><img src="https://stormga.github.io//post-images/17.encoding.jpg" alt="" loading="lazy"></figure>
<p>4、login进行标签插入</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;!-- saved from url=(0051)https://getbootstrap.com/docs/4.1/examples/sign-in/ --&gt;
&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;
    
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot; /&gt;
    &lt;meta name=&quot;description&quot; content=&quot;&quot; /&gt;
    &lt;meta name=&quot;author&quot; content=&quot;&quot; /&gt;
    &lt;link rel=&quot;icon&quot; href=&quot;https://getbootstrap.com/favicon.ico&quot; /&gt;

    &lt;title&gt;登录页面&lt;/title&gt;

    &lt;!-- Bootstrap core CSS --&gt;
    &lt;link href=&quot;#&quot; th:href=&quot;@{/css/bootstrap.min.css}&quot; rel=&quot;stylesheet&quot; /&gt;

    &lt;!-- Custom styles for this template --&gt;
    &lt;link href=&quot;./login_files/signin.css&quot; th:href=&quot;@{/css/signin.css}&quot; rel=&quot;stylesheet&quot; /&gt;
  &lt;/head&gt;

  &lt;body class=&quot;text-center&quot;&gt;
    &lt;form class=&quot;form-signin&quot;&gt;
      &lt;img class=&quot;mb-4&quot; src=&quot;./login_files/bootstrap-solid.svg&quot; th:src=&quot;@{/img/bootstrap-solid.svg}&quot; alt=&quot;&quot; width=&quot;72&quot; height=&quot;72&quot; /&gt;
      &lt;h1 class=&quot;h3 mb-3 font-weight-normal&quot; th:text=&quot;#{login.tip}&quot;&gt;Please sign in&lt;/h1&gt;
      &lt;label  class=&quot;sr-only&quot; th:text=&quot;#{login.username}&quot;&gt;Username&lt;/label&gt;
      &lt;input type=&quot;text&quot;  name=&quot;username&quot; class=&quot;form-control&quot; placeholder=&quot;Username&quot; th:placeholder=&quot;#{login.username}&quot; required=&quot;&quot; autofocus=&quot;&quot;/&gt;
      &lt;label for=&quot;inputPassword&quot; class=&quot;sr-only&quot; th:text=&quot;#{login.password}&quot;&gt;Password&lt;/label&gt;
      &lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;inputPassword&quot; class=&quot;form-control&quot; placeholder=&quot;Password&quot; th:placeholder=&quot;#{login.password}&quot; required=&quot;&quot; /&gt;
      &lt;div class=&quot;checkbox mb-3&quot;&gt;
        &lt;label&gt;
          &lt;input type=&quot;checkbox&quot; value=&quot;remember-me&quot; /&gt; [[#{login.remember}]]
        &lt;/label&gt;
      &lt;/div&gt;
      &lt;button class=&quot;btn btn-lg btn-primary btn-block&quot; type=&quot;submit&quot; th:text=&quot;#{login.btn}&quot;&gt;Sign in&lt;/button&gt;
      &lt;p class=&quot;mt-5 mb-3 text-muted&quot;&gt;© 2017-2018&lt;/p&gt;
    &lt;/form&gt;
  

&lt;/body&gt;&lt;/html&gt;

</code></pre>
<p>效果根据浏览器语言的信息切换国际化</p>
<p>原理：</p>
<p>国际化locale（区域信息对象）；LocaleResolver(获取区域对象)；</p>
<pre><code class="language-java">@Bean
@ConditionalOnMissingBean
@ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;locale&quot;)
public LocaleResolver localeResolver() {
    if (this.mvcProperties
        .getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) {
        return new FixedLocaleResolver(this.mvcProperties.getLocale());
    }
    AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver();
    localeResolver.setDefaultLocale(this.mvcProperties.getLocale());
    return localeResolver;
}            


</code></pre>
<p>默认的就是根据请求头带来的区域信息获取local国际化信息（截图就是这么犀利）</p>
<figure data-type="image" tabindex="16"><img src="https://stormga.github.io//post-images/18.accept-language.jpg" alt="" loading="lazy"></figure>
<h4 id="2-点击链接切换国际化">2、点击链接切换国际化</h4>
<p>自己编写localResolver，加到容器中</p>
<p>1、更改HTML代码</p>
<pre><code class="language-html">&lt;p class=&quot;mt-5 mb-3 text-muted&quot;&gt;© 2017-2018&lt;/p&gt;
  &lt;a href=&quot;#&quot; class=&quot;btn btn-sm&quot; th:href=&quot;@{/index.html?lg=zh_CN}&quot;&gt;中文&lt;/a&gt;
  &lt;a href=&quot;#&quot; class=&quot;btn btn-sm&quot; th:href=&quot;@{/index.html?lg=en_US}&quot;&gt;English&lt;/a&gt;

</code></pre>
<p>2、新建一个MyLocaleResolver.class</p>
<pre><code class="language-java">public class MyLocaleResolver implements LocaleResolver {

    //解析区域信息
    @Override
    public Locale resolveLocale(HttpServletRequest request) {
        String l = request.getParameter(&quot;lg&quot;);
        Locale locale = Locale.getDefault();
        if(!StringUtils.isEmpty(l)){
            String[] split = l.split(&quot;_&quot;);
            locale = new Locale(split[0], split[1]);
        }
        return locale;
    }

    @Override
    public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) {

    }
}

</code></pre>
<p>3、将MyLocaleResolver加入到容器中</p>
<pre><code class="language-java">@Bean
public LocaleResolver localeResolver(){
    return new MyLocalResolver();
}

</code></pre>
<p>4、启动演示</p>
<h3 id="3-登录拦截器">3、登录拦截器</h3>
<h4 id="1-登录">1、登录</h4>
<p>开发技巧</p>
<p>​	1、清除模板缓存</p>
<p>​	2、Ctrl+F9刷新</p>
<p>1、新建一个LoginController</p>
<pre><code class="language-java">@Controller
public class LoginController {

    @PostMapping(value =&quot;/user/login&quot;)
    public String login(@RequestParam(&quot;username&quot;)String username,
                        @RequestParam(&quot;password&quot;)String password,
                        Map&lt;String,Object&gt; map){
        if(!StringUtils.isEmpty(username) &amp;&amp; &quot;123456&quot;.equals(password)){
            //登录成功
            return &quot;list&quot;;
        }else{
            map.put(&quot;msg&quot;, &quot;用户名密码错误&quot;);
            return &quot;login&quot;;
        }

    }
}

</code></pre>
<p>2、登录错误消息显示</p>
<pre><code class="language-html">&lt;!--判断--&gt;
&lt;p style=&quot;color: red&quot; th:text=&quot;${msg}&quot; th:if=&quot;${not #strings.isEmpty(msg)}&quot;&gt;&lt;/p&gt;

</code></pre>
<p>3、表单重复提交</p>
<p>表单重复提交事件 --》重定向来到成功页面--》模板引擎解析</p>
<pre><code class="language-java">if(!StringUtils.isEmpty(username) &amp;&amp; &quot;123456&quot;.equals(password)){
    //登录成功,防止重复提交
    return &quot;redirect:/main.html&quot;;
}else{
    map.put(&quot;msg&quot;, &quot;用户名密码错误&quot;);
    return &quot;login&quot;;
}

</code></pre>
<p>模板引擎解析</p>
<pre><code class="language-java">@Override
public void addViewControllers(ViewControllerRegistry registry) {
    registry.addViewController(&quot;/&quot;).setViewName(&quot;login&quot;);
    registry.addViewController(&quot;/index.html&quot;).setViewName(&quot;login&quot;);
    registry.addViewController(&quot;/main.html&quot;).setViewName(&quot;Dashboard&quot;);
}

</code></pre>
<h3 id="4-拦截器">4、拦截器</h3>
<p>作用：实现权限控制，每个页面请求前中后，都会进入到拦截器进行处理（登录权限）</p>
<p>1、在component下新建一个LoginHandlerInterceptor拦截器</p>
<pre><code class="language-java">public class LoginHandlerInterceptor implements HandlerInterceptor {

    //目标方法执行之前
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        Object user = request.getSession().getAttribute(&quot;loginUser&quot;);
        if(user!=null){
            //已经登录
            return true;
        }
        //未经过验证
        request.setAttribute(&quot;msg&quot;, &quot;没权限请先登录&quot;);
        request.getRequestDispatcher(&quot;/index.html&quot;).forward(request, response);

        return false;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {

    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {

    }
}

</code></pre>
<p>2、在MyMvcConfig配置中重写拦截器方法，加入到容器中</p>
<pre><code class="language-java">//所有的webMvcConfigurerAdapter组件会一起起作用
@Bean //註冊到容器去
public WebMvcConfigurerAdapter webMvcConfigurerAdapter(){
    WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() {
        @Override
        public void addViewControllers(ViewControllerRegistry registry) {
            registry.addViewController(&quot;/&quot;).setViewName(&quot;login&quot;);
            registry.addViewController(&quot;/index.html&quot;).setViewName(&quot;login&quot;);
            registry.addViewController(&quot;/main.html&quot;).setViewName(&quot;Dashboard&quot;);
        }
        //注册拦截器
        @Override
        public void addInterceptors(InterceptorRegistry registry) {
            //静态资源 css js img 已经做好了静态资源映射
            registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns(&quot;/**&quot;).
                    excludePathPatterns(&quot;/index.html&quot;,&quot;/&quot;,&quot;/user/login&quot;);
        }
    };
    return adapter;
}

</code></pre>
<p>3、在LoginHandler中添加登录成功写入session</p>
<pre><code class="language-java">@Controller
public class LoginController {

    @PostMapping(value =&quot;/user/login&quot;)
    public String login(@RequestParam(&quot;username&quot;)String username,
                        @RequestParam(&quot;password&quot;)String password,
                        Map&lt;String,Object&gt; map,
                        HttpSession session){
        if(!StringUtils.isEmpty(username) &amp;&amp; &quot;123456&quot;.equals(password)){
            //登录成功,防止重复提交
            session.setAttribute(&quot;loginUser&quot;, username);
            return &quot;redirect:/main.html&quot;;
        }else{
            map.put(&quot;msg&quot;, &quot;用户名密码错误&quot;);
            return &quot;login&quot;;
        }

    }
}

</code></pre>
<h3 id="5-crud-员工列表">5、CRUD-员工列表</h3>
<p>实验要求：</p>
<p>1）、RestfulCRUD：CRUD满足Rest风格</p>
<p>URI:/资源名称/资源标识+HTTP操作</p>
<table>
<thead>
<tr>
<th></th>
<th>普通CRUD</th>
<th>RestfulCRUD</th>
</tr>
</thead>
<tbody>
<tr>
<td>查询</td>
<td>getEmp</td>
<td>emp -- GET</td>
</tr>
<tr>
<td>添加</td>
<td>addEmp?xxx</td>
<td>emp --POST</td>
</tr>
<tr>
<td>修改</td>
<td>updateEmp?id=xxx&amp;xxx=xx</td>
<td>emp/{id} -- PUT</td>
</tr>
<tr>
<td>删除</td>
<td>deleteEmp?id=1</td>
<td>emp/{id} --DELETE</td>
</tr>
</tbody>
</table>
<p>2、实验的请求架构</p>
<table>
<thead>
<tr>
<th></th>
<th>请求URI</th>
<th>请求方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>查询所有员工</td>
<td>emps</td>
<td>GET</td>
</tr>
<tr>
<td>查询某个员工</td>
<td>emp/{id}</td>
<td>GET</td>
</tr>
<tr>
<td>添加页面</td>
<td>emp</td>
<td>GET</td>
</tr>
<tr>
<td>添加员工</td>
<td>emp</td>
<td>POST</td>
</tr>
<tr>
<td>修改页面(回显)</td>
<td>emp/{id}</td>
<td>GET</td>
</tr>
<tr>
<td>修改员工</td>
<td>emp/{id}</td>
<td>PUT</td>
</tr>
<tr>
<td>删除员工</td>
<td>emp/{id}</td>
<td>DELETE</td>
</tr>
</tbody>
</table>
<p>3、员工列表</p>
<h4 id="1-公共页面抽取">1、公共页面抽取</h4>
<p>使用方法</p>
<pre><code class="language-html">1、抽取公共片段
&lt;!--footer.html--&gt;
&lt;div id=&quot;footid&quot; th:fragment=&quot;copy&quot;&gt;xxx&lt;/div&gt;
2、引入公共片段
&lt;!--test.html--&gt;
&lt;div th:insert=~{footer::copy}&gt;&lt;/div&gt;
~{templatename::selector} 模板名::选择器  footer::#footid
~{templatename::fragmentname} 模板名::片段名称 footer::copy
行内写法可以加~{xx::xx} 标签体可以 xx::xx

</code></pre>
<p><strong>三种引用方式</strong></p>
<p><strong>th:insert</strong> :加个外层标签 +1</p>
<p><strong>th:replace</strong> :完全替换 1</p>
<p><strong>th:include</strong>：就替换里面的内容 -1</p>
<p>公共页面</p>
<pre><code class="language-html">&lt;body&gt;
	...
    &lt;div th:insert=&quot;footer :: copy&quot;&gt;&lt;/div&gt;
    &lt;div th:replace=&quot;footer :: copy&quot;&gt;&lt;/div&gt;
    &lt;div th:include=&quot;footer :: copy&quot;&gt;&lt;/div&gt;
&lt;/body&gt;

</code></pre>
<p>结果</p>
<pre><code class="language-html">&lt;body&gt;
...
    &lt;!-- th:insert --&gt;
    &lt;div&gt;
        &lt;footer&gt;
            &amp;copy; 2011 The Good Thymes Virtual Grocery
        &lt;/footer&gt;
    &lt;/div&gt;
    &lt;!--th:replace--&gt;
    &lt;footer&gt;
   		&amp;copy; 2011 The Good Thymes Virtual Grocery
    &lt;/footer&gt;
    &lt;!--th:include--&gt;
    &lt;div&gt;
        &amp;copy; 2011 The Good Thymes Virtual Grocery
    &lt;/div&gt;
&lt;/body&gt;

</code></pre>
<p>用此种方法将公共页面引入</p>
<h4 id="2-列表高亮">2、列表高亮</h4>
<p>引入片段的时候传入参数，新建一个commons文件夹存储公共页面bar.html</p>
<p>模板引入变量名</p>
<p>dashboard</p>
<pre><code class="language-html">&lt;a class=&quot;nav-link active&quot;
   th:class=&quot;${activeUri}=='main.html'?'nav-link active':'nav-link'&quot;
   href=&quot;https://getbootstrap.com/docs/4.1/examples/dashboard/#&quot; th:href=&quot;@{/main.html}&quot;&gt;
    &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; stroke-width=&quot;2&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; class=&quot;feather feather-home&quot;&gt;&lt;path d=&quot;M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z&quot;&gt;&lt;/path&gt;&lt;polyline points=&quot;9 22 9 12 15 12 15 22&quot;&gt;&lt;/polyline&gt;&lt;/svg&gt;
    Dashboard &lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt;
&lt;/a&gt;

</code></pre>
<p>员工管理</p>
<pre><code class="language-html">&lt;li class=&quot;nav-item&quot;&gt;
    &lt;a class=&quot;nav-link&quot;
       th:class=&quot;${activeUri}=='emps'?'nav-link active':'nav-link'&quot;
       href=&quot;https://getbootstrap.com/docs/4.1/examples/dashboard/#&quot; th:href=&quot;@{/emps}&quot;&gt;
        &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; stroke-width=&quot;2&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; class=&quot;feather feather-users&quot;&gt;&lt;path d=&quot;M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2&quot;&gt;&lt;/path&gt;&lt;circle cx=&quot;9&quot; cy=&quot;7&quot; r=&quot;4&quot;&gt;&lt;/circle&gt;&lt;path d=&quot;M23 21v-2a4 4 0 0 0-3-3.87&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M16 3.13a4 4 0 0 1 0 7.75&quot;&gt;&lt;/path&gt;&lt;/svg&gt;
        员工管理
    &lt;/a&gt;

</code></pre>
<p>引入模板的时候传入参数</p>
<p>dashboard.html引入</p>
<pre><code class="language-html">&lt;!--引入侧边栏--&gt;
   &lt;div th:replace=&quot;commons/bar :: sidebar(activeUri='main.html')&quot;&gt;&lt;/div&gt;

</code></pre>
<p>list.html引入</p>
<pre><code class="language-html">&lt;!--引入侧边栏--&gt;
&lt;div th:replace=&quot;commons/bar::sidebar(activeUri='emps')&quot;&gt;&lt;/div&gt;

</code></pre>
<h3 id="6-列表数据显示查">6、列表数据显示（查）</h3>
<h4 id="1-传入员工对象">1、传入员工对象</h4>
<p>EmployeeController类,传入员工对象</p>
<pre><code class="language-java">@Controller
public class EmployeeController {

    @Autowired
    EmployeeDao employeeDao;
    /**
     * 查询所有员工返回列表页面
     */
    @GetMapping(value = &quot;/emps&quot;)
    public String list(Model model){

        Collection&lt;Employee&gt; employees = employeeDao.getAll();
        model.addAttribute(&quot;emps&quot;,employees);
        return &quot;emp/list&quot;;
    }
}

</code></pre>
<h4 id="2-遍历对象">2、 遍历对象</h4>
<p>list.html中 使用模板的 <code>th:each</code>方法</p>
<pre><code class="language-html">table class=&quot;table table-striped table-sm&quot;&gt;
    &lt;thead&gt;
    &lt;tr&gt;
        &lt;th&gt;#&lt;/th&gt;
        &lt;th&gt;lastName&lt;/th&gt;
        &lt;th&gt;email&lt;/th&gt;
        &lt;th&gt;gender&lt;/th&gt;
        &lt;th&gt;department&lt;/th&gt;
        &lt;th&gt;birth&lt;/th&gt;
        &lt;th&gt;操作&lt;/th&gt;
    &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr th:each=&quot;emp:${emps}&quot;&gt;
            &lt;td th:text=&quot;${emp.id}&quot;&gt;1&lt;/td&gt;
            &lt;td th:text=&quot;${emp.lastName}&quot;&gt;1&lt;/td&gt;
            &lt;td th:text=&quot;${emp.email}&quot;&gt;1&lt;/td&gt;
            &lt;td th:text=&quot;${emp.gender}&quot;&gt;1&lt;/td&gt;
            &lt;td th:text=&quot;${emp.department.departmentName}&quot;&gt;1&lt;/td&gt;
            &lt;td th:text=&quot;${#dates.format(emp.birth,'yyyy-MM-dd HH:mm:ss')}&quot;&gt;1&lt;/td&gt;
            &lt;td&gt;
                &lt;button class=&quot;btn btn-sm btn-primary&quot;&gt;编辑&lt;/button&gt;
                &lt;button class=&quot;btn btn-sm btn-danger&quot;&gt;删除&lt;/button&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;

</code></pre>
<h4 id="3-效果显示">3、效果显示</h4>
<p>![](https://stormga.github.io//post-images/19.table list.jpg)</p>
<h3 id="7-员工添加增">7、员工添加（增）</h3>
<p>功能：点击添加按钮，出现新增页面</p>
<h4 id="1-新增页面">1、新增页面</h4>
<pre><code class="language-html">&lt;form&gt;
    &lt;!-- LastName --&gt;
    &lt;div class=&quot;form-group&quot;&gt;
        &lt;label for=&quot;LastName&quot;&gt;LastName&lt;/label&gt;
        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;LastName&quot;  placeholder=&quot;LastName&quot;&gt;
    &lt;/div&gt;
    &lt;!-- Email --&gt;
    &lt;div class=&quot;form-group&quot;&gt;
        &lt;label for=&quot;Email&quot;&gt;Email&lt;/label&gt;
        &lt;input type=&quot;email&quot; class=&quot;form-control&quot; id=&quot;Email&quot;  placeholder=&quot;zhangsan@163.com&quot;&gt;
    &lt;/div&gt;
    &lt;!--gender--&gt;
    &lt;div class=&quot;form-group&quot;&gt;
        &lt;label &gt;Gender&lt;/label&gt;&lt;br/&gt;
        &lt;div class=&quot;form-check form-check-inline&quot;&gt;
            &lt;input class=&quot;form-check-input&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot;&gt;
            &lt;label class=&quot;form-check-label&quot; &gt;男&lt;/label&gt;
        &lt;/div&gt;
        &lt;div class=&quot;form-check form-check-inline&quot;&gt;
            &lt;input class=&quot;form-check-input&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot;&gt;
            &lt;label class=&quot;form-check-label&quot; &gt;女&lt;/label&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;!-- department --&gt;
    &lt;div class=&quot;form-group&quot;&gt;
        &lt;label for=&quot;exampleFormControlSelect1&quot;&gt;department&lt;/label&gt;
        &lt;select class=&quot;form-control&quot; id=&quot;exampleFormControlSelect1&quot;&gt;
            &lt;option th:each=&quot;dept:${depts}&quot; th:value=&quot;${dept.id}&quot; th:text=&quot;${dept.departmentName}&quot;&gt;&lt;/option&gt;
        &lt;/select&gt;
    &lt;/div&gt;
    &lt;!--Birth--&gt;
    &lt;div class=&quot;form-group&quot;&gt;
        &lt;label for=&quot;birthDate&quot;&gt;Birth&lt;/label&gt;
        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;birthDate&quot; placeholder=&quot;2012-12-12&quot;&gt;
    &lt;/div&gt;
    &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;添 加&lt;/button&gt;
&lt;/form&gt;

</code></pre>
<h4 id="2-页面跳转">2、页面跳转</h4>
<p>在EmployeeController中添加addEmpPage方法</p>
<pre><code class="language-java">/**
 * 添加员工
 */
@GetMapping(value = &quot;/emp&quot;)
public String toAddPage(Model model){
    //来到添加页面,查出所有部门显示
    Collection&lt;Department&gt; depts = departmentDao.getDepartments();
    model.addAttribute(&quot;depts&quot;,depts);
    return &quot;emp/add&quot;;
}

</code></pre>
<p>关键点：在添加部门页面要遍历部门信息，所以在方法中出入部门信息</p>
<h4 id="3-添加功能完成">3、添加功能完成</h4>
<p>新建一个PostMapping</p>
<blockquote>
<p>ThymeleafViewResolver 查看redirect和forward,原生的sendredirect方法；</p>
</blockquote>
<p>1、新建一个postMapping的方法用来接受页面的添加POST请求</p>
<pre><code class="language-java">/**
 * 员工添加
 */
@PostMapping(value = &quot;/emp&quot;)
public String addEmp(Employee employee){

    employeeDao.save(employee);
    //来到员工列表页面、redirect:重定向到一个地址，forward转发到一个地址
    return &quot;redirect:/emps&quot;;
}

</code></pre>
<p>2、修改添加页面，添加name属性</p>
<pre><code class="language-html">&lt;form th:action=&quot;@{/emp}&quot; method=&quot;post&quot;&gt;
    &lt;!-- LastName --&gt;
    &lt;div class=&quot;form-group&quot;&gt;
        &lt;label for=&quot;LastName&quot;&gt;LastName&lt;/label&gt;
        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;LastName&quot; name=&quot;lastName&quot; placeholder=&quot;LastName&quot;&gt;
    &lt;/div&gt;
    &lt;!-- Email --&gt;
    &lt;div class=&quot;form-group&quot;&gt;
        &lt;label for=&quot;Email&quot;&gt;Email&lt;/label&gt;
        &lt;input type=&quot;email&quot; class=&quot;form-control&quot; id=&quot;Email&quot;  name=&quot;email&quot; placeholder=&quot;zhangsan@163.com&quot;&gt;
    &lt;/div&gt;
    &lt;!--gender--&gt;
    &lt;div class=&quot;form-group&quot;&gt;
        &lt;label &gt;Gender&lt;/label&gt;&lt;br/&gt;
        &lt;div class=&quot;form-check form-check-inline&quot;&gt;
            &lt;input class=&quot;form-check-input&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot;&gt;
            &lt;label class=&quot;form-check-label&quot; &gt;男&lt;/label&gt;
        &lt;/div&gt;
        &lt;div class=&quot;form-check form-check-inline&quot;&gt;
            &lt;input class=&quot;form-check-input&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot;&gt;
            &lt;label class=&quot;form-check-label&quot; &gt;女&lt;/label&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;!-- department --&gt;
    &lt;div class=&quot;form-group&quot;&gt;
        &lt;label &gt;department&lt;/label&gt;
        &lt;select class=&quot;form-control&quot;  name=&quot;department.id&quot;&gt;
            &lt;option th:each=&quot;dept:${depts}&quot; th:value=&quot;${dept.id}&quot; th:text=&quot;${dept.departmentName}&quot;&gt;&lt;/option&gt;
        &lt;/select&gt;
    &lt;/div&gt;
    &lt;div class=&quot;form-group&quot;&gt;
        &lt;label for=&quot;birthDate&quot;&gt;Birth&lt;/label&gt;
        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;birthDate&quot; placeholder=&quot;2012-12-12&quot; name=&quot;birth&quot;&gt;
    &lt;/div&gt;
    &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;添 加&lt;/button&gt;
&lt;/form&gt;

</code></pre>
<p>1、部门对象问题？</p>
<pre><code class="language-html">&lt;select class=&quot;form-control&quot;  name=&quot;department.id&quot;&gt;

</code></pre>
<p>2、日期格式化？</p>
<p>属性中添加 date-formate 默认是 /</p>
<pre><code class="language-java">@Bean
@ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;date-format&quot;)
public Formatter&lt;Date&gt; dateFormatter() {
   return new DateFormatter(this.mvcProperties.getDateFormat());
}

@Override
public MessageCodesResolver getMessageCodesResolver() {
   if (this.mvcProperties.getMessageCodesResolverFormat() != null) {
      DefaultMessageCodesResolver resolver = new DefaultMessageCodesResolver();
      resolver.setMessageCodeFormatter(
            this.mvcProperties.getMessageCodesResolverFormat());
      return resolver;
   }
   return null;
}

</code></pre>
<pre><code class="language-properties">spring.mvc.date-format=yyyy-MM-dd

</code></pre>
<h3 id="8-员工编辑改">8、员工编辑（改）</h3>
<p>思路使用add页面，并且数据回显，然后区分添加，PUT请求</p>
<h4 id="1-修改按钮">1、修改按钮</h4>
<p>在list.html的<code>编辑</code>按钮加上链接</p>
<pre><code class="language-html">&lt;td&gt;
    &lt;a  href=&quot;#&quot; th:href=&quot;@{/emp/}+${emp.id}&quot; class=&quot;btn btn-sm btn-primary&quot;&gt;编辑&lt;/a&gt;
    &lt;button class=&quot;btn btn-sm btn-danger&quot;&gt;删除&lt;/button&gt;
&lt;/td&gt;

</code></pre>
<h4 id="2-编写跳转页面">2、编写跳转页面</h4>
<p>跳转到员工编辑页面的Controller</p>
<pre><code class="language-java">/**
 * 员工编辑页面
 */
@GetMapping(value = &quot;/emp/{id}&quot;)
public String toEditPage(@PathVariable(&quot;id&quot;) Integer id ,Model model){
    Employee emp = employeeDao.getEmpById(id);
    Collection&lt;Department&gt; departments = departmentDao.getDepartments();
    model.addAttribute(&quot;emp&quot;,emp);
    model.addAttribute(&quot;depts&quot;,departments);
    return &quot;emp/add&quot;;
}
   

</code></pre>
<h4 id="3-对页面修改">3、对页面修改</h4>
<p>对add页面进行修改</p>
<p>1）、添加回显</p>
<p>2）、添加判断是否emp!=null（区分add or edit）</p>
<p>3）、添加put请求 --两个input的hidden标签</p>
<pre><code class="language-html"> &lt;form th:action=&quot;@{/emp}&quot; method=&quot;post&quot;&gt;
        &lt;!--发送put请求--&gt;
        &lt;!--1.SpringMVC配置HiddenHttpMethodFilter
            2.页面创建一个post表单
            3.创建一个 input name_method 值就是我们请求的方式--&gt;
        &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;put&quot; th:if=&quot;${emp!=null}&quot;&gt;

        &lt;input type=&quot;hidden&quot; name=&quot;id&quot; th:value=&quot;${emp.id}&quot; th:if=&quot;${emp!=null}&quot;&gt;
        &lt;!-- LastName --&gt;
        &lt;div class=&quot;form-group&quot;&gt;
            &lt;label for=&quot;LastName&quot;&gt;LastName&lt;/label&gt;
            &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;LastName&quot; name=&quot;lastName&quot; placeholder=&quot;LastName&quot; th:value=&quot;${emp!=null}?${emp.lastName}&quot;&gt;
        &lt;/div&gt;
        &lt;!-- Email --&gt;
        &lt;div class=&quot;form-group&quot;&gt;
            &lt;label for=&quot;Email&quot;&gt;Email&lt;/label&gt;
            &lt;input type=&quot;email&quot; class=&quot;form-control&quot; id=&quot;Email&quot;  name=&quot;email&quot; placeholder=&quot;zhangsan@163.com&quot; th:value=&quot;${emp!=null}?${emp.email}&quot;&gt;
        &lt;/div&gt;
        &lt;!--gender--&gt;
        &lt;div class=&quot;form-group&quot;&gt;
            &lt;label &gt;Gender&lt;/label&gt;&lt;br/&gt;
            &lt;div class=&quot;form-check form-check-inline&quot;&gt;
                &lt;input class=&quot;form-check-input&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot; th:checked=&quot;${emp!=null}?${emp.gender}==1&quot;&gt;
                &lt;label class=&quot;form-check-label&quot; &gt;男&lt;/label&gt;
            &lt;/div&gt;
            &lt;div class=&quot;form-check form-check-inline&quot;&gt;
                &lt;input class=&quot;form-check-input&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot; th:checked=&quot;${emp!=null}?${emp.gender}==0&quot;&gt;
                &lt;label class=&quot;form-check-label&quot; &gt;女&lt;/label&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;!-- department --&gt;
        &lt;div class=&quot;form-group&quot;&gt;
            &lt;label &gt;department&lt;/label&gt;
            &lt;select class=&quot;form-control&quot;  name=&quot;department.id&quot; &gt;
                &lt;option th:selected=&quot;${emp!=null}?${dept.id == emp.department.id}&quot; th:each=&quot;dept:${depts}&quot; th:value=&quot;${dept.id}&quot; th:text=&quot;${dept.departmentName}&quot;&gt;&lt;/option&gt;
            &lt;/select&gt;
        &lt;/div&gt;
        &lt;div class=&quot;form-group&quot;&gt;
            &lt;label for=&quot;birthDate&quot;&gt;Birth&lt;/label&gt;
            &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;birthDate&quot; placeholder=&quot;2012-12-12&quot; name=&quot;birth&quot; th:value=&quot;${emp!=null}?${#dates.format(emp.birth,'yyyy-MM-dd HH:mm:ss')}&quot;&gt;
        &lt;/div&gt;
        &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot; th:text=&quot;${emp!=null}?'修改':'添加'&quot;&gt;添 加&lt;/button&gt;
    &lt;/form&gt;
&lt;/main&gt;

</code></pre>
<h3 id="9-员工删除删">9、员工删除（删）</h3>
<h4 id="1-新建contoller">1、新建Contoller</h4>
<pre><code class="language-java">/**
 * 员工删除
 */
@DeleteMapping(value = &quot;/emp/{id}&quot;)
public String deleteEmp(@PathVariable(&quot;id&quot;) Integer id){
    employeeDao.deleteEmpById(id);
    return &quot;redirect:/emps&quot;;
}

</code></pre>
<h4 id="2-修改删除标签">2、修改删除标签</h4>
<pre><code class="language-html">&lt;button th:attr=&quot;del_uri=@{/emp/}+${emp.id}&quot;  class=&quot;btn btn-sm btn-danger deleteBtn&quot;&gt;
    删除
&lt;/button&gt;

</code></pre>
<h4 id="3-写form表单">3、写Form表单</h4>
<p>form表单卸载外面，input 中 name=&quot;_method&quot; value=&quot;delete&quot; 模拟delete请求</p>
<pre><code class="language-html">                &lt;/tbody&gt;
            &lt;/table&gt;
        &lt;/div&gt;
    &lt;/main&gt;
    &lt;form id=&quot;deleteEmpForm&quot; method=&quot;post&quot;&gt;
        &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;delete&quot;&gt;
    &lt;/form&gt;
&lt;/div&gt;

</code></pre>
<h4 id="4-写js提交">4、写JS提交</h4>
<pre><code class="language-javascript">&lt;script&gt;
    $(&quot;.deleteBtn&quot;).click(function () {
        $(&quot;#deleteEmpForm&quot;).attr(&quot;action&quot;,$(this).attr(&quot;del_uri&quot;)).submit();
        return false;
    })
&lt;/script&gt;

</code></pre>
<blockquote>
<p>return false;禁用btn提交效果</p>
</blockquote>
<h2 id="7-错误机制的处理">7、错误机制的处理</h2>
<h3 id="1-默认的错误处理机制">1、默认的错误处理机制</h3>
<p>默认错误页面</p>
<figure data-type="image" tabindex="17"><img src="https://stormga.github.io//post-images/20.error.jpg" alt="" loading="lazy"></figure>
<p>原理参照</p>
<p>ErrorMvcAutoConfiguration:错误处理的自动配置</p>
<pre><code>org\springframework\boot\spring-boot-autoconfigure\1.5.12.RELEASE\spring-boot-autoconfigure-1.5.12.RELEASE.jar!\org\springframework\boot\autoconfigure\web\ErrorMvcAutoConfiguration.class


</code></pre>
<ul>
<li>
<p>DefaultErrorAttributes</p>
<p>帮我们在页面共享信息</p>
<pre><code class="language-java">@Override
public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes,
      boolean includeStackTrace) {
   Map&lt;String, Object&gt; errorAttributes = new LinkedHashMap&lt;String, Object&gt;();
   errorAttributes.put(&quot;timestamp&quot;, new Date());
   addStatus(errorAttributes, requestAttributes);
   addErrorDetails(errorAttributes, requestAttributes, includeStackTrace);
   addPath(errorAttributes, requestAttributes);
   return errorAttributes;
}

</code></pre>
</li>
<li>
<p>BasicErrorController</p>
<pre><code class="language-java">@Controller
@RequestMapping(&quot;${server.error.path:${error.path:/error}}&quot;)
public class BasicErrorController extends AbstractErrorController {
    //产生HTML数据
    @RequestMapping(produces = &quot;text/html&quot;)
	public ModelAndView errorHtml(HttpServletRequest request,
			HttpServletResponse response) {
		HttpStatus status = getStatus(request);
		Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes(
				request, isIncludeStackTrace(request, MediaType.TEXT_HTML)));
		response.setStatus(status.value());
		ModelAndView modelAndView = resolveErrorView(request, response, status, model);
		return (modelAndView == null ? new ModelAndView(&quot;error&quot;, model) : modelAndView);
	}
	//产生Json数据
	@RequestMapping
	@ResponseBody
	public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) {
		Map&lt;String, Object&gt; body = getErrorAttributes(request,
				isIncludeStackTrace(request, MediaType.ALL));
		HttpStatus status = getStatus(request);
		return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status);
	}

</code></pre>
</li>
<li>
<p>ErrorPageCustomizer</p>
<pre><code class="language-java">@Value(&quot;${error.path:/error}&quot;)
private String path = &quot;/error&quot;;//系统出现错误以后来到error请求进行处理，(web.xml)

</code></pre>
</li>
<li>
<p>DefaultErrorViewResolver</p>
<pre><code class="language-java">@Override
public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status,
      Map&lt;String, Object&gt; model) {
   ModelAndView modelAndView = resolve(String.valueOf(status), model);
   if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) {
      modelAndView = resolve(SERIES_VIEWS.get(status.series()), model);
   }
   return modelAndView;
}

private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) {
    //默认SpringBoot可以找到一个页面？error/状态码
   String errorViewName = &quot;error/&quot; + viewName;
    //如果模板引擎可以解析地址，就返回模板引擎解析
   TemplateAvailabilityProvider provider = this.templateAvailabilityProviders
         .getProvider(errorViewName, this.applicationContext);
   if (provider != null) {
       //有模板引擎就返回到errorViewName指定的视图地址
      return new ModelAndView(errorViewName, model);
   }
    //自己的文件 就在静态文件夹下找静态文件 /静态资源文件夹/404.html
   return resolveResource(errorViewName, model);
}

</code></pre>
</li>
</ul>
<p>一旦系统出现4xx或者5xx错误 ErrorPageCustomizer就回来定制错误的响应规则,就会来到 /error请求,BasicErrorController处理，就是一个Controller</p>
<p>1.响应页面,去哪个页面是由 DefaultErrorViewResolver 拿到所有的错误视图</p>
<pre><code class="language-java">protected ModelAndView resolveErrorView(HttpServletRequest request,
      HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model) {
   for (ErrorViewResolver resolver : this.errorViewResolvers) {
      ModelAndView modelAndView = resolver.resolveErrorView(request, status, model);
      if (modelAndView != null) {
         return modelAndView;
      }
   }
   return null;
}

</code></pre>
<p>l浏览器发送请求 accpt:text/html</p>
<p>客户端请求：accept:/*</p>
<h3 id="2-如何定制错误响应">2、如何定制错误响应</h3>
<p>​	1）、如何定制错误的页面</p>
<p>​		1.有模板引擎：静态资源/404.html,什么错误什么页面；所有以4开头的 4xx.html 5开头的5xx.html</p>
<p>​		有精确的404和4xx优先选择404</p>
<p>​		页面获得的数据</p>
<p>​			timestamp：时间戳</p>
<p>​			status：状态码</p>
<p>​			error：错误提示</p>
<p>​			exception：异常对象</p>
<p>​			message：异常信息</p>
<p>​			errors:JSR303有关</p>
<p>​		2.没有放在模板引擎，放在静态文件夹，也可以显示，就是没法使用模板取值</p>
<p>​		3.没有放模板引擎，没放静态，会显示默认的错误</p>
<p>​	2）、如何定义错误的数据</p>
<p>举例子：新建4xx和5xx文件</p>
<figure data-type="image" tabindex="18"><img src="https://stormga.github.io//post-images/21.error-static.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-html">&lt;body &gt;
    &lt;p&gt;status: [[${status}]]&lt;/p&gt;
    &lt;p&gt;timestamp: [[${timestamp}]]&lt;/p&gt;
    &lt;p&gt;error: [[${error}]]&lt;/p&gt;
    &lt;p&gt;message: [[${message}]]&lt;/p&gt;
    &lt;p&gt;exception: [[${exception}]]&lt;/p&gt;
&lt;/body&gt;

</code></pre>
<figure data-type="image" tabindex="19"><img src="https://stormga.github.io//post-images/22.4xxhtml.jpg" alt="" loading="lazy"></figure>
<h3 id="3-如何定制json数据">3、如何定制Json数据</h3>
<h4 id="1-仅发送json数据">1、仅发送json数据</h4>
<pre><code class="language-java">public class UserNotExitsException extends  RuntimeException {
    public UserNotExitsException(){
        super(&quot;用户不存在&quot;);
    }
}

</code></pre>
<pre><code class="language-java">/**
 * 异常处理器
 */
@ControllerAdvice
public class MyExceptionHandler {

    @ResponseBody
    @ExceptionHandler(UserNotExitsException.class)
    public Map&lt;String ,Object&gt; handlerException(Exception e){
        Map&lt;String ,Object&gt; map =new HashMap&lt;&gt;();
        map.put(&quot;code&quot;, &quot;user not exist&quot;);
        map.put(&quot;message&quot;, e.getMessage());
        return map;
    }
}

</code></pre>
<p>无法自适应 都是返回的json数据</p>
<h4 id="2-转发到error自适应处理">2、转发到error自适应处理</h4>
<pre><code class="language-java">@ExceptionHandler(UserNotExitsException.class)
public String handlerException(Exception e, HttpServletRequest request){
    Map&lt;String ,Object&gt; map =new HashMap&lt;&gt;();
    //传入自己的状态码
    request.setAttribute(&quot;javax.servlet.error.status_code&quot;, 432);
    map.put(&quot;code&quot;, &quot;user not exist&quot;);
    map.put(&quot;message&quot;, e.getMessage());
    //转发到error
    return &quot;forward:/error&quot;;
}

</code></pre>
<p>程序默认获取状态码</p>
<pre><code class="language-java">protected HttpStatus getStatus(HttpServletRequest request) {
   Integer statusCode = (Integer) request
         .getAttribute(&quot;javax.servlet.error.status_code&quot;);
   if (statusCode == null) {
      return HttpStatus.INTERNAL_SERVER_ERROR;
   }
   try {
      return HttpStatus.valueOf(statusCode);
   }
   catch (Exception ex) {
      return HttpStatus.INTERNAL_SERVER_ERROR;
   }

</code></pre>
<p>没有自己写的自定义异常数据</p>
<h4 id="3-自适应和定制数据传入">3、自适应和定制数据传入</h4>
<p>Spring 默认的原理，出现错误后回来到error请求，会被BasicErrorController处理,响应出去的数据是由BasicErrorController的父类AbstractErrorController(ErrorController)规定的方法getAttributes得到的；</p>
<p>1、编写一个ErrorController的实现类【或者AbstractErrorController的子类】，放在容器中；</p>
<p>2、页面上能用的数据，或者是json数据返回能用的数据都是通过errorAttributes.getErrorAttributes得到；</p>
<p>容器中的DefaultErrorAtrributes.getErrorAtrributees();默认进行数据处理</p>
<pre><code class="language-java">public class MyErrorAttributes extends DefaultErrorAttributes {
    @Override
    public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) {
        Map&lt;String, Object&gt; map = super.getErrorAttributes(requestAttributes, includeStackTrace);
        map.put(&quot;company&quot;, &quot;wdjr&quot;);
        return map;
    }
}

</code></pre>
<p>异常处理：把map方法请求域中</p>
<pre><code class="language-java">    @ExceptionHandler(UserNotExitsException.class)
    public String handlerException(Exception e, HttpServletRequest request){
        Map&lt;String ,Object&gt; map =new HashMap&lt;&gt;();
        //传入自己的状态码
        request.setAttribute(&quot;javax.servlet.error.status_code&quot;, 432);
        map.put(&quot;code&quot;, &quot;user not exist&quot;);
        map.put(&quot;message&quot;, e.getMessage());
        request.setAttribute(&quot;ext&quot;, map);
        //转发到error
        return &quot;forward:/error&quot;;
    }
}

</code></pre>
<p>在上面的MyErrorAttributes类中加上</p>
<pre><code class="language-java">//我们的异常处理器
Map&lt;String,Object&gt; ext = (Map&lt;String, Object&gt;) requestAttributes.getAttribute(&quot;ext&quot;, 0);
map.put(&quot;ext&quot;, ext);

</code></pre>
<h2 id="8-配置嵌入式servlet容器">8、配置嵌入式servlet容器</h2>
<h3 id="1-定制和修改servlet容器">1、定制和修改Servlet容器</h3>
<p>SpringBoot默认使用Tomcat作为嵌入式的Servlet容器；</p>
<p>![](https://stormga.github.io//post-images/23.tomcat emd.jpg)</p>
<p>问题？</p>
<p>1）、如何定制和修改Servlet容器；</p>
<p>1、 修改Server相关的配置文件 application.properties</p>
<pre><code class="language-properties">#通用的servlet容器配置
server.xxx
#tomcat的配置
server.tomcat.xxxx

</code></pre>
<p>2、编写一个EmbeddedServletContainerCustomizer;嵌入式的Servlet容器的定制器；来修改Servlet的容器配置</p>
<pre><code class="language-java">@Bean
public EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer(){
    return new EmbeddedServletContainerCustomizer() {
        //定制嵌入式Servlet的容器相关规则
        @Override
        public void customize(ConfigurableEmbeddedServletContainer container) {
            container.setPort(8999);
        }
    };
}

</code></pre>
<p>其实同理，都是实现EmbeddedServletContainerCustomizer</p>
<h3 id="2-注册servlet三大组件">2、注册Servlet三大组件</h3>
<p>三大组件 Servlet Filter Listener</p>
<p>由于SprringBoot默认是以jar包启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml</p>
<p>注册三大组件</p>
<h4 id="servletregistrationbean">ServletRegistrationBean</h4>
<pre><code class="language-java">@Bean
public ServletRegistrationBean myServlet(){
    ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean(new MyServlet(),&quot;/servlet&quot;);
    return servletRegistrationBean;
}

</code></pre>
<p>MyServlet</p>
<pre><code class="language-java">public class MyServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.getWriter().write(&quot;Hello Servlet&quot;);
    }
}

</code></pre>
<h4 id="filterregistrationbean">FilterRegistrationBean</h4>
<pre><code class="language-java">@Bean
public FilterRegistrationBean myFilter(){
    FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean();
    filterRegistrationBean.setFilter(new MyFilter());
    filterRegistrationBean.setUrlPatterns(Arrays.asList(&quot;/hello&quot;,&quot;/myServlet&quot;));
    return filterRegistrationBean;
}

</code></pre>
<p>MyFilter</p>
<pre><code class="language-java">public class MyFilter implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        System.out.println(&quot;MyFilter process&quot;);
        chain.doFilter(request, response);
    }

    @Override
    public void destroy() {

    }
}

</code></pre>
<h4 id="servletlistenerregistrationbean">ServletListenerRegistrationBean</h4>
<pre><code class="language-java">@Bean
public ServletListenerRegistrationBean myListener(){
    ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean = new ServletListenerRegistrationBean&lt;&gt;(new MyListener());
    return registrationBean;
}

</code></pre>
<p>MyListener</p>
<pre><code class="language-java">public class MyListener implements ServletContextListener {
    @Override
    public void contextInitialized(ServletContextEvent sce) {
        System.out.println(&quot;.........web应用启动..........&quot;);
    }

    @Override
    public void contextDestroyed(ServletContextEvent sce) {
        System.out.println(&quot;.........web应用销毁..........&quot;);
    }
}

</code></pre>
<p>SpringBoot帮助我们自动配置SpringMVC的时候，自动注册SpringMVC的前端控制器；DispatcherServlet;</p>
<pre><code class="language-java">@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)
@ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)
   public ServletRegistrationBean dispatcherServletRegistration(
         DispatcherServlet dispatcherServlet) {
      ServletRegistrationBean registration = new ServletRegistrationBean(
            dispatcherServlet, this.serverProperties.getServletMapping());
       //默认拦截 /所有请求 包括静态资源 不包括jsp
       //可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径
      registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME);
      registration.setLoadOnStartup(
            this.webMvcProperties.getServlet().getLoadOnStartup());
      if (this.multipartConfig != null) {
         registration.setMultipartConfig(this.multipartConfig);
      }
      return registration;
   }

}

</code></pre>
<h3 id="3-切换其他的servlet容器">3、切换其他的Servlet容器</h3>
<p>在ServerProperties中</p>
<pre><code class="language-java">private final Tomcat tomcat = new Tomcat();

private final Jetty jetty = new Jetty();

private final Undertow undertow = new Undertow();

</code></pre>
<p>tomcat(默认支持)</p>
<p>jetty（长连接）</p>
<p>undertow（多并发）</p>
<p>切换容器 仅仅需要修改pom文件的依赖就可以</p>
<pre><code class="language-xml">        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;
        &lt;/dependency&gt;
&lt;!--        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt;
        &lt;/dependency&gt;--&gt;

</code></pre>
<h3 id="4-嵌入式servlet容器自动配置原理">4、嵌入式Servlet容器自动配置原理</h3>
<pre><code class="language-java">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
@Configuration
@ConditionalOnWebApplication
@Import(BeanPostProcessorsRegistrar.class)
//给容器导入组件 后置处理器 在Bean初始化前后执行前置后置的逻辑 创建完对象还没属性赋值进行初始化工作
public class EmbeddedServletContainerAutoConfiguration {
    @Configuration
	@ConditionalOnClass({ Servlet.class, Tomcat.class })//当前是否引入tomcat依赖
    //判断当前容器没有用户自定义EmbeddedServletContainerFactory，就会创建默认的嵌入式容器
	@ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)
	public static class EmbeddedTomcat {

		@Bean
		public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() {
			return new TomcatEmbeddedServletContainerFactory();
		}

</code></pre>
<p>1）、EmbeddedServletContainerFactory（嵌入式Servlet容器工厂）</p>
<pre><code class="language-java">public interface EmbeddedServletContainerFactory {
	//获取嵌入式的Servlet容器
   EmbeddedServletContainer getEmbeddedServletContainer(
         ServletContextInitializer... initializers);

}

</code></pre>
<p>继承关系</p>
<figure data-type="image" tabindex="20"><img src="https://stormga.github.io//post-images/24.EmdServletFactory.jpg" alt="" loading="lazy"></figure>
<p>2）、EmbeddedServletContainer:(嵌入式的Servlet容器)</p>
<figure data-type="image" tabindex="21"><img src="https://stormga.github.io//post-images/25.EmdServletContainer.jpg" alt="" loading="lazy"></figure>
<p>3）、TomcatEmbeddedServletContainerFactory为例</p>
<pre><code class="language-java">@Override
public EmbeddedServletContainer getEmbeddedServletContainer(
      ServletContextInitializer... initializers) {
   Tomcat tomcat = new Tomcat();
    //配置tomcat的基本环节
   File baseDir = (this.baseDirectory != null ? this.baseDirectory
         : createTempDir(&quot;tomcat&quot;));
   tomcat.setBaseDir(baseDir.getAbsolutePath());
   Connector connector = new Connector(this.protocol);
   tomcat.getService().addConnector(connector);
   customizeConnector(connector);
   tomcat.setConnector(connector);
   tomcat.getHost().setAutoDeploy(false);
   configureEngine(tomcat.getEngine());
   for (Connector additionalConnector : this.additionalTomcatConnectors) {
      tomcat.getService().addConnector(additionalConnector);
   }
   prepareContext(tomcat.getHost(), initializers);
    //将配置好的tomcat传入进去；并且启动tomcat容器
   return getTomcatEmbeddedServletContainer(tomcat);
}

</code></pre>
<p>4）、嵌入式配置修改</p>
<pre><code>ServerProperties、EmbeddedServletContainerCustomizer

</code></pre>
<p>EmbeddedServletContainerCustomizer:定制器帮我们修改了Servlet容器配置？</p>
<p>怎么修改？</p>
<p>5）、容器中导入了<strong>EmbeddedServletContainerCustomizerBeanPostProcessor</strong></p>
<pre><code class="language-java">@Override
public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,
      BeanDefinitionRegistry registry) {
   if (this.beanFactory == null) {
      return;
   }
   registerSyntheticBeanIfMissing(registry,
         &quot;embeddedServletContainerCustomizerBeanPostProcessor&quot;,
         EmbeddedServletContainerCustomizerBeanPostProcessor.class);
   registerSyntheticBeanIfMissing(registry,
         &quot;errorPageRegistrarBeanPostProcessor&quot;,
         ErrorPageRegistrarBeanPostProcessor.class);
}

</code></pre>
<pre><code class="language-java">@Override
public Object postProcessBeforeInitialization(Object bean, String beanName)
      throws BeansException {
    //如果当前初始化的是一个ConfigurableEmbeddedServletContainer
   if (bean instanceof ConfigurableEmbeddedServletContainer) {
      postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean);
   }
   return bean;
}

private void postProcessBeforeInitialization(
    ConfigurableEmbeddedServletContainer bean) {
    //获取所有的定制器，调用每个定制器的customer方法给Servlet容器进行赋值
    for (EmbeddedServletContainerCustomizer customizer : getCustomizers()) {
        customizer.customize(bean);
    }
}

private Collection&lt;EmbeddedServletContainerCustomizer&gt; getCustomizers() {
    if (this.customizers == null) {
        // Look up does not include the parent context
        this.customizers = new ArrayList&lt;EmbeddedServletContainerCustomizer&gt;(
            this.beanFactory
            //从容器中获取所有的这个类型的组件：EmbeddedServletContainerCustomizer
            //定制Servlet,给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件
            .getBeansOfType(EmbeddedServletContainerCustomizer.class,
                            false, false)
            .values());
        Collections.sort(this.customizers, AnnotationAwareOrderComparator.INSTANCE);
        this.customizers = Collections.unmodifiableList(this.customizers);
    }
    return this.customizers;
}

</code></pre>
<p>ServerProperties也是EmbeddedServletContainerCustomizer定制器</p>
<p>步骤：</p>
<p>1）、SpringBoot根据导入的依赖情况，给容器中添加响应的容器工厂 例：tomcat</p>
<p>EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】</p>
<p>2）、容器中某个组件要创建对象就要通过后置处理器；</p>
<pre><code class="language-java">EmbeddedServletContainerCustomizerBeanPostProcessor

</code></pre>
<p>只要是嵌入式的Servlet容器工厂，后置处理器就工作；</p>
<p>3）、后置处理器，从容器中获取的所有的EmbeddedServletContainerCustomizer，调用定制器的定制方法</p>
<h3 id="5-嵌入式servlet容器启动原理">5、嵌入式Servlet容器启动原理</h3>
<p>什么时候创建嵌入式的Servlet的容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat;</p>
<p>获取嵌入式的容器工厂</p>
<p>1）、SpringBoot应用启动Run方法</p>
<p>2）、刷新IOC容器对象【创建IOC容器对象，并初始化容器，创建容器的每一个组件】；如果是web环境AnnotationConfigEmbeddedWebApplicationContext,如果不是AnnotationConfigApplicationContext</p>
<pre><code class="language-JAVA">if (contextClass == null) {
   try {
      contextClass = Class.forName(this.webEnvironment
            ? DEFAULT_WEB_CONTEXT_CLASS : DEFAULT_CONTEXT_CLASS);
   }

</code></pre>
<p>3）、refresh(context);刷新创建好的IOC容器</p>
<pre><code class="language-java">try {
   // Allows post-processing of the bean factory in context subclasses.
   postProcessBeanFactory(beanFactory);

   // Invoke factory processors registered as beans in the context.
   invokeBeanFactoryPostProcessors(beanFactory);

   // Register bean processors that intercept bean creation.
   registerBeanPostProcessors(beanFactory);

   // Initialize message source for this context.
   initMessageSource();

   // Initialize event multicaster for this context.
   initApplicationEventMulticaster();

   // Initialize other special beans in specific context subclasses.
   onRefresh();

   // Check for listener beans and register them.
   registerListeners();

   // Instantiate all remaining (non-lazy-init) singletons.
   finishBeanFactoryInitialization(beanFactory);

   // Last step: publish corresponding event.
   finishRefresh();
}

</code></pre>
<p>4）、 onRefresh();web的ioc容器重写了onRefresh方法</p>
<p>5）、webioc会创建嵌入式的Servlet容器；createEmbeddedServletContainer</p>
<p>6）、获取嵌入式的Servlet容器工厂；</p>
<pre><code class="language-java">EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory();

</code></pre>
<p>从ioc容器中获取EmbeddedServletContainerFactory组件；</p>
<pre><code class="language-java">@Bean
public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() {
return new TomcatEmbeddedServletContainerFactory();
}

</code></pre>
<p>TomcatEmbeddedServletContainerFactory创建对象，后置处理器看这个对象，就来获取所有的定制器来定制Servlet容器的相关配置；</p>
<p>7）、使用容器工厂获取嵌入式的Servlet容器</p>
<p>8）、嵌入式的Servlet容器创建对象并启动Servlet容器；</p>
<p>先启动嵌入式的Servlet容器，在将ioc容器中剩下的没有创建出的对象获取出来</p>
<p>ioc启动创建Servlet容器</p>
<h2 id="9-使用外置的servlet容器">9、使用外置的Servlet容器</h2>
<p>嵌入式的Servlet容器：应用达成jar包</p>
<p>​	优点：简单、便携</p>
<p>​	缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义定制器】，自己来编写嵌入式的容器工厂）</p>
<p>外置的Servlet容器：外面安装Tomcat是以war包的方式打包。</p>
<h3 id="1-idea操作外部servlet">1、IDEA操作外部Servlet</h3>
<p>1、创建程序为war程序</p>
<figure data-type="image" tabindex="22"><img src="https://stormga.github.io//post-images/26.tomcat1.jpg" alt="" loading="lazy"></figure>
<p>2、选择版本</p>
<figure data-type="image" tabindex="23"><img src="https://stormga.github.io//post-images/27.tomcat2.jpg" alt="" loading="lazy"></figure>
<p>3、添加tomcat</p>
<figure data-type="image" tabindex="24"><img src="https://stormga.github.io//post-images/28.tomcat3.jpg" alt="" loading="lazy"></figure>
<p>4、选择tomcat</p>
<figure data-type="image" tabindex="25"><img src="https://stormga.github.io//post-images/30.tomcat4.jpg" alt="" loading="lazy"></figure>
<p>5、选择本地的Tomcat</p>
<figure data-type="image" tabindex="26"><img src="https://stormga.github.io//post-images/31.tomcat5.jpg" alt="" loading="lazy"></figure>
<p>6、配置tomcat路径</p>
<figure data-type="image" tabindex="27"><img src="https://stormga.github.io//post-images/32.tomcat6.jpg" alt="" loading="lazy"></figure>
<p>7、添加服务器</p>
<figure data-type="image" tabindex="28"><img src="https://stormga.github.io//post-images/33.tomcat7.jpg" alt="" loading="lazy"></figure>
<p>8、添加exploded的war配置，应用OK tomcat配置完成</p>
<figure data-type="image" tabindex="29"><img src="https://stormga.github.io//post-images/34.tomcat8.jpg" alt="" loading="lazy"></figure>
<p>二、配置webapp文件夹</p>
<p>1、点击配置</p>
<figure data-type="image" tabindex="30"><img src="https://stormga.github.io//post-images/35.tomcat9.jpg" alt="" loading="lazy"></figure>
<p>2、添加webapp目录</p>
<figure data-type="image" tabindex="31"><img src="https://stormga.github.io//post-images/36.tomcat10.jpg" alt="" loading="lazy"></figure>
<p>3、默认配置就可以</p>
<figure data-type="image" tabindex="32"><img src="https://stormga.github.io//post-images/37.tomcat11.jpg" alt="" loading="lazy"></figure>
<p>4、配置web.xml文件</p>
<figure data-type="image" tabindex="33"><img src="https://stormga.github.io//post-images/38.tomcat12.jpg" alt="" loading="lazy"></figure>
<p>5、文档目录结构</p>
<figure data-type="image" tabindex="34"><img src="https://stormga.github.io//post-images/39.tomcat13.jpg" alt="" loading="lazy"></figure>
<h3 id="2-运行一个示例">2、运行一个示例</h3>
<p>1、项目目录</p>
<figure data-type="image" tabindex="35"><img src="https://stormga.github.io//post-images/40.demo1.jpg" alt="" loading="lazy"></figure>
<p>2、配置文件写视图解析前后缀</p>
<pre><code class="language-properties">spring.mvc.view.prefix=/WEB-INF/jsp/

spring.mvc.view.suffix=.jsp

</code></pre>
<p>3、HelloController</p>
<pre><code class="language-java">@Controller
public class HelloController {
    @GetMapping(&quot;/hello&quot;)
    public String hello(Model model){
        model.addAttribute(&quot;message&quot;,&quot;这是Controller传过来的message&quot;);
        return &quot;success&quot;;
    }
}

</code></pre>
<p>4、success.jsp</p>
<pre><code class="language-jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Success&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Success&lt;/h1&gt;
message:${message}
&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<p>5、运行结果</p>
<figure data-type="image" tabindex="36"><img src="https://stormga.github.io//post-images/41.demo2.jpg" alt="" loading="lazy"></figure>
<p>步骤</p>
<p>1、必须创建一个war项目；</p>
<p>2、将嵌入式的Tomcat指定为provided</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;

</code></pre>
<p>3、必须编写一个SpringBootServletInitializer的子类，并调用configure方法里面的固定写法</p>
<pre><code class="language-java">public class ServletInitializer extends SpringBootServletInitializer {

    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
        //传入SpringBoot的主程序，
        return application.sources(SpringBoot04WebJspApplication.class);
    }

}

</code></pre>
<p>4、启动服务器就可以；</p>
<h3 id="3-原理">3、原理</h3>
<p>jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet的容器；</p>
<p>war包：启动服务器，服务器启动SpringBoot应用，【SpringBootServletInitializer】启动ioc容器</p>
<p>servlet3.0规范</p>
<p>8.2.4 共享库和运行时插件</p>
<p>规则：</p>
<p>1、服务器启动（web应用启动），会创建当前的web应用里面每一个jar包里面ServletContrainerInitializer的实现类的实例</p>
<p>2、SpringBootServletInitializer这个类的实现需要放在jar包下的META-INF/services文件夹下，有一个命名为javax.servlet.ServletContainerInitalizer的文件，内容就是ServletContainerInitializer的实现类全类名</p>
<p>3、还可以使用@HandlerTypes注解，在应用启动的时候可以启动我们感兴趣的类</p>
<p>流程：</p>
<p>1、启动Tomcat服务器</p>
<p>2、spring web模块里有这个文件</p>
<figure data-type="image" tabindex="37"><img src="https://stormga.github.io//post-images/42.servletContainerInit.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-java">org.springframework.web.SpringServletContainerInitializer

</code></pre>
<p>3、SpringServletContainerInitializer将handlerTypes标注的所有类型的类传入到onStartip方法的Set&lt;Class&lt;?&gt;&gt;;为这些感兴趣类创建实例</p>
<p>4、每个创建好的WebApplicationInitializer调用自己的onStratup</p>
<p>5、相当于我们的SpringBootServletInitializer的类会被创建对象，并执行onStartup方法</p>
<p>6、SpringBootServletInitializer执行onStartup方法会创建createRootApplicationContext</p>
<pre><code class="language-java">protected WebApplicationContext createRootApplicationContext(ServletContext servletContext) {
    SpringApplicationBuilder builder = this.createSpringApplicationBuilder();
    //环境构建器
    StandardServletEnvironment environment = new StandardServletEnvironment();
    environment.initPropertySources(servletContext, (ServletConfig)null);
    builder.environment(environment);
    builder.main(this.getClass());
    ApplicationContext parent = this.getExistingRootWebApplicationContext(servletContext);
    if (parent != null) {
        this.logger.info(&quot;Root context already created (using as parent).&quot;);
        servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, (Object)null);
        builder.initializers(new ApplicationContextInitializer[]{new ParentContextApplicationContextInitializer(parent)});
    }
	
    builder.initializers(new ApplicationContextInitializer[]{new ServletContextApplicationContextInitializer(servletContext)});
    builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class);
    //调用Configure,子类重写了这个方法，将SpringBoot的主程序类传入进来
    builder = this.configure(builder);
    //创建一个spring应用
    SpringApplication application = builder.build();
    if (application.getSources().isEmpty() &amp;&amp; AnnotationUtils.findAnnotation(this.getClass(), Configuration.class) != null) {
        application.getSources().add(this.getClass());
    }

    Assert.state(!application.getSources().isEmpty(), &quot;No SpringApplication sources have been defined. Either override the configure method or add an @Configuration annotation&quot;);
    if (this.registerErrorPageFilter) {
        application.getSources().add(ErrorPageFilterConfiguration.class);
    }
	//最后启动Spring容器
    return this.run(application);
}

</code></pre>
<p>7、Spring的应用就启动完了并且创建IOC容器；</p>
<pre><code class="language-java">public ConfigurableApplicationContext run(String... args) {
   StopWatch stopWatch = new StopWatch();
   stopWatch.start();
   ConfigurableApplicationContext context = null;
   FailureAnalyzers analyzers = null;
   configureHeadlessProperty();
   SpringApplicationRunListeners listeners = getRunListeners(args);
   listeners.starting();
   try {
      ApplicationArguments applicationArguments = new DefaultApplicationArguments(
            args);
      ConfigurableEnvironment environment = prepareEnvironment(listeners,
            applicationArguments);
      Banner printedBanner = printBanner(environment);
      context = createApplicationContext();
      analyzers = new FailureAnalyzers(context);
      prepareContext(context, environment, listeners, applicationArguments,
            printedBanner);
      refreshContext(context);
      afterRefresh(context, applicationArguments);
      listeners.finished(context, null);
      stopWatch.stop();
      if (this.logStartupInfo) {
         new StartupInfoLogger(this.mainApplicationClass)
               .logStarted(getApplicationLog(), stopWatch);
      }
      return context;
   }
   catch (Throwable ex) {
      handleRunFailure(context, listeners, analyzers, ex);
      throw new IllegalStateException(ex);
   }
}

</code></pre>
<h1 id="五-docker">五、Docker</h1>
<h2 id="1-简介-2">1、简介</h2>
<p>Docker是一个开源的应用容器引擎</p>
<p>将软件编译成一个镜像；然后在镜像里各种软件做好配置，将镜像发布出去，其他的使用这就可以直接使用这个镜像。运行中的这个镜像叫做容器，容器启动速度快，类似ghost操作系统，安装好了什么都有了；</p>
<h2 id="2-docker的核心概念">2、Docker的核心概念</h2>
<p>docker主机（HOST）:安装了Docker程序的机器（Docker直接安装在操作系统上的）</p>
<p>docker客户端（Client）:操作docker主机</p>
<p>docker仓库（Registry）：用来保存打包好的软件镜像</p>
<p>docker镜像（Image）:软件打好包的镜像，放到docker的仓库中</p>
<p>docker容器（Container）:镜像启动后的实例（5个容器启动5次镜像）</p>
<p>docker的步骤：</p>
<p>​	1、安装Docker</p>
<p>​	2、去Docker仓库找到这个软件对应的镜像；</p>
<p>​	3、使用Docker运行的这个镜像，镜像就会生成一个容器</p>
<p>​	4、对容器的启动停止，就是对软件的启动和停止</p>
<h2 id="3-安装docker">3、安装Docker</h2>
<h3 id="1-安装linux">1、安装Linux</h3>
<p><a href="http://note.youdao.com/noteshare?id=06ccb673d253fea78fe35430465758e1">安装vxbox并且安装ubuntu</a></p>
<h3 id="2-在linux上安装docker">2、在linux上安装docker</h3>
<pre><code class="language-shell">1、查看centos版本
# uname -r
3.10.0-693.el7.x86_64
要求：大于3.10
如果小于的话升级*（选做）
# yum update
2、安装docker
# yum install docker
3、启动docker
# systemctl start docker
# docker -v
4、开机启动docker
# systemctl enable docker
5、停止docker
# systemctl stop docker

</code></pre>
<h2 id="4-docker的常用操作">4、docker的常用操作</h2>
<h3 id="1-镜像操作">1、镜像操作</h3>
<p>1、搜索</p>
<pre><code class="language-shell">docker search mysql

</code></pre>
<p>默认去docker hub网站查找 <img src="https://stormga.github.io//post-images/44.docker1.jpg" alt="" loading="lazy"></p>
<p>2、拉取</p>
<pre><code class="language-shell">默认最新版本
# docekr pull mysql
安装指定版本
# docker pull mysql:5.5

</code></pre>
<p>3、查看</p>
<pre><code class="language-shell">docker images

</code></pre>
<p>4、删除</p>
<pre><code>docker rmi imageid

</code></pre>
<h3 id="2-容器操作">2、容器操作</h3>
<p>软件的镜像（qq.exe） -- 运行镜像 -- 产生一个容器（正在运行的软件）</p>
<pre><code class="language-shell">1、搜索镜像
# docker search tomcat
2、拉取镜像
# docker pull tomcat
3、根据镜像启动容器
[root@lion ~]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
docker.io/tomcat    latest              d3d38d61e402        35 hours ago        549 MB
[root@lion ~]# docker run --name mytomcat -d tomcat:latest
2f0348702f5f2a2777082198795d8059d83e5ee38f430d2d44199939cc63e249
4、查看那个进程正在进行
[root@lion ~]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
2f0348702f5f        tomcat:latest       &quot;catalina.sh run&quot;   41 seconds ago      Up 39 seconds       8080/tcp            mytomcat
5、停止运行中容器
[root@lion ~]# docker stop 2f0348702f5f
2f0348702f5f
6、查看所有容器
[root@lion ~]# docker ps -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                       PORTS               NAMES
2f0348702f5f        tomcat:latest       &quot;catalina.sh run&quot;   52 minutes ago      Exited (143) 2 minutes ago                       mytomcat
7、启动容器
[root@lion ~]# docker start 2f0348702f5f
8、删除docker容器
[root@lion ~]# docker rm 2f0348702f5f
2f0348702f5f
9、端口映射
[root@lion ~]# docker run --name mytomcat -d -p 8888:8080 tomcat
692c408c220128014df32ecb6324fb388427d1ecd0ec56325580135c58f63b29
虚拟机:8888
容器的:8080
-d:后台运行
-p:主机端口映射到容器端口
浏览器：192.168.179.129:8888
10、docker的日志
[root@lion ~]# docker logs 692c408c2201
11、多个启动
[root@lion ~]# docker run -d -p 9000:8080 --name mytomcat2 tomcat
浏览器：192.168.179.129:9000

</code></pre>
<p>更多命令参考docker镜像文档</p>
<h3 id="3-安装mysql">3、安装Mysql</h3>
<pre><code class="language-shell">docker pull mysql
docker run --name mysql001 -e MYSQL_ROOT_PASSWORD -d -p 3307:3306 mysql

</code></pre>
<h1 id="六-数据访问">六、数据访问</h1>
<h2 id="1-整合jdbc数据源">1、整合JDBC数据源</h2>
<p>1、新建项目 spring-boot-06-data-jdbc</p>
<ul>
<li>WEB</li>
<li>Mysql</li>
<li>JDBC</li>
<li>SpringBoot1.5</li>
</ul>
<p>2、编写配置文件appliction.yml</p>
<pre><code class="language-yaml">spring:
  datasource:
    username: root
    password: Welcome_1
    url: jdbc:mysql://192.168.179.131:3306/jdbc
    driver-class-name: com.mysql.jdbc.Driver

</code></pre>
<p>3、编写测试类测试</p>
<pre><code class="language-java">@RunWith(SpringRunner.class)
@SpringBootTest
public class SpringBoot06DataJdbcApplicationTests {

    @Autowired
    DataSource dataSource;

    @Test
    public void contextLoads() throws SQLException {
        System.out.println(dataSource.getClass());

        Connection connection = dataSource.getConnection();
        System.out.println(connection);
        connection.close();
    }

}

</code></pre>
<p>4、测试结果</p>
<pre><code>class org.apache.tomcat.jdbc.pool.DataSource
ProxyConnection[PooledConnection[com.mysql.jdbc.JDBC4Connection@c35af2a]]

</code></pre>
<p>数据源相关配置都在DataSourceProperties属性里</p>
<p>自动配置原理</p>
<p>E:\Develop\Maven_Repo\org\springframework\boot\spring-boot-autoconfigure\1.5.13.RELEASE\spring-boot-autoconfigure-1.5.13.RELEASE.jar!\org\springframework\boot\autoconfigure\jdbc</p>
<h3 id="1-datasource">1、DataSource</h3>
<p>参考DataSourceConfiguration,根据配置创建数据源，默认是使用tomcat连接池，可以使用spring.datasource.type指定自定义的数据源</p>
<h3 id="2-springboot默认支持">2、SpringBoot默认支持</h3>
<pre><code>Tomcat数据源
HikariDataSource
dbcp.BasicDataSource
dbcp2.BasicDataSource

</code></pre>
<h3 id="3-自定义数据源">3、自定义数据源</h3>
<pre><code class="language-java"> */
@ConditionalOnMissingBean(DataSource.class)
@ConditionalOnProperty(name = &quot;spring.datasource.type&quot;)
static class Generic {

   @Bean
   public DataSource dataSource(DataSourceProperties properties) {
       //使用builder创建数据源，利用反射创建相应的type数据源，并绑定数据源
      return properties.initializeDataSourceBuilder().build();
   }

}

</code></pre>
<h3 id="4-运行sql建表">4、运行sql建表</h3>
<p>在DataSourceAutoConfiguration中<strong>DataSourceInitializer</strong>类</p>
<p>监听器</p>
<p>作用：</p>
<p>1）、postConstruct -》runSchemaScript 运行建表sql文件</p>
<p>2）、runDataScript运行插入数据的sql语句；</p>
<p>默认只需要将文件命名为：</p>
<pre><code class="language-sql">schema-*.sql data-*.sql
默认规则：schema.sql ,schema-all.sql;

</code></pre>
<p><strong>举个栗子</strong></p>
<p>创建department表</p>
<p>1、department.sql</p>
<pre><code class="language-sql">/*
Navicat MySQL Data Transfer

Source Server         : 192.168.179.131
Source Server Version : 50719
Source Host           : 192.168.179.131:3306
Source Database       : jdbc

Target Server Type    : MYSQL
Target Server Version : 50719
File Encoding         : 65001

Date: 2018-05-14 14:28:52
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for department
-- ----------------------------
DROP TABLE IF EXISTS `department`;
CREATE TABLE `department` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `departmentName` varchar(255) DEFAULT '',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;


</code></pre>
<p>2、将department.sql命名为schema-all.sql</p>
<figure data-type="image" tabindex="38"><img src="https://stormga.github.io//post-images/45.schema-all.jpg" alt="" loading="lazy"></figure>
<p>3、运行测试类</p>
<p>自定义sql的文件名，department.sql在配置文件中</p>
<pre><code class="language-yaml">schema:
  - classpath:department.sql

</code></pre>
<hr>
<h3 id="5-操作jdbctemplate">5、操作JdbcTemplate</h3>
<p><strong>FBI warning</strong>:将department.sql删除或者改名，因为运行文件会将表中数据清除</p>
<p>1、新建一个Controller</p>
<pre><code class="language-java">@Controller
public class HelloController {

    @Autowired
    JdbcTemplate jdbcTemplate;

    @ResponseBody
    @GetMapping(&quot;/hello&quot;)
    public Map&lt;String ,Object&gt; hello(){

        List&lt;Map&lt;String, Object&gt;&gt; list = jdbcTemplate.queryForList(&quot;select * from department&quot;);
        return list.get(0);
    }
}

</code></pre>
<p>2、表中添加数据</p>
<figure data-type="image" tabindex="39"><img src="https://stormga.github.io//post-images/46.department.jpg" alt="" loading="lazy"></figure>
<p>3、访问请求查询数据</p>
<figure data-type="image" tabindex="40"><img src="https://stormga.github.io//post-images/47.hello.jpg" alt="" loading="lazy"></figure>
<h2 id="2-自定义数据源">2、自定义数据源</h2>
<p>1、导入Druid的依赖</p>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;druid&lt;/artifactId&gt;
    &lt;version&gt;1.1.9&lt;/version&gt;
&lt;/dependency&gt;


</code></pre>
<p>2、修改配置文件</p>
<pre><code class="language-yaml">spring:
  datasource:
    username: root
    password: Welcome_1
    url: jdbc:mysql://192.168.179.131:3306/jdbc
    driver-class-name: com.mysql.jdbc.Driver
    type: com.alibaba.druid.pool.DruidDataSource
#    schema:
#      - classpath:department.sql
server:
  port: 9000

</code></pre>
<p>已经替换了原来的tomcat数据源</p>
<p>3、配置Druid数据源配置</p>
<pre><code class="language-yaml">spring:
  datasource:
    username: root
    password: Welcome_1
    url: jdbc:mysql://192.168.179.131:3306/jdbc
    driver-class-name: com.mysql.jdbc.Driver
    type: com.alibaba.druid.pool.DruidDataSource
	# 初始化大小，最小，最大  
    initialSize: 5
    minIdle: 5
    maxActive: 20
    # 配置获取连接等待超时的时间  
    maxWait: 60000
    # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 
    timeBetweenEvictionRunsMillis: 60000
    # 配置一个连接在池中最小生存的时间，单位是毫秒 
    minEvictableIdleTimeMillis: 300000
    validationQuery: SELECT 1 FROM DUAL
    testWhileIdle: true
    testOnBorrow: false
    testOnReturn: false
    poolPreparedStatements: true
    # 配置监控统计拦截的filters,去掉监控界面sql无法统计，‘wall’用于防火墙
    filters: stat,wall,log4j
    maxPoolPreparedStatementPerConnectionSize: 20
    userGlobalDataSourceStat: true
    # 通过connectProperties属性来打开mergeSql功能；慢SQL记录  
    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500
#    schema:
#      - classpath:department.sql
server:
  port: 9000

</code></pre>
<p>4、Druid配置监控</p>
<pre><code class="language-java">@Configuration
public class DruidConfig {

    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)
    @Bean
    public DataSource druid(){
        return  new DruidDataSource();
    }

    //配置Druid的监控
    //1、配置一个管理后台
    @Bean
    public ServletRegistrationBean statViewServlet(){
        ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(),&quot;/druid/*&quot;);
        Map&lt;String,String&gt; initParams =new HashMap&lt;&gt;();
        initParams.put(&quot;loginUsername&quot;, &quot;admin&quot;);
        initParams.put(&quot;loginPassword&quot;, &quot;123456&quot;);
        bean.setInitParameters(initParams);
        return bean;
    }
    //2、配置监控的filter
    @Bean
    public FilterRegistrationBean webstatFilter(){
        FilterRegistrationBean bean = new FilterRegistrationBean();
        bean.setFilter(new WebStatFilter());

        Map&lt;String,String&gt; initParams =new HashMap&lt;&gt;();
        initParams.put(&quot;exclusions&quot;, &quot;*.js,*.css,/druid/*&quot;);
        bean.setInitParameters(initParams);
        bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;));
        return bean;
    }

}

</code></pre>
<p>5、运行测试，访问 localhost:9000/druid</p>
<figure data-type="image" tabindex="41"><img src="https://stormga.github.io//post-images/48.druid.jpg" alt="" loading="lazy"></figure>
<p>输入刚才调好的用户名密码即可访问</p>
<h2 id="3-整合mybatis">3、整合Mybatis</h2>
<p>1、新建工程，SpringBoot1.5+web+JDBC+Mysql</p>
<p>导入依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.3.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;druid&lt;/artifactId&gt;
    &lt;version&gt;1.1.9&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;
&lt;/dependency&gt;

</code></pre>
<p>2、导入配置文件中关于Druid的配置</p>
<p>​	2.1、导入依赖</p>
<p>​	2.2、配置文件application.yml（指定用户名密码...配置Druid的配置参数，修改sql文件加载的默认名）</p>
<p>​	2.3、将Druid组件加入到容器中（监控）重点</p>
<p>​	具体同上</p>
<p>3、创建数据表department和employee表</p>
<p>​	3.1、根据sql文件，新建两张表</p>
<p>​	3.2、修改加载的sql名（默认为schema.sql和schema-all.sql）</p>
<pre><code class="language-yaml">spring:
  datasource:
    schema:
      - classpath:sql/department.sql
      - classpath:sql/employeee.sql

</code></pre>
<p>​	3.3、运行程序检查数据库是否创建成功</p>
<p>4、创建数据库对应的JavaBean （驼峰命名，getter/setter toString/注释掉schema防止重复创建）</p>
<p>在配置文件中修改驼峰命名开启 ,不写配置文件就写配置类</p>
<pre><code class="language-yaml">mybatis:
  configuration:
    map-underscore-to-camel-case: true

</code></pre>
<pre><code class="language-java">//类名冲突所以全类名
@org.springframework.context.annotation.Configuration
public class MyBatisConfig {

    @Bean
    public ConfigurationCustomizer configurationCustomizer(){

        return new ConfigurationCustomizer() {
            @Override
            public void customize(Configuration configuration) {
                configuration.setMapUnderscoreToCamelCase(true);
            }
        };
    }
}

</code></pre>
<h3 id="注解方式">注解方式</h3>
<p>5、新建mapper</p>
<pre><code class="language-yaml">//指定是一个mapper
@Mapper
public interface DepartmentMapper {

    @Insert(&quot;insert into department(dept_name) value(#{deptName})&quot;)
    public int insertDept(Department department);

    @Delete(&quot;delete from department where id=#{id}&quot;)
    public int deleteDeptById(Integer id);

    @Update(&quot;update department set dept_Name=#{deptName} where id=#{id}&quot;)
    public int updateDept(Department department);

    @Select(&quot;select * from department where id=#{id}&quot;)
    public Department getDeptById(Integer id);

}

</code></pre>
<p>6、编写controller测试</p>
<pre><code class="language-java">@RestController
public class DeptController {

    @Autowired
    DepartmentMapper departmentMapper;

    @RequestMapping(&quot;/getDept/{id}&quot;)
    public Department getDepartment(@PathVariable(&quot;id&quot;) Integer id){
        return departmentMapper.getDeptById(id);
    }

    @RequestMapping(&quot;/delDept/{id}&quot;)
    public int delDept(@PathVariable(&quot;id&quot;) Integer id){
        return departmentMapper.deleteDeptById(id);
    }

    @RequestMapping(&quot;/update/{id}&quot;)
    public int updateDept(@PathVariable(&quot;id&quot;) Integer id){
        return departmentMapper.updateDept(new Department(id, &quot;开发部&quot;));
    }

    @GetMapping(&quot;/insert&quot;)
    public int insertDept(Department department){
        return departmentMapper.insertDept(department);
    }
}

</code></pre>
<p>问题：</p>
<p>mapper文件夹下有多个mapper文件，加麻烦，可以直接扫描整个mapper文</p>
<p>件夹下的mapper</p>
<pre><code class="language-java">//主配置类或者mybatis配置类
@MapperScan(value = &quot;com.wdjr.springboot.mapper&quot;)

</code></pre>
<h3 id="配置文件方式">配置文件方式</h3>
<p>1、新建文件</p>
<figure data-type="image" tabindex="42"><img src="https://stormga.github.io//post-images/50.mybatisxml.jpg" alt="" loading="lazy"></figure>
<p>2、新建mybatis的配置文件</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;settings&gt;
        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
    &lt;/settings&gt;
&lt;/configuration&gt;

</code></pre>
<p>3、新建Employee的接口方法</p>
<pre><code class="language-java">public interface EmployeeMapper {

    public Employee getEmpById(Integer id);

    public void insetEmp(Employee employee);
}

</code></pre>
<p>4、新建Employee的mapper.xml的映射文件</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.wdjr.springboot.mapper.EmployeeMapper&quot;&gt;
    &lt;select id=&quot;getEmpById&quot; resultType=&quot;com.wdjr.springboot.bean.Employee&quot;&gt;
      select * from employee where id=#{id}
   &lt;/select&gt;

    &lt;insert id=&quot;insetEmp&quot;&gt;
        INSERT  INTO employee(last_name,email,gender,d_id) VALUES (#{lastName},#{email},#{gender},#{dId})
    &lt;/insert&gt;
&lt;/mapper&gt;

</code></pre>
<p>5、修改application.yml配置文件</p>
<pre><code class="language-yaml">mybatis:
  config-location: classpath:mybatis/mybatis-config.xml
  mapper-locations: classpath:mybatis/mapper/*.xml

</code></pre>
<p>6、新建一个Controller访问方法</p>
<pre><code class="language-java">@RestController
public class EmployeeController {
    @Autowired
    EmployeeMapper employeeMapper;

    @RequestMapping(&quot;/getEmp/{id}&quot;)
    public Employee getEmp(@PathVariable(&quot;id&quot;) Integer id){
        return employeeMapper.getEmpById(id);
    }

    @GetMapping(&quot;/insertEmp&quot;)
    public Employee insertEmp(Employee employee){
        employeeMapper.insetEmp(employee);
        return employee;
    }
}

</code></pre>
<h2 id="4-jpa数据访问">4、JPA数据访问</h2>
<p>新建工程 springBoot1.5+Web+JPA+MYSQL+JDBC</p>
<p>目录结构</p>
<figure data-type="image" tabindex="43"><img src="https://stormga.github.io//post-images/51.JPA.jpg" alt="" loading="lazy"></figure>
<p>1、新建一个实体类User</p>
<pre><code class="language-java">//使用JPA注解配置映射关系
@Entity//告诉JPA这是一个实体类（和数据表映射的类）
@Table(name=&quot;tbl_user&quot;) //@Table来指定和那个数据表对应，如果省略默认表明就是user;

public class User {

    @Id //这是一个主键
    @GeneratedValue(strategy = GenerationType.IDENTITY)//自增组件
    private Integer id ;

    @Column(name=&quot;last_name&quot;,length = 50) //这是和数据表对应的一个列
    private String lastName;
    @Column//省略默认列名就是属性名
    private String email;
    @Column
    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }
}

</code></pre>
<p>2、新建一个UserRepository来继承jpa的绝大多数功能</p>
<pre><code class="language-java">//继承jpaRepository
public interface UserRepository extends JpaRepository&lt;User,Integer&gt; {

}

</code></pre>
<p>3、编写配置文件application.yml</p>
<pre><code class="language-yaml">spring:
  datasource:
    url: jdbc:mysql://192.168.179.131/jpa
    username: root
    password: Welcome_1
    driver-class-name: com.mysql.jdbc.Driver
  jpa:
    hibernate:
    #更新或创建
      ddl-auto: update
    show-sql: true

</code></pre>
<p>4、编写Controller测试</p>
<pre><code class="language-java">@RestController
public class UserController {
    @Autowired
    UserRepository userRepository;

    @GetMapping(&quot;/user/{id}&quot;)
    public User getUser(@PathVariable(&quot;id&quot;) Integer id){
        User user = userRepository.findOne(id);
        return user;
    }

    @GetMapping(&quot;/insert&quot;)
    public User insertUser(User user){
        User user1 = userRepository.save(user);
        return  user1;
    }
}

</code></pre>
<h1 id="七-启动配置原理">七、启动配置原理</h1>
<p>几个重要的事件回调机制</p>
<p>加载配置文件META-INF/spring.factories</p>
<p>​	ApplicationContextInitializer</p>
<p>​	SpringApplicationRunListener</p>
<p>ioc容器中</p>
<p>​	ApplicationRunner</p>
<p>​	CommandLineRunner</p>
<p>启动流程</p>
<h2 id="1-创建springapplicaiotn对象">1、创建SpringApplicaiotn对象</h2>
<pre><code class="language-java">private void initialize(Object[] sources) {
    //保存主配置类
   if (sources != null &amp;&amp; sources.length &gt; 0) {
      this.sources.addAll(Arrays.asList(sources));
   }
    //判断当前是否是个web应用
   this.webEnvironment = deduceWebEnvironment();
    //从类路径下找到META-INF/spring.factories配置中的所有ApplicationInitializer 然后保存起来
   setInitializers((Collection) getSpringFactoriesInstances(
         ApplicationContextInitializer.class));
    //从类路径下找到META-INF/spring.factories配置中的所有ApplicationListener 然后保存起来
   setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
    //决定哪一个是主程序
   this.mainApplicationClass = deduceMainApplicationClass();
}

</code></pre>
<p>ApplicationInitializer</p>
<figure data-type="image" tabindex="44"><img src="https://stormga.github.io//post-images/52.applicationCotextInitializer.jpg" alt="" loading="lazy"></figure>
<p>ApplicationListener</p>
<figure data-type="image" tabindex="45"><img src="https://stormga.github.io//post-images/53.Listener.jpg" alt="" loading="lazy"></figure>
<h2 id="2-运行run方法">2、运行Run方法</h2>
<pre><code class="language-java">public ConfigurableApplicationContext run(String... args) {
   StopWatch stopWatch = new StopWatch();
   stopWatch.start();
   ConfigurableApplicationContext context = null;
   FailureAnalyzers analyzers = null;
   configureHeadlessProperty();
    //获取SpringApplicationRunListeners;从类路径下META-INF/spring.factory
   SpringApplicationRunListeners listeners = getRunListeners(args);
    //回调所有的SpringApplicationRunListener.starting()方法
   listeners.starting();
   try {
       //封装命令行参数
      ApplicationArguments applicationArguments = new DefaultApplicationArguments(
            args);
       //准备环境
      ConfigurableEnvironment environment = prepareEnvironment(listeners,
            applicationArguments);
       //创建环境，完成后回调SpringApplicationRunListener.environmentPrepared环境准备完成
       //打印SpringBoot图标
      Banner printedBanner = printBanner(environment);
       //创建ApplicationContext，决定创建web的ioc容器还是普通的ioc
      context = createApplicationContext();
       //异常分析
      analyzers = new FailureAnalyzers(context);
       //重点：将environment保存的ioc中，applyInitializers初始化器上面那6个的获取，并且回调ApplicationContextInitializer.initialize方法
       
       //回调所有的SpringApplicationRunListener的contextPrepare()
       //告诉prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded
      prepareContext(context, environment, listeners, applicationArguments,
            printedBanner);
       //重要：刷新所有组件 ioc容器初始化，如果是web应用还会创建嵌入式的tomcat
       //扫描 创建加载所有组件的地方
      refreshContext(context);
       //从ioc中获取所有的ApplicationRunner和CommandLineRunner
       //ApplicationRunner先回调
      afterRefresh(context, applicationArguments);
       //所有的SpringApplicationRunListener回调finished方法
      listeners.finished(context, null);
       //保存应用状态
      stopWatch.stop();
      if (this.logStartupInfo) {
         new StartupInfoLogger(this.mainApplicationClass)
               .logStarted(getApplicationLog(), stopWatch);
      }
       //整个springboot启动完成以后返回启动的ioc容器
      return context;
   }
   catch (Throwable ex) {
      handleRunFailure(context, listeners, analyzers, ex);
      throw new IllegalStateException(ex);
   }
}

</code></pre>
<h2 id="3-事件监听机制">3、事件监听机制</h2>
<p>新建listener监听</p>
<p>文件目录</p>
<figure data-type="image" tabindex="46"><img src="https://stormga.github.io//post-images/54.listener2.jpg" alt="" loading="lazy"></figure>
<p>1、HelloApplicationContextInitializer</p>
<pre><code class="language-java">//泛型监听ioc容器
public class HelloApplicationContextInitializer implements ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; {
    @Override
    public void initialize(ConfigurableApplicationContext applicationContext) {
        System.out.println(&quot;ApplicationContextInitializer...跑起来了.....&quot;+applicationContext);
    }
}

</code></pre>
<p>2、HelloSpringApplicationRunListener</p>
<p>加构造器</p>
<pre><code class="language-java">public class HelloSpringApplicationRunListener implements SpringApplicationRunListener {

    public HelloSpringApplicationRunListener(SpringApplication application, String[] args){

    }

    @Override
    public void starting() {
        System.out.println(&quot;监听容器开始......&quot;);
    }

    @Override
    public void environmentPrepared(ConfigurableEnvironment environment) {
        System.out.println(&quot;环境准备好了......&quot;+environment.getSystemProperties().get(&quot;os.name&quot;));
    }

    @Override
    public void contextPrepared(ConfigurableApplicationContext context) {
        System.out.println(&quot;ioc容器准备好了......&quot;);
    }

    @Override
    public void contextLoaded(ConfigurableApplicationContext context) {
        System.out.println(&quot;容器环境已经加载完成......&quot;);
    }

    @Override
    public void finished(ConfigurableApplicationContext context, Throwable exception) {
        System.out.println(&quot;全部加载完成......&quot;);
    }
}

</code></pre>
<p>3、HelloApplicationRunner</p>
<pre><code class="language-java">@Component
public class HelloApplicationRunner implements ApplicationRunner {
    @Override
    public void run(ApplicationArguments args) throws Exception {
        System.out.println(&quot;ApplicationRunner.....run....&quot;);
    }
}

</code></pre>
<p>4、HelloCommandLineRunner</p>
<pre><code class="language-java">@Component
public class HelloCommandLineRunner implements CommandLineRunner {
    @Override
    public void run(String... args) throws Exception {
        System.out.println(&quot;CommandLineRunner......run.....&quot;+Arrays.asList(args));
    }
}

</code></pre>
<p>事件运行方法</p>
<p>HelloApplicationContextInitializer和HelloSpringApplicationRunListener文件META-INF/spring.factories中加入</p>
<pre><code># Initializers
org.springframework.context.ApplicationContextInitializer=\
com.wdjr.springboot.listener.HelloApplicationContextInitializer

org.springframework.boot.SpringApplicationRunListener=\
com.wdjr.springboot.listener.HelloSpringApplicationRunListener

</code></pre>
<p>HelloApplicationRunner和HelloCommandLineRunner ioc加入</p>
<p>@Component</p>
<h1 id="八-springboot的自定义starter">八、SpringBoot的自定义starter</h1>
<p>starter：场景启动器</p>
<p>1、场景需要使用什么依赖？</p>
<p>2、如何编写自动配置</p>
<pre><code class="language-java">@Configuration //指定这个类是一个配置类
@ConditionalOnXXX //在指定条件下成立的情况下自动配置类生效
@AutoConfigureAfter //指定自动配置类的顺序
@Bean //给容器中添加组件

@ConfigurationProperties //结合相关xxxProperties类来绑定相关的配置
@EnableConfigurationProperties //让xxxProperties生效加到容器中

自动配置类要能加载
将需要启动就加载的自动配置类，配置在META-INF/spring.factories
# Auto Configure
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\
org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\

</code></pre>
<p>3、模式</p>
<p>启动器空的jar只需要做依赖管理导入；</p>
<p>专门写一个自动配置模块；</p>
<p>启动器依赖自动配置，别人只需要引入starter</p>
<p>xxx-spring-boot-starter</p>
<h3 id="新建一个starter">新建一个starter</h3>
<blockquote>
<p>绕的你怀疑人生</p>
</blockquote>
<h4 id="1-新建一个空项目工程">1、新建一个空项目工程</h4>
<figure data-type="image" tabindex="47"><img src="https://stormga.github.io//post-images/56.starter01.jpg" alt="" loading="lazy"></figure>
<p>2、项目命名</p>
<figure data-type="image" tabindex="48"><img src="https://stormga.github.io//post-images/57.starter02.jpg" alt="" loading="lazy"></figure>
<p>3、导入module</p>
<figure data-type="image" tabindex="49"><img src="https://stormga.github.io//post-images/58.starter03.jpg" alt="" loading="lazy"></figure>
<p>4、新建一个Maven工程</p>
<figure data-type="image" tabindex="50"><img src="https://stormga.github.io//post-images/59.starter04.jpg" alt="" loading="lazy"></figure>
<p>5、项目命名</p>
<figure data-type="image" tabindex="51"><img src="https://stormga.github.io//post-images/60.starter05.jpg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="52"><img src="https://stormga.github.io//post-images/61.starter06.jpg" alt="" loading="lazy"></figure>
<p>6、在新建一个autoconfiguration类的spring</p>
<figure data-type="image" tabindex="53"><img src="https://stormga.github.io//post-images/62.starter07.jpg" alt="" loading="lazy"></figure>
<p>7、项目命名</p>
<figure data-type="image" tabindex="54"><img src="https://stormga.github.io//post-images/63.starter08.jpg" alt="" loading="lazy"></figure>
<p>8、无需导入依赖</p>
<figure data-type="image" tabindex="55"><img src="https://stormga.github.io//post-images/64.starter09.jpg" alt="" loading="lazy"></figure>
<p>9、next</p>
<figure data-type="image" tabindex="56"><img src="https://stormga.github.io//post-images/65.starter10.jpg" alt="" loading="lazy"></figure>
<p>最后配置完成</p>
<h4 id="2-编写starter">2、编写starter</h4>
<h5 id="autoconfigurer">autoconfigurer</h5>
<p>对<strong>lkh-spring-boot-starter-autoconfigurer</strong>进行删减</p>
<p>目录</p>
<figure data-type="image" tabindex="57"><img src="https://stormga.github.io//post-images/66.starter-build01.jpg" alt="" loading="lazy"></figure>
<p>2、pom文件修改</p>
<pre><code class="language-xml">    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;

    &lt;/dependencies&gt;


&lt;/project&gt;

</code></pre>
<p>3、编写相关的类</p>
<figure data-type="image" tabindex="58"><img src="https://stormga.github.io//post-images/67.starter-build02.jpg" alt="" loading="lazy"></figure>
<p>4、HelloProperties</p>
<pre><code class="language-java">package com.lkh.starter;


import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties(prefix = &quot;lkh.hello&quot;)
public class HelloProperties {
    private String prefix;
    private String suffix;

    public String getPrefix() {
        return prefix;
    }

    public void setPrefix(String prefix) {
        this.prefix = prefix;
    }

    public String getSuffix() {
        return suffix;
    }

    public void setSuffix(String suffix) {
        this.suffix = suffix;
    }
}

</code></pre>
<p>5、HelloService</p>
<pre><code class="language-java">package com.lkh.starter;

public class HelloService {

    HelloProperties helloProperties;

    public HelloProperties getHelloProperties() {
        return helloProperties;
    }

    public void setHelloProperties(HelloProperties helloProperties) {
        this.helloProperties = helloProperties;
    }

    public String sayHello(String name){
        return helloProperties.getPrefix()+name+helloProperties.getSuffix();
    }
}

</code></pre>
<p>6、HelloServiceAutoConfiguration</p>
<pre><code class="language-java">package com.lkh.starter;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@ConditionalOnWebApplication
@EnableConfigurationProperties(HelloProperties.class)
public class HelloServiceAutoConfiguration {

    @Autowired
    HelloProperties helloProperties;
    @Bean
    public HelloService helloService(){
        HelloService service = new HelloService();
        service.setHelloProperties(helloProperties);
        return service;
    }

}

</code></pre>
<p>7、配置文件</p>
<pre><code>org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.lkh.starter.HelloServiceAutoConfiguration

</code></pre>
<p>8、修改lkh-spring-boot-starter 也就是之前的Maven项目，修改pom文件引入autoconfiguration依赖</p>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.lkh.starter&lt;/groupId&gt;
        &lt;artifactId&gt;lkh-spring-boot-starter-autoconfigurer&lt;/artifactId&gt;
        &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

</code></pre>
<p>9、install生成</p>
<figure data-type="image" tabindex="59"><img src="https://stormga.github.io//post-images/68.starter-build03.jpg" alt="" loading="lazy"></figure>
<h4 id="3-测试">3、测试</h4>
<p>新建一个springboot 1.5+web</p>
<p>1、引入starter</p>
<pre><code class="language-xml">    &lt;dependency&gt;
        &lt;groupId&gt;com.lkh.starter&lt;/groupId&gt;
        &lt;artifactId&gt;lkh-spring-boot-starter&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;

&lt;/dependencies&gt;

</code></pre>
<p>2、新建一个Controller用来测试</p>
<pre><code class="language-java">@RestController
public class HelloController {

    @Autowired
    HelloService helloService;

    @GetMapping
    public  String hello(){
        return helloService.sayHello(&quot;test&quot;);
    }
}

</code></pre>
<p>3、编写配置文件制定前缀和后缀名</p>
<pre><code class="language-properties">lkh.hello.prefix=Starter-
lkh.hello.suffix=-Success

</code></pre>
<p>4、运行访问http://localhost:8080/hello</p>
<figure data-type="image" tabindex="60"><img src="https://stormga.github.io//post-images/70.starter-build05.jpg" alt="" loading="lazy"></figure>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://stormga.github.io/post/redis-replication/" class="post-title gt-a-link">
                    Redis主从复制
                </a>
            </div>
        

        
            
                <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '9f08b02d55852a9358a9',
    clientSecret: '8a0742474fa3482c2b8462606c0d6a9cfeff8621',
    repo: 'stormGa.github.io',
    owner: 'stormGa',
    admin: ['stormGa'],
    id: location.pathname,      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

            

            
        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">Every 🐦 has an 🦅's dream.</div>
    <div class="social-container">
        
            
        
            
        
            
        
            
        
            
        
            
        
    </div>
    <a href="www.github.com/stormGa">github</a> | <a href="https://stormga.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
    hljs.initHighlightingOnLoad()
</script>


    </div>
</div>
</body>
</html>
