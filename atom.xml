<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://stormga.github.io/</id>
    <title>Kohath</title>
    <updated>2020-03-09T08:01:59.506Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://stormga.github.io/"/>
    <link rel="self" href="https://stormga.github.io/atom.xml"/>
    <subtitle>Every 🐦 has an 🦅&apos;s dream.</subtitle>
    <logo>https://stormga.github.io/images/avatar.png</logo>
    <icon>https://stormga.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Kohath</rights>
    <entry>
        <title type="html"><![CDATA[Java-集合]]></title>
        <id>https://stormga.github.io/post/java-ji-he/</id>
        <link href="https://stormga.github.io/post/java-ji-he/">
        </link>
        <updated>2020-03-09T07:46:38.000Z</updated>
        <content type="html"><![CDATA[<h1 id="集合">集合</h1>
<ul>
<li>集合是用来存储类型数据的容器</li>
<li>集合是用来存储对象的引用</li>
</ul>
<h2 id="collection集合常用方法">Collection集合常用方法</h2>
<table>
<thead>
<tr>
<th>boolean</th>
<th><a href="#add-E-">add</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/Collection.html">E</a> e) 向集合中添加元素e</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td><a href="#addAll-java.util.Collection-">addAll</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/Collection.html">Collection</a>&lt;? extends <a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/Collection.html">E</a>&gt; c)  把c集合中的所有元素添加到当前集合中</td>
</tr>
<tr>
<td>void</td>
<td><a href="#clear--">clear</a>() 清空集合中所有元素.</td>
</tr>
<tr>
<td>boolean</td>
<td><a href="#contains-java.lang.Object-">contains</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/lang/Object.html">Object</a> o) 判断当前集合是否包含指定元素o.</td>
</tr>
<tr>
<td>boolean</td>
<td><a href="#containsAll-java.util.Collection-">containsAll</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/Collection.html">Collection</a>&lt;?&gt; c) 判断当前集合是否包含c集合中的所有元素</td>
</tr>
<tr>
<td>boolean</td>
<td><a href="#equals-java.lang.Object-">equals</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/lang/Object.html">Object</a> o).</td>
</tr>
<tr>
<td>int</td>
<td><a href="#hashCode--">hashCode</a>().</td>
</tr>
<tr>
<td>boolean</td>
<td><a href="#isEmpty--">isEmpty</a>() 判断集合是否为空.</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/Iterator.html">Iterator</a><E></td>
<td><a href="#iterator--">iterator</a>() 返回集合的迭代器.</td>
</tr>
<tr>
<td>boolean</td>
<td><a href="#remove-java.lang.Object-">remove</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/lang/Object.html">Object</a> o) 在当前集合中删除第一个与元素o匹配的元素.</td>
</tr>
<tr>
<td>boolean</td>
<td><a href="#removeAll-java.util.Collection-">removeAll</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/Collection.html">Collection</a>&lt;?&gt; c) 在当前集合中删除所有出现在c集合中的元素.</td>
</tr>
<tr>
<td>boolean</td>
<td><a href="#retainAll-java.util.Collection-">retainAll</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/Collection.html">Collection</a>&lt;?&gt; c) 只保留在集合c中出现的元素,其他的元素都删除.</td>
</tr>
<tr>
<td>int</td>
<td><a href="#size--">size</a>() 返回元素的个数.</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/lang/Object.html">Object</a>[]</td>
<td><a href="#toArray--">toArray</a>() 集合转数组.</td>
</tr>
<tr>
<td><T> T[]</td>
<td><a href="#toArray-T:A-">toArray</a>(T[] a)</td>
</tr>
</tbody>
</table>
<h2 id="list集合">List集合</h2>
<ul>
<li>继承了Collection,Collection所有的操作,List都有</li>
<li>List存储特点: 有序,可重复</li>
<li>List集合为每个元素指定一个索引值, 主要增加了针对索引值的操作</li>
</ul>
<table>
<thead>
<tr>
<th>void</th>
<th><a href="#add-int-E-">add</a>(int index, <a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/List.html">E</a> element) 在指定位置添加元素</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td><a href="#addAll-int-java.util.Collection-">addAll</a>(int index, <a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/Collection.html">Collection</a>&lt;? extends <a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/List.html">E</a>&gt; c)</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/List.html">E</a></td>
<td><a href="#get-int-">get</a>(int index) 返回指定位置元素的值</td>
</tr>
<tr>
<td>int</td>
<td><a href="#indexOf-java.lang.Object-">indexOf</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/lang/Object.html">Object</a> o) 返回元素o第一次出现的位置</td>
</tr>
<tr>
<td>int</td>
<td><a href="#lastIndexOf-java.lang.Object-">lastIndexOf</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/lang/Object.html">Object</a> o) 返回元素o最后一次出现的索引值</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/ListIterator.html">ListIterator</a><E></td>
<td><a href="#listIterator--">listIterator</a>() 返回ListIterator迭代器</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/List.html">E</a></td>
<td><a href="#remove-int-">remove</a>(int index)</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/List.html">E</a></td>
<td><a href="#set-int-E-">set</a>(int index, <a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/List.html">E</a> element)</td>
</tr>
<tr>
<td>void</td>
<td><a href="#sort-java.util.Comparator-">sort</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/Comparator.html">Comparator</a>&lt;? super <a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/List.html">E</a>&gt; c)</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/List.html">List</a><E></td>
<td><a href="#subList-int-int-">subList</a>(int fromIndex, int toIndex) 返回子列表</td>
</tr>
</tbody>
</table>
<h3 id="arraylist和vector">ArrayList和Vector</h3>
<ul>
<li>底层都是数组</li>
<li>默认初始化容量: 10</li>
<li>ArrayList扩容: 1.5倍,  Vector默认按2倍大小扩容</li>
<li>Vector提供的操作都使用synchronized修饰, 是线程安全的, ArrayList不是线程安全的</li>
</ul>
<h3 id="linkedlist">LinkedList</h3>
<ul>
<li>底层是双向链表</li>
<li>常用操作</li>
</ul>
<table>
<thead>
<tr>
<th>void</th>
<th><a href="#addFirst-E-">addFirst</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/LinkedList.html">E</a> e) 把元素e添加到链表的头部</th>
</tr>
</thead>
<tbody>
<tr>
<td>void</td>
<td><a href="#addLast-E-">addLast</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/LinkedList.html">E</a> e)  把元素e添加到最后</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/Iterator.html">Iterator</a><E></td>
<td><a href="#descendingIterator--">descendingIterator</a>() 逆序迭代</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/LinkedList.html">E</a></td>
<td><a href="#element--">element</a>() 返回第一个元素.</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/LinkedList.html">E</a></td>
<td><a href="#getFirst--">getFirst</a>()返回第一个元素.</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/LinkedList.html">E</a></td>
<td><a href="#getLast--">getLast</a>()返回最后一个元素</td>
</tr>
<tr>
<td>boolean</td>
<td><a href="#offer-E-">offer</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/LinkedList.html">E</a> e) 把元素e添加到最后.</td>
</tr>
<tr>
<td>boolean</td>
<td><a href="#offerFirst-E-">offerFirst</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/LinkedList.html">E</a> e) 把元素e添加到最前面,链表的头部</td>
</tr>
<tr>
<td>boolean</td>
<td><a href="#offerLast-E-">offerLast</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/LinkedList.html">E</a> e) 把元素e添加到最后</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/LinkedList.html">E</a></td>
<td><a href="#peek--">peek</a>().返回第一个元素.</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/LinkedList.html">E</a></td>
<td><a href="#peekFirst--">peekFirst</a>()返回第一个元素.</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/LinkedList.html">E</a></td>
<td><a href="#peekLast--">peekLast</a>()返回最后一个元素.</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/LinkedList.html">E</a></td>
<td><a href="#poll--">poll</a>() 删除第一个元素,并把删除的元素返回.</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/LinkedList.html">E</a></td>
<td><a href="#pollFirst--">pollFirst</a>()删除第一个元素,并把删除的元素返回..</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/LinkedList.html">E</a></td>
<td><a href="#pollLast--">pollLast</a>()删除最后一个元素,并把删除的元素返回.</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/LinkedList.html">E</a></td>
<td><a href="#pop--">pop</a>()删除第一个元素,并把删除的元素返回.</td>
</tr>
<tr>
<td>void</td>
<td><a href="#push-E-">push</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/LinkedList.html">E</a> e) 把元素e添加到链表的头部</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/LinkedList.html">E</a></td>
<td><a href="#removeFirst--">removeFirst</a>()删除第一个元素,并把删除的元素返回.</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/LinkedList.html">E</a></td>
<td><a href="#removeLast--">removeLast</a>()删除最后一个元素,并把删除的元素返回.</td>
</tr>
</tbody>
</table>
<h2 id="set集合">Set集合</h2>
<p>**特点：无序，不可重复 **</p>
<h3 id="hashset">HashSet</h3>
<ul>
<li>
<p>HashSet底层是HashMap, HashSet的无参构造给hashMap进行了初始化</p>
</li>
<li>
<p>向hashSet中通过add(e)添加一个元素, 实际上是把这个元素作为 键,添加到了底层的hashMap中</p>
<p>map.put(e, PRESENT)</p>
</li>
<li>
<p>HashSet实际上是就是底层HashMap的键的集合</p>
</li>
<li>
<p>因为Map中的键不允许重复,所以HashSet也不能存储重复的元素</p>
</li>
</ul>
<h3 id="treeset">TreeSet</h3>
<ul>
<li>
<p>TreeSet 实现了SortedSet, 可以对存储的元素进行自然排序</p>
</li>
<li>
<p>TreeSet要求存储的元素必须是可比较的</p>
<ul>
<li>要么指定Comparator比较器</li>
<li>没有Comparator比较器,元素的类要实现Comparable接口</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/TreeSet.html">E</a></th>
<th><a href="#ceiling-E-">ceiling</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/TreeSet.html">E</a> e) 返回Set集合中大于等于指定元素e的最小元素.</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/Iterator.html">Iterator</a><E></td>
<td><a href="#descendingIterator--">descendingIterator</a>() 返回TreeSet集合的逆序迭代.</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/NavigableSet.html">NavigableSet</a><E></td>
<td><a href="#descendingSet--">descendingSet</a>() 返回TreeSet集合的逆序.</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/TreeSet.html">E</a></td>
<td><a href="#first--">first</a>() 返回TreeSet集合中的第一个元素</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/TreeSet.html">E</a></td>
<td><a href="#floor-E-">floor</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/TreeSet.html">E</a> e) 返回Set集合中小于等于指定元素e的最大元素.</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/SortedSet.html">SortedSet</a><E></td>
<td><a href="#headSet-E-">headSet</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/TreeSet.html">E</a> toElement) 返回TreeSet集合从开始到指定元素toElement之间的视图</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/NavigableSet.html">NavigableSet</a><E></td>
<td><a href="#headSet-E-boolean-">headSet</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/TreeSet.html">E</a> toElement, boolean inclusive).</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/TreeSet.html">E</a></td>
<td><a href="#higher-E-">higher</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/TreeSet.html">E</a> e). 返回TreeSet集合中大于指定元素e的最小元素</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/TreeSet.html">E</a></td>
<td><a href="#last--">last</a>()返回TreeSet集合最后一个元素</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/TreeSet.html">E</a></td>
<td><a href="#lower-E-">lower</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/TreeSet.html">E</a> e) 返回TreeSet集合中小于指定元素e的最大元素</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/TreeSet.html">E</a></td>
<td><a href="#pollFirst--">pollFirst</a>() 删除TreeSet集合的第一个元素,并把删除的元素返回.</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/TreeSet.html">E</a></td>
<td><a href="#pollLast--">pollLast</a>()删除TreeSet集合的最后一个元素,并把删除的元素返回</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/SortedSet.html">SortedSet</a><E></td>
<td><a href="#subSet-E-E-">subSet</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/TreeSet.html">E</a> fromElement, <a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/TreeSet.html">E</a> toElement) 返回TreeSet指定范围[fromElement, toElement)内的视图 .</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/SortedSet.html">SortedSet</a><E></td>
<td><a href="#tailSet-E-">tailSet</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/TreeSet.html">E</a> fromElement).返回从指定元素fromElement到最后的一个子视图</td>
</tr>
</tbody>
</table>
<p><strong>注意:</strong></p>
<ul>
<li>
<p>TreeSet集合的contains()/remove()方法是根据Comparator或者Comparable的比较结果是否为0来判断元素是否存在</p>
</li>
<li>
<p>如何选择Comparator还是Comparable??</p>
<p>通过Comparator可以定义多种比较器</p>
<p>类实现了Comparable接口之后 ,排序规则就固定了, 可以把它当作默认的排序</p>
</li>
</ul>
<h2 id="迭代器">迭代器</h2>
<p><strong>集合继承Iterable接口，用集合的iteartor()方法得到迭代器对象</strong></p>
<h3 id="collection集合中使用迭代器">Collection集合中使用迭代器</h3>
<pre><code class="language-java">Iterator&lt;String&gt; iterator = collection.iterator();
		/*
		 * 1)刚刚获得迭代器对象时, 迭代器的游标指向第一个元素的前面
		 * 2) hasNext()判断是否还有没有访问到的元素
		 * 3) next()把下一个没访问的元素返回, 游标下移
		 */
		while( iterator.hasNext()){
			String next = iterator.next();
			System.out.println( next );
		}
</code></pre>
<p>###迭代器中有两个重要方法</p>
<ul>
<li>hasNext() 判断游标后面还有 没有访问到的元素</li>
<li>next() 把下一个没有访问的元素返回，游标下移</li>
</ul>
<h3 id="使用迭代器的注意事项">使用迭代器的注意事项</h3>
<ul>
<li>
<p>每次迭代完后，游标就在最后一个元素后面，如果我们还想使用迭代器我们需要重新获取</p>
</li>
<li>
<pre><code class="language-java">Iterator&lt;String&gt; iterator = collection.iterator();
      while(iterator.hasNext()){
          collection.remove(&quot;abc&quot;);
      
</code></pre>
</li>
</ul>
<pre><code>  **这段代码是错误的**

  我们阅读源码会发现：

  Iterator在创建的时候会返回一个Itr对象

  源码：

  ```java
      public Iterator&lt;E&gt; iterator() {
          return new Itr();
      }
</code></pre>
<p>而这个Itr是集合的内部类，我们以ArrayList分析</p>
<pre><code class="language-java">  private class Itr implements Iterator&lt;E&gt; {
      int cursor;       // index of next element to return
      int lastRet = -1; // index of last element returned; -1 if no such
      int expectedModCount = modCount;

      // prevent creating a synthetic constructor
      Itr() {}

</code></pre>
<p>这个modCount是ArrayList的一个成员变量</p>
<p>​</p>
<pre><code class="language-java">protected transient int modCount = 0;
</code></pre>
<p>每次ArrayList进行 remove,add操作就会改变modCount的值。</p>
<p>而迭代器的next方法会检查这两个值是否一样，不一样会抛异常。</p>
<p><strong>结论：</strong></p>
<p><strong>当我们创建的Iterator时，我们就不能使用集合自身的remove，add等方法了，否则我们进行迭代的时候会抛异常。由于foreach循环是底层是迭代器实现的，所以我们在foreach循环的时候也不能使用remove，add，clear等方法</strong></p>
<h2 id="map集合">Map集合</h2>
<h3 id="linkedhashmap">LinkedHashMap</h3>
<pre><code class="language-java">public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt;
</code></pre>
<p>继承自HashMap，一个有序的Map接口实现，这里的有序指的是元素可以按插入顺序或访问顺序排列；与HashMap相比，因为LinkedHashMap是继承自HashMap，因此LinkedHashMap：</p>
<ul>
<li>同样是基于散列表实现。</li>
<li>同时实现了Serializable 和 Cloneable接口，支持序列化和克隆。</li>
<li>并且同样不是线程安全的。</li>
</ul>
<p>区别是其内部维护了一个双向循环链表，该链表是有序的，可以按元素插入顺序或元素最近访问顺序(LRU)排列。</p>
<h4 id="linkedhashmap源码分析">LinkedHashMap源码分析</h4>
<ul>
<li>
<p>由于LinkedHashMap继承自HashMap，所以它不仅像HashMap那样对其进行基于哈希表和单链表的Entry数组+ next链表的存储方式，而且还结合了LinkedList的优点，为每个Entry节点增加了前驱和后继，并增加了一个为header头结点，构造了一个双向循环链表。<strong>（多一个以header为头结点的双向循环链表，也就是说，每次put进来KV，除了将其保存到对哈希表中的对应位置外，还要将其插入到双向循环链表的尾部。）</strong></p>
</li>
<li>
<p>LinkedHashMap的属性比HashMap多了一个accessOrder属性。<strong>当它false时，表示双向链表中的元素按照Entry插入LinkedHashMap到中的先后顺序排序</strong>，即每次put到LinkedHashMap中的Entry都放在双向链表的尾部，这样遍历双向链表时，Entry的输出顺序便和插入的顺序一致，这也是默认的双向链表的存储顺序；<strong>当它为true时，表示双向链表中的元素按照访问的先后顺序排列</strong>，可以看到，虽然Entry插入链表的顺序依然是按照其put到LinkedHashMap中的顺序，但put和get方法均有调用recordAccess方法（put方法在key相同，覆盖原有的Entry的情况下调用recordAccess方法），该方法判断accessOrder是否为true，如果是，则将当前访问的Entry（put进来的Entry或get出来的Entry）移到双向链表的尾部（key不相同时，put新Entry时，会调用addEntry，它会调用creatEntry，该方法同样将新插入的元素放入到双向链表的尾部，既符合插入的先后顺序，又符合访问的先后顺序，因为这时该Entry也被访问了），否则，什么也不做。</p>
</li>
<li>
<p>构造函数中有设置accessOrder的方法，如果我们需要实现LRU算法时，就需要将accessOrder的值设定为TRUE。</p>
</li>
<li>
<p>在HashMap的put方法中，如果key不为null时且哈希表中已经在存在时，循环遍历table[i]中的链表时会调用recordAccess方法，而在HashMap中这个方法是个空方法，在LinkedHashMap中则实现了该方法，该方法会判断accessOrder是否为true，如果为true，它会将当前访问的Entry（在这里指put进来的Entry）移动到双向循环链表的尾部，从而实现双向链表中的元素按照访问顺序来排序（最近访问的Entry放到链表的最后，这样多次下来，前面就是最近没有被访问的元素，在实现、LRU算法时，当双向链表中的节点数达到最大值时，将前面的元素删去即可，因为前面的元素是最近最少使用的），否则什么也不做。</p>
</li>
</ul>
<h1 id="自定义类型的集合进行排序">自定义类型的集合进行排序</h1>
<h2 id="实现comparable接口">实现comparable接口</h2>
<pre><code class="language-java">public class SortTest1 {
    public static void main(String[] args) {
        List &lt;Person&gt; personList = new ArrayList&lt;&gt;();
        personList.add(new Person(&quot;a&quot;, 15));
        personList.add(new Person(&quot;b&quot;, 11));
        personList.add(new Person(&quot;c&quot;, 18));
        personList.add(new Person(&quot;d&quot;, 10));
        Collections.sort(personList);
        System.out.println(personList);
    }

    static class Person implements Comparable&lt;Person&gt;{
        String name;
        int age;

        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }

        @Override
        public String toString() {
            return &quot;Person{&quot; +
                    &quot;name='&quot; + name + '\'' +
                    &quot;, age=&quot; + age +
                    '}';
        }

        @Override
        public int compareTo(Person o) {
            return this.age - o.age;
        }
    }
}
</code></pre>
<h2 id="实现comparator比较器">实现comparator比较器</h2>
<pre><code class="language-java">public class SortTest2 {
    public static void main(String[] args) {
        List &lt;Person&gt; personList = new ArrayList&lt;&gt;();
        personList.add(new Person(&quot;a&quot;, 15));
        personList.add(new Person(&quot;b&quot;, 11));
        personList.add(new Person(&quot;c&quot;, 18));
        personList.add(new Person(&quot;d&quot;, 10));
        Collections.sort(personList);
        System.out.println(personList);
    }

    static class Person implements Comparable&lt;Person&gt;{
        String name;
        int age;

        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }

        @Override
        public String toString() {
            return &quot;Person{&quot; +
                    &quot;name='&quot; + name + '\'' +
                    &quot;, age=&quot; + age +
                    '}';
        }

        @Override
        public int compareTo(Person o) {
            return this.age - o.age;
        }
    }
}
</code></pre>
<h2 id="在treeset中的一些排序和方法异常">在TreeSet中的一些排序和方法异常</h2>
<h3 id="一创建自定义treeset时出错">一.创建自定义TreeSet时出错</h3>
<pre><code class="language-java">public class TreeSetTest {
    public static void main(String[] args) {
        TreeSet&lt;Computer&gt; computers = new TreeSet&lt;&gt;();
        computers.add(new Computer(&quot;Asus&quot;,5800,8));
        computers.add(new Computer(&quot;Lenovo&quot;,4800,16));
        computers.add(new Computer(&quot;Dell&quot;,3800,8));
        computers.add(new Computer(&quot;Mac&quot;,15800,16));
        System.out.println(computers);
    }

    static class Computer {
        String brand;        //品牌
        int price;            //价格
        int memorySize;    //内存大小

        public Computer(String brand, int price, int memorySize) {
            super();
            this.brand = brand;
            this.price = price;
            this.memorySize = memorySize;
        }

        @Override
        public String toString() {
            return &quot;Computer{&quot; +
                    &quot;brand='&quot; + brand + '\'' +
                    &quot;, price=&quot; + price +
                    &quot;, memorySize=&quot; + memorySize +
                    '}';
        }
    }
}

</code></pre>
<p>这个程序我们运行的时候会报错，因为TreeSet是可排序的，我们的自定义类必须是可排序的，所以</p>
<p>我们要么指定Comparator比较器，要么类实现Comparable接口。</p>
<p>所以我们应该在改为：</p>
<pre><code class="language-java">public class TreeSetTest {
    public static void main(String[] args) {
      //在定义的时候加上Comparator比较器
        TreeSet&lt;Computer&gt; computers = new TreeSet&lt;&gt;(new Comparator&lt;Computer&gt;() {
            @Override
            public int compare(Computer o1, Computer o2) {
                return o1.price - o2.price;
            }
        });
        computers.add(new Computer(&quot;Asus&quot;, 5800, 8));
        computers.add(new Computer(&quot;Lenovo&quot;, 4800, 16));
        computers.add(new Computer(&quot;Dell&quot;, 3800, 8));
        computers.add(new Computer(&quot;Mac&quot;, 15800, 16));
        System.out.println(computers);
    }

    static class Computer {
        String brand;        //品牌
        int price;            //价格
        int memorySize;    //内存大小

        public Computer(String brand, int price, int memorySize) {
            super();
            this.brand = brand;
            this.price = price;
            this.memorySize = memorySize;
        }

        @Override
        public String toString() {
            return &quot;Computer{&quot; +
                    &quot;brand='&quot; + brand + '\'' +
                    &quot;, price=&quot; + price +
                    &quot;, memorySize=&quot; + memorySize +
                    '}';
        }
    }
}

</code></pre>
<p>###二.指定比较器后添加失败，删除方法异常。</p>
<p>如果我们在main方法中，添加一个和比较器的比较对象比较值一样的对象默认为一个对象，不会执行该对象。</p>
<pre><code class="language-java">public static void main(String[] args) {
    TreeSet&lt;Computer&gt; computers = new TreeSet&lt;&gt;(new Comparator&lt;Computer&gt;() {
        @Override
        public int compare(Computer o1, Computer o2) {
            return o1.price - o2.price;
        }
    });
    computers.add(new Computer(&quot;Asus&quot;, 5800, 8));
    computers.add(new Computer(&quot;Lenovo&quot;, 4800, 16));
    computers.add(new Computer(&quot;Dell&quot;, 3800, 8));
    computers.add(new Computer(&quot;Mac&quot;, 15800, 16));
    System.out.println(computers);
  //[Computer{brand='Dell', price=3800, memorySize=8}, Computer{brand='Lenovo', price=4800, memorySize=16}, Computer{brand='Asus', price=5800, memorySize=8}, Computer{brand='Mac', price=15800, memorySize=16}]
    computers.add((new Computer(&quot;Acer&quot;,5800,8)));
    System.out.println(computers);
  //[Computer{brand='Dell', price=3800, memorySize=8}, Computer{brand='Lenovo', price=4800, memorySize=16}, Computer{brand='Asus', price=5800, memorySize=8}, Computer{brand='Mac', price=15800, memorySize=16}]
}
</code></pre>
<p><strong>而如果我们删除一个品牌为小米，price为5800，内存为8的对象时，他会删除价格为5800的华硕电脑。</strong></p>
<p><strong>因为TreeSet执行ComparaTo方法，返回值如果为0，那么它会认为这两个对象是同一对象。如该程序中，华硕电脑和小米电脑一样的价格，它执行比较器返回0，就会认为是同一对象</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kohath' Blog]]></title>
        <id>https://stormga.github.io/post/hello-gridea/</id>
        <link href="https://stormga.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎来到 <strong>我的博客</strong> ！<br>
✍️ 用它来记录我的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎来到 <strong>我的博客</strong> ！<br>
✍️ 用它来记录我的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/stormGa">Github</a><br>
<a href="https://stormga.github.io/">Blog 主页</a></p>
]]></content>
    </entry>
</feed>