<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://stormga.github.io/</id>
    <title>Kohath</title>
    <updated>2020-03-09T11:17:08.804Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://stormga.github.io/"/>
    <link rel="self" href="https://stormga.github.io/atom.xml"/>
    <subtitle>Every 🐦 has an 🦅&apos;s dream.</subtitle>
    <logo>https://stormga.github.io/images/avatar.png</logo>
    <icon>https://stormga.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Kohath</rights>
    <entry>
        <title type="html"><![CDATA[大型网站技术架构]]></title>
        <id>https://stormga.github.io/post/book-01/</id>
        <link href="https://stormga.github.io/post/book-01/">
        </link>
        <updated>2020-03-09T11:01:21.000Z</updated>
        <summary type="html"><![CDATA[<p>最近在读《大型网站技术架构》，文章广度很大，对于我这种初步建立起网站架构体系的人无疑是一个形成体系结构的机会。本文对该书重要知识做一个总结，供自己经常翻阅.</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近在读《大型网站技术架构》，文章广度很大，对于我这种初步建立起网站架构体系的人无疑是一个形成体系结构的机会。本文对该书重要知识做一个总结，供自己经常翻阅.</p>
<!-- more -->
<h1 id="大型网站进化史">大型网站进化史</h1>
<h2 id="大型网站软件系统的特点">大型网站软件系统的特点</h2>
<ul>
<li>高并发、大流量</li>
<li>高可用。7*24小时不断的服务</li>
<li>海量数据</li>
<li>用户分布广发、网络情况复杂。用户分布广，各地的网络情况千差万别，再过国内各个运营商之间的网络互通问题</li>
<li>安全环境恶劣</li>
<li>需求快速变更，发布频繁</li>
<li>渐进式发展。也就是 随着网络发展逐渐变化的。</li>
</ul>
<h2 id="初级网站架构">初级网站架构</h2>
<p>初始阶段的网站访问人数比较少，所有的在一台服务器。</p>
<figure data-type="image" tabindex="1"><img src="https://stormga.github.io//post-images/1089769-20180422153541801-2019951891.png" alt="" loading="lazy"></figure>
<h2 id="应用服务和数据服务分离">应用服务和数据服务分离</h2>
<figure data-type="image" tabindex="2"><img src="https://stormga.github.io//post-images/1089769-20180422153949952-969765602.png" alt="" loading="lazy"></figure>
<p>随着业务的发展，就会发现一台服务器抗不过来了，所以将应用服务器与数据（文件、数据库）服务器分离。三台服务器对硬件资源的要求各不相同：应用服务器需要更快的CPU，文件服务器需要更大的磁盘和带宽，数据库服务器需要更快速的磁盘和更大的内存。分离之后，三个服务器各司其职，也方便针对性的优化。</p>
<h2 id="使用缓存改善网站性能">使用缓存改善网站性能</h2>
<figure data-type="image" tabindex="3"><img src="https://stormga.github.io//post-images/1089769-20180422154411541-1804654037.png" alt="" loading="lazy"></figure>
<p>“世界上没有什么问题是加一级缓存解决不了的，如果有那就再加一级缓存”</p>
<p>缓存的使用无处不在，缓存的根本目的是加快访问速度。当数据库的访问压力过大的时候，就可以考虑使用缓存了。网站使用的缓存可以分为两种: 缓存在应用服务器上的本地缓存和缓存在专门的分布式缓存服务器上的远程缓存。</p>
<h2 id="使用应用服务器集群改善网站的并发处理能力">使用应用服务器集群改善网站的并发处理能力</h2>
<figure data-type="image" tabindex="4"><img src="https://stormga.github.io//post-images/1089769-20180422154734552-838306655.png" alt="" loading="lazy"></figure>
<p></p>
<p>随着业务的发展，单个应用服务器一定会成为瓶颈，应用服务器实现集群是网站可伸缩集群架构设计中较为简单成熟的一种。后面也会提到，将应用服务器设计为无状态的（没有需要保存的上下文信息），就可以通过增加机器，使用负载均衡来scale out。</p>
<h2 id="数据库读写分离">数据库读写分离</h2>
<figure data-type="image" tabindex="5"><img src="https://stormga.github.io//post-images/1089769-20180422154958394-621428384.png" alt="" loading="lazy"></figure>
<p>即使使用了缓存，但在缓存未命中、或者缓存服务时效的情况下，还是需要访问数据库，这个时候就需要数据库的读写分离：主库提供写操作，从库提供读服务。注意，在上图中增加了一个数据访问模块，可以对应用层透明数据库的主从分离信息。</p>
<h2 id="使用反向代理和cdn-加速网站晌应">使用反向代理和CDN 加速网站晌应</h2>
<figure data-type="image" tabindex="6"><img src="https://stormga.github.io//post-images/1089769-20180422155322032-1195590504.png" alt="" loading="lazy"></figure>
<p>CDN和反向代理其实都是缓存，区别在于CDN 部署在网络提供商的机房；而反向代理则部署在网站的中心机房。使用CDN 和反向代理的目的都是尽旱返回数据给用户， 一方面加快用户访问速度，另一方面也减轻后端服务器的负载压力。</p>
<h2 id="使用分布式文件系统和分布式数据库系统">使用分布式文件系统和分布式数据库系统</h2>
<figure data-type="image" tabindex="7"><img src="https://stormga.github.io//post-images/1089769-20180422155540571-959599459.png" alt="" loading="lazy"></figure>
<p>单个物理机的磁盘是有限的，单个关系数据库的处理能力也是有上限的，所以需要分布式文件存储与分布式数据库。当然，也需要”统一数据访问模块“，使得应用层不用关心文件、数据的具体位置。值得一提的事，关系型数据库自身并没有很好的水平扩展方案，因此一般都需要一个数据库代理层，如mycat。</p>
<h2 id="使用nosql-和搜索引擎">使用NoSQL 和搜索引擎</h2>
<figure data-type="image" tabindex="8"><img src="https://stormga.github.io//post-images/1089769-20180422160052062-334394168.png" alt="" loading="lazy"></figure>
<p>web2.0的很多应用并一定适合用关系数据库存储，更加灵活的NoSql能更加方便的解决一些问题，而且NoSQL天然就支持分布式。专门的搜索引擎在提供更优质服务的同时，也大大减轻了数据库的压力。</p>
<h2 id="业务拆分">业务拆分</h2>
<p><img src="https://stormga.github.io//post-images/1089769-20180422160336085-10854169.png" alt="" loading="lazy">”</p>
<p>将一个网站拆分成许多不同的应用， 每个应用独立部署维护。应用之间可以通过一个超链接建立关系(在首页上的导航链接每个都指向不同的应用地址) ，也可以通过消息队列进行数据分发， 当然最多的还是通过访问同一个数据存储系统来构成一个关联的完整系统</p>
<h2 id="分布式服务">分布式服务</h2>
<figure data-type="image" tabindex="9"><img src="https://stormga.github.io//post-images/1089769-20180422160547076-1416732001.png" alt="" loading="lazy"></figure>
<p>既然每一个应用系统都需要执行许多相同的业务操作， 比如用户管理、商品管理等，那么可以<strong>将这些共用的业务提取出来，独立部署</strong>。</p>
<p>通过服务的分布式，各个应用能更好的独立发展，实现了<strong>从依赖模块到依赖服务的过渡</strong>。将通用的公共服务独立出来，也方便做服务管控，比如对各个应用的服务请求进行监控，在高峰时期限制、关闭某些应用的访问等</p>
<h1 id="大型网站架构模式">大型网站架构模式</h1>
<p>文中说：“<strong>每个模式描述了一个在我们周围不断重复发生的问题以及该问题解决方案的核心，这样就能一次又一次的使用这个方案不必做重复工作</strong>”。模式的关键在于模式的可重复性， 问题与场景的可重复性带来解决方案的可重复使用。</p>
<h2 id="分层">分层</h2>
<p>将网站软件系统分为应用层，服务层，数据层。</p>
<p>分层的好处在于：解耦合，独立发展，伸缩性，可扩展性。</p>
<p>但是分层架构也有一些挑战， 就是<strong>必须合理规划层次边界和接口</strong>，在开发过程中，严格遵循分层架构的约束， 禁止跨层次的调用( 应用层直接调用数据层)及逆向调用(数据层调用服务层， 或者服务层调用应用层)。</p>
<p>分层后的各个模块可以部署在同一个物理机器上。分层最初是为了规划软件清晰的逻辑结构便于开发，而在网站发展中，分层在支持分布式高并发时是必要的。</p>
<h2 id="分割">分割</h2>
<p>分层强调的是横向切分，而分割是纵向切分， 上面网站进化史部分的业务拆分就包含了分割。</p>
<p>分割的目标是高内聚、低耦合的模块单元。</p>
<p>比如在应用层，将购物，论坛，广告分割成不同的应用，由不同团队开发，部署在不同的服务器上。</p>
<h2 id="分布式">分布式</h2>
<p>分层和分割的一个主要目的是分布式部署，但分布式也有自己的问题：网络通信带来的性能问题，可用性，一致性与分布式事务，系统维护管理复杂度。</p>
<ul>
<li>分布式应用和服务</li>
<li>分布式静态资源</li>
<li>分布式数据和存储</li>
<li>分布式计算</li>
</ul>
<h2 id="集群">集群</h2>
<p>一个机器解决不了的问题，就用几个机器来解决，当服务无状态的时候，通过往集群增加机器就能解决大部分问题。对应网站进化史中“使用应用服务器集群改善网站的并发处理能力”</p>
<p><strong>例如网站首页，访问集中，可以多台服务器部署相同的服务构成一个集群，通过负载均衡设备共同对外服务</strong></p>
<h2 id="缓存">缓存</h2>
<p>缓存就是将数据存放在距离计算最近的位置以加快处理速度，同时大大减轻了数据提供者的压力</p>
<p>大型网站架构设计在很多方面都使用了缓存设计：<strong>CDN、反向代理、本地缓存、分布式缓存</strong></p>
<h2 id="异步">异步</h2>
<p>异步是解耦合的一个重要手段，常见的生产者-消费者模型就是一个异步模式。</p>
<p>出了解耦合，异步还能提高系统可用性、加快响应速度、流量削峰</p>
<h2 id="冗余">冗余</h2>
<p>冗余是系统可用性的重要保障，也是数据可靠性的重要手段。数据库冷备份和热备份。</p>
<h2 id="自动化">自动化</h2>
<p>凡人总是会出这样那样的错误，能自动话的就要自动化。自动化大大解放了程序员、运维人员的生产力！</p>
<p>发布过程自动化、自动化代码管理、自动化测试、自动化安全检测、自动化部署、自动化监控、自动化报警、自动化失效转移、自动化失效恢复、自动化降级。</p>
<h1 id="架构模式在新浪的应用">架构模式在新浪的应用</h1>
<ul>
<li>早起使用MPSS（单服务器多端口），每台都部署多个服务，每个服务使用不同的端口提供服务。现在常用的服务部署，一台机器虚拟成多个机器。</li>
<li>异步推拉：用户发微博后会在所有粉丝订阅中显示，这样会造成一个用户发文，会将这条微博插入到所有粉丝订阅中造成大量写操作。新浪使用异步推拉结合，用户发微博后写入消息队列后立即返回，用户响应迅速，消息队列消费者将微博推送给所有当前<strong>在线粉丝</strong>，非在线用户上线后根据关注列表拉取订阅列表。</li>
<li>由于微博更新频繁，新浪使用多级缓存，热门微博和明星用户的微博缓存在所有服务器中，在线用户的微博和近期微博在分布式缓存集群中。所以“刷微博操作全部都是缓存访问”。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot使用Redis的序列化问题]]></title>
        <id>https://stormga.github.io/post/springboot-reids-Serialization/</id>
        <link href="https://stormga.github.io/post/springboot-reids-Serialization/">
        </link>
        <updated>2020-03-09T10:51:13.000Z</updated>
        <summary type="html"><![CDATA[<p>redis作为互联网中重要的加速组件，在系统中扮演着重要的角色，在使用springboot整合redis的时候踩坑纪记录。</p>
]]></summary>
        <content type="html"><![CDATA[<p>redis作为互联网中重要的加速组件，在系统中扮演着重要的角色，在使用springboot整合redis的时候踩坑纪记录。</p>
<!-- more -->
<h1 id="redis简介">Redis简介</h1>
<ul>
<li>redis是一种运行在内存的数据库，支持7种数据类型存储。</li>
<li>redis开源，使用ANSI C语言编写，遵守BSD协议，支持网络，可以存储在内存，也支持数据持久化的日执行，键值对型数据库，提供了多种语言的api</li>
<li>按照官网文档，redis支持1s内10万次的读写。</li>
<li>Redis在2.6版本增加了Lua语言的支持，而且redis在Lua语言下 的执行是原子性的，也就是不被其他命令打断。这样我们保证在高并发场景下的一致性。</li>
</ul>
<h2 id="redis在springboot-的pom文件中的配置">redis在springboot 的pom文件中的配置</h2>
<pre><code class="language-xml">&lt;!-- redis依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;io.lettuce&lt;/groupId&gt;
            &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;

&lt;!-- redis的客户端jedis --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;redis.clients&lt;/groupId&gt;
    &lt;artifactId&gt;jedis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>spring-boot-starter-data-redis默认会启动Lettuce作为redis客户端驱动，但是一般我们会用jedis，所以在这里使用exclusion排除。</li>
</ul>
<h1 id="spring-data-redis的设计">Spring-data-redis的设计</h1>
<ul>
<li>
<p>Spring 提供了一个RedisConnectionFactory接口</p>
</li>
<li>
<p>通过RedisConnectionFactory接口可以生成一个RedisConnection接口对象</p>
</li>
<li>
<p>RedisConnection接口对象就是对redis底层的封装</p>
</li>
<li>
<p>如果我们要操作redis，我们需要先从工厂获得连接，然后使用后在关闭他，spring 为了简化开发提供了RedisTemplate去从RedisConnectionFactory工厂获取连接，然后执行redis命令，关闭连接。</p>
</li>
</ul>
<h2 id="解决序列化问题">解决序列化问题</h2>
<ul>
<li>我们需要知道redis是基于字符串存储的NoSQL，而Java是基于对象存储的。对象是无法存储到redis中的。</li>
<li>Java提供了序列化机制，只要类实现了java.io.Serializable接口，这样就能将对象转化为二进制字符串，这样redis就能将对象以字符串存储。</li>
<li>Spring提供了序列化机制。</li>
<li><strong>在默认情况下会使用JdkSerializationRedisSerializer对对象进行序列化和反序列化，但这样会得到复杂的字符串，不利用我们使用redis。</strong></li>
</ul>
<h3 id="解决方法">解决方法</h3>
<ul>
<li>在springboot的启动文件中修改RedisTemplate序列化器</li>
</ul>
<pre><code class="language-java">@Autowired
private RedisTemplate redisTemplate = null;


//定义自定义后初始化方法
@PostConstruct
public void init(){
    initRedisTemplate();
}

private void initRedisTemplate(){
    RedisSerializer stringSerializable = redisTemplate.getStringSerializer();
    redisTemplate.setKeySerializer(stringSerializable);
    redisTemplate.setHashKeySerializer(stringSerializable);

}
</code></pre>
<ul>
<li>首先优@AutoWired注入由springboot配置生成的RedisTemplate，然后利用spring bean的生命周期特性使用@PostConstruct自定义初始化方法。</li>
<li>在这个初始化方法里，把redisTemplate中的键序列化器修改为StringRedisSerializer对象</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot（二）]]></title>
        <id>https://stormga.github.io/post/springboot-note2/</id>
        <link href="https://stormga.github.io/post/springboot-note2/">
        </link>
        <updated>2020-03-09T10:47:49.000Z</updated>
        <summary type="html"><![CDATA[<p>本文继续介绍SpringBoot的使用：SpringBoot下的SpringMVC，SpringBoot集成MyBatis，SpringBoot实现restful,SpringBoot热部署插件，SpringBoot集成Redis。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本文继续介绍SpringBoot的使用：SpringBoot下的SpringMVC，SpringBoot集成MyBatis，SpringBoot实现restful,SpringBoot热部署插件，SpringBoot集成Redis。</p>
<!-- more -->
<h1 id="springboot下的springmvc">SpringBoot下的SpringMVC</h1>
<h2 id="restcontroller">@RestController</h2>
<ul>
<li>这个注解的作用就是Controller + ResponseBody</li>
<li>所有方法的返回值都是json</li>
</ul>
<pre><code class="language-java">@RestController
public class UserController {

    @RequestMapping(&quot;/boot/getUser&quot;)
    public Object getUser(){
        User user = new User();
        user.setId(&quot;1&quot;);
        user.setAge(&quot;12&quot;);
        user.setName(&quot;zs&quot;);
        return user;
    }
}
</code></pre>
<h2 id="getmapping">@GetMapping</h2>
<h2 id="postmapping">@PostMapping</h2>
<h2 id="putmapping">@PutMapping</h2>
<h2 id="deletemapping">@DeleteMapping</h2>
<h1 id="springboot集成mybatis">SpringBoot集成MyBatis</h1>
<h2 id="添加依赖">添加依赖</h2>
<pre><code class="language-xml">&lt;!-- Tomcat对jsp的依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;
    &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;!-- Tomcat对servlet的依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;!-- jsp的依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
    &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt;
    &lt;version&gt;2.3.1&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- jstl依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;jstl&lt;/artifactId&gt;
&lt;/dependency&gt;


&lt;!-- 添加Myatis依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.3.1&lt;/version&gt;
&lt;/dependency&gt;


&lt;!-- 添加Mysql-jdbc依赖--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="applicationproperties中配置数据库信息">application.properties中配置数据库信息</h2>
<pre><code class="language-properties"># 配置mybatis的mapper.xml文件
mybatis.mapper-locations=classpath:cn/lkhcoding/springboot/mapper/*.xml


# 数据库连接信息
spring.datasource.url=jdbc:MySQL://localhost:3306/springboot_chapter
spring.datasource.username=root
spring.datasource.password=root
</code></pre>
<h2 id="在mapper接口上添加mapper注解或者在运行主类添加mapperscanxxxxxx注解包扫描">在mapper接口上添加@Mapper注解或者在运行主类添加@MapperScan(&quot;xx.xx.xx&quot;)注解包扫描</h2>
<ul>
<li>UserMapper.java</li>
</ul>
<pre><code class="language-java">@Mapper
public interface UserMapper {

    /**
     * 根据id获取信息
     * @return
     */
    User getUser(int id);
}
</code></pre>
<ul>
<li>
<p>UserMapper.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
  PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
  &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
  
&lt;mapper namespace=&quot;cn.lkhcoding.springboot.mapper.UserMapper&quot;&gt;
   &lt;select id=&quot;getUser&quot; resultType=&quot;cn.lkhcoding.springboot.model.User&quot;&gt;
      SELECT id,name,age FROM user WHERE id=#{id}
   &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
</li>
</ul>
<h2 id="在pom中添加">在POM中添加</h2>
<pre><code class="language-xml">&lt;resources&gt;
    &lt;resource&gt;
        &lt;directory&gt;src/main/java&lt;/directory&gt;
        &lt;includes&gt;
            &lt;include&gt;**/*.xml&lt;/include&gt;
        &lt;/includes&gt;
    &lt;/resource&gt;
    &lt;resource&gt;
        &lt;directory&gt;src/main/resources&lt;/directory&gt;
        &lt;includes&gt;
            &lt;include&gt;**/*.*&lt;/include&gt;
        &lt;/includes&gt;
    &lt;/resource&gt;
    &lt;resource&gt;
        &lt;directory&gt;src/main/webapp&lt;/directory&gt;
        &lt;targetPath&gt;META-INF/resources&lt;/targetPath&gt;
        &lt;includes&gt;
            &lt;include&gt;**/*.*&lt;/include&gt;
        &lt;/includes&gt;
    &lt;/resource&gt;
&lt;/resources&gt;
</code></pre>
<h2 id="使用controller访问">使用Controller访问</h2>
<pre><code class="language-java">@Autowired
private UserService userService;

@RequestMapping(&quot;/boot/getUserFromMysql&quot;)
public  User getUser(int id) {
    return userService.getUser(id);
}
</code></pre>
<p>#SpringBoot实现restful</p>
<h2 id="使用pathvariable">使用@PathVariable</h2>
<ul>
<li>
<p>获取url的数据</p>
</li>
<li>
<p>该注解是实现RESTFull最重要的一个注解</p>
<pre><code class="language-java">@RequestMapping(&quot;/boot/getUserFromMysql/{id}&quot;)
public User getUser(@PathVariable(&quot;id&quot;) int id) {
    return userService.getUser(id);
}
</code></pre>
</li>
<li>
<p>访问的时候路径为:http://localhost:8080/springboot_03/boot/getUserFromMysql/1</p>
</li>
</ul>
<p>#SpringBoot热部署插件</p>
<h2 id="为什么需要热部署">为什么需要热部署</h2>
<ul>
<li>在实际开发中，我们修改代码的逻辑功能，都需要重启应用，这无形中降低了开发效率.</li>
</ul>
<h2 id="92-什么是热部署">9.2 什么是热部署</h2>
<ul>
<li>当我们修改代码的时候，服务能自动重启加载新修改的内容，这样大大提高了我们的开发效率</li>
</ul>
<h2 id="93-实现热部署">9.3 实现热部署</h2>
<h3 id="931-添加插件spring-boot-devtools">9.3.1 添加插件spring-boot-devtools</h3>
<ul>
<li>
<p>在pom文件中添加</p>
<pre><code class="language-xml">&lt;!-- spring-boot-devtools --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
    &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;
</code></pre>
</li>
</ul>
<p>#SpringBoot集成Redis</p>
<h2 id="在pom中添加jar依赖">在pom中添加jar依赖</h2>
<pre><code class="language-xml">&lt;!--  springboot  redis依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="在applicationproperties中配置redis连接信息">在application.properties中配置redis连接信息</h2>
<pre><code class="language-properties"># Redis配置
spring.redis.host=xxx.xxx.xxx.xxx
spring.redis.port=6379
spring.redis.password=xxx
</code></pre>
<h2 id="在需要操作redis的类中注入redis-template">在需要操作redis的类中注入redis Template</h2>
<ul>
<li>
<p>在需要使用类上添加</p>
<pre><code class="language-java">@Autowired
private RedisTemplate&lt;String,String&gt; redisTemplate;

@Autowired
private RedisTemplate&lt;Object,Object&gt; redisTemplate;
</code></pre>
</li>
</ul>
<h2 id="springboot集成redis哨兵模式">springboot集成redis哨兵模式</h2>
<pre><code class="language-properties">#redis哨兵配置
spring.redis.password=xx
spring.redis.sentinel.master=mymaster
spring.redis.sentinel.nodes=xxx.xxx.xxx.xxx:26380,xxx.xxx.xxx.xxx:26382.....
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot（一）]]></title>
        <id>https://stormga.github.io/post/springboot-note1/</id>
        <link href="https://stormga.github.io/post/springboot-note1/">
        </link>
        <updated>2020-03-09T10:24:41.000Z</updated>
        <summary type="html"><![CDATA[<p>本文主要介绍了：Springboot的入门程序，springboot配置文件，日志模块，web开发，docker，数据访问，启动原理，自定义starter。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本文主要介绍了：Springboot的入门程序，springboot配置文件，日志模块，web开发，docker，数据访问，启动原理，自定义starter。</p>
<!-- more -->
<h1 id="一-spring-boot入门">一、Spring Boot入门</h1>
<h2 id="1-spring-boot简介">1、Spring Boot简介</h2>
<p>Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。</p>
<h2 id="2-微服务">2、微服务</h2>
<p>微服务：架构风格（服务微化）</p>
<p>一个应用应该是一组小型服务，可以通过HTTP的方式进行互通</p>
<p>单体应用：ALL IN ONE</p>
<p>微服务：每个功能元素最终都是一个可以独立替换和升级的软件单元</p>
<h2 id="3-环境准备">3、环境准备</h2>
<p>环境约束</p>
<ul>
<li>jdk1.8</li>
<li>maven 3.x :maven3.3以上</li>
<li>IDEA2017</li>
<li>SpringBoot 1.5.9RELEASE</li>
</ul>
<h3 id="1-maven设置">1、MAVEN设置</h3>
<pre><code class="language-xml">&lt;!-- 配置JDK版本 --&gt;
&lt;profile&gt;    
    &lt;id&gt;jdk18&lt;/id&gt;    
    &lt;activation&gt;    
        &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;    
        &lt;jdk&gt;1.8&lt;/jdk&gt;    
    &lt;/activation&gt;    
    &lt;properties&gt;    
        &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;    
        &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;    
        &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt;    
    &lt;/properties&gt;     
&lt;/profile&gt;
   &lt;!-- 当 nexus-aliyun 下不了的包，或许这个镜像能下，
        才开放它，这个实在太慢，而且要把它放在首位，即 nexus-aliyun 之前，做过测试。
        所以它的用途只有那么一瞬间，就是或许它能下载，可以通过 url 去查找确定一下
    --&gt;
    &lt;!-- &lt;mirror&gt;
        &lt;id&gt;spring-libs-milestone&lt;/id&gt;
        &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;
        &lt;name&gt;Spring Milestones&lt;/name&gt;
        &lt;url&gt;http://repo.spring.io/libs-milestone&lt;/url&gt;
    &lt;/mirror&gt; --&gt;

    &lt;!-- nexus-aliyun 首选，放第一位,有不能下载的包，再去做其他镜像的选择  --&gt;
    &lt;mirror&gt;
        &lt;id&gt;nexus-aliyun&lt;/id&gt;
        &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;
        &lt;name&gt;Nexus aliyun&lt;/name&gt;
        &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;
    &lt;/mirror&gt;

    &lt;!-- 备选镜像，也是可以通过 url 去查找确定一下，
        该镜像是否含有你想要的包，它比 spring-libs-milestone 快  --&gt;
    &lt;mirror&gt;
        &lt;id&gt;central-repository&lt;/id&gt;
        &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;
        typor&lt;name&gt;Central Repository&lt;/name&gt;
        &lt;url&gt;http://central.maven.org/maven2/&lt;/url&gt;
    &lt;/mirror&gt;  
</code></pre>
<h3 id="2-idea设置">2、IDEA设置</h3>
<p>​    配置IDEA的Maven，指定Setting的Maven目录和MAVEN的setting.xml文件</p>
<p>​	快捷键：</p>
<p>​	Ctrl+D 复制一行</p>
<p>​	Ctrl+Y 删除一行</p>
<p>​	Ctrl+P 参数提示</p>
<p>​	Ctrl+Alt+V 自动补齐方法</p>
<p>​	Ctrl+N 查找类方法</p>
<p>​	Alt+Ins 构造器、getter/setter toString</p>
<p>​	Ctrl+O 重载方法提示</p>
<p>​	Alt+Enter 提示导入类etc</p>
<p>​	Shift+F6 :文件重命名</p>
<h2 id="4-spring-boot的hello-world">4、Spring Boot的Hello World</h2>
<h3 id="1-创建一个maven工程">1、创建一个Maven工程</h3>
<h3 id="2-导入spring-boot的相关依赖">2、导入Spring Boot的相关依赖</h3>
<pre><code class="language-xml">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;
    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
&lt;/parent&gt;

&lt;properties&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
    &lt;java.version&gt;1.8&lt;/java.version&gt;
&lt;/properties&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

</code></pre>
<h3 id="3-编写个主程序">3、编写个主程序</h3>
<pre><code class="language-java">@SpringBootApplication
public class SpringBoot01HelloQuickApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringBoot01HelloQuickApplication.class, args);
    }
}
</code></pre>
<h3 id="4-编写相应的controller和service">4、编写相应的Controller和Service</h3>
<pre><code class="language-java">@Controller
public class HelloController {

    @ResponseBody
    @RequestMapping(&quot;/hello&quot;)
    public  String  hello(){
        return &quot;hello world&quot;;
    }
}
</code></pre>
<h3 id="5-运行主程序测试">5、运行主程序测试</h3>
<p>访问 localhost:8080/hello</p>
<h3 id="6-简化部署">6、简化部署</h3>
<p>在pom.xml文件中，导入build插件</p>
<pre><code class="language-xml">&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<h2 id="5-helloworld深度理解">5、HelloWorld深度理解</h2>
<h3 id="1pomxml文件">1.POM.xml文件</h3>
<h4 id="1-父项目">1、父项目</h4>
<pre><code class="language-xml">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;
    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
&lt;/parent&gt;
</code></pre>
<p>这个父项目<strong>spring-boot-starter-parent</strong>又依赖一个父项目</p>
<pre><code class="language-xml">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;
    &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;
    &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;
&lt;/parent&gt;
</code></pre>
<p>下面有个属性，定义了对应的版本号</p>
<pre><code class="language-xml">&lt;properties&gt;
    &lt;activemq.version&gt;5.15.3&lt;/activemq.version&gt;
    &lt;antlr2.version&gt;2.7.7&lt;/antlr2.version&gt;
    &lt;appengine-sdk.version&gt;1.9.63&lt;/appengine-sdk.version&gt;
    &lt;artemis.version&gt;2.4.0&lt;/artemis.version&gt;
    &lt;aspectj.version&gt;1.8.13&lt;/aspectj.version&gt;
    &lt;assertj.version&gt;3.9.1&lt;/assertj.version&gt;
    &lt;atomikos.version&gt;4.0.6&lt;/atomikos.version&gt;
    &lt;bitronix.version&gt;2.1.4&lt;/bitronix.version&gt;
    &lt;build-helper-maven-plugin.version&gt;3.0.0&lt;/build-helper-maven-plugin.version&gt;
    。。。。。。。
</code></pre>
<p>Spring Boot的版本仲裁中心 会自动导入对应的版本，不需要我们自己导入依赖，没有dependencies里面管理的依赖自己声明</p>
<h4 id="2-启动器">2、启动器</h4>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;

</code></pre>
<p>**spring-boot-starter-web:**帮我们导入web模块正常运行所依赖的组件</p>
<p><strong>spring boot</strong>将所有的功能场景都抽取出来，做成一个个的starter(启动器)，只需要在项目里引入这些starter相关场景的所有依赖都会被导入进来，要用什么功能就导入什么场景的启动器。</p>
<h3 id="2-主程序入口">2、主程序入口</h3>
<pre><code class="language-java">@SpringBootApplication
public class SpringBoot01HelloQuickApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringBoot01HelloQuickApplication.class, args);
    }
}

</code></pre>
<p><strong>@SpringBootApplication:</strong> 说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动应用</p>
<p>进入SpringBootApplication注解</p>
<pre><code class="language-java">@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(
    excludeFilters = {@Filter(
    type = FilterType.CUSTOM,
    classes = {TypeExcludeFilter.class}
), @Filter(
    type = FilterType.CUSTOM,
    classes = {AutoConfigurationExcludeFilter.class}
)}
)
public @interface SpringBootApplication {

</code></pre>
<p><strong>@SpringBootConfiguration</strong>：SpringBoot的配置类： 标准在某个类上，表示这是一个SpringBoot的配置类</p>
<p><strong>@Configuration</strong>:配置类上，来标注这个注解；<br>
配置类 ---- 配置文件，也是容器中的一个组件（@Component）<br>
<strong>@EnableAutoConfiguration</strong>:开启自动配置功能<br>
以前需要自动配置的东西，Spring Boot帮我们自动配置；@EnableAutoConfiguration告诉SpringBoot开启自动<br>
配置功能；这样自动配置才能生效。</p>
<pre><code class="language-java">@AutoConfigurationPackage
@Import({AutoConfigurationImportSelector.class})
public @interface EnableAutoConfiguration { 

</code></pre>
<p><strong>@AutoConfigurationPackage</strong>:自动配置包<br>
<strong>@Import({Registrar.class})</strong>：底层注解，给容器导入组件；<br>
将主配置类（@SpringBootApplication标注的类）的所在包及下面所有的子包里面的所有组件扫描到Spring容器；</p>
<p><strong>@Import({AutoConfigurationImportSelector.class})：</strong><br>
给容器导入组件？</p>
<p>AutoConfigurationImportSelector：导入组件选择器</p>
<p>将所有需要导入的组件以及全类名的方式返回；这些组件将以字符串数组 String[] 添加到容器中；</p>
<p>会给容器非常多的自动配置类，（xxxAutoConfiguration）;就是给容器中导入这个场景需要的所有组件，并配置<br>
好这些组件。</p>
<figure data-type="image" tabindex="1"><img src="https://stormga.github.io//post-images/1.configuration.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-java">protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata,
AnnotationAttributes attributes) {
	List&lt;String&gt; configurations =
SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(),
this.getBeanClassLoader());
	Assert.notEmpty(configurations, &quot;No auto configuration classes found in META‐INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;);
	return configurations;
} 

</code></pre>
<p><code>SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(),</code><br>
<code>this.getBeanClassLoader());</code></p>
<p>Spring Boot在启动的时候从类路径下的META-INF/spring.factorys中获取的EnableAutoConfiguration指定的值；</p>
<p>将这些值作为自动配置类导入到容器中，自动配置就生效了。 <img src="https://stormga.github.io//post-images/2.factories.jpg" alt="" loading="lazy"></p>
<p>J2EE的整体解决方案</p>
<p>org\springframework\boot\spring-boot-autoconfigure\2.0.1.RELEASE\spring-boot-autoconfigure-2.0.1.RELEASE.jar</p>
<h2 id="6-使用spring-initializer创建一个快速向导">6、使用Spring Initializer创建一个快速向导</h2>
<p>1.IDE支持使用Spring Initializer</p>
<p>自己选择需要的组件:例如web</p>
<p>默认生成的SpringBoot项目</p>
<ul>
<li>
<p>主程序已经生成好了，我们只需要完成我们的逻辑</p>
</li>
<li>
<p>resources文件夹目录结构</p>
<ul>
<li>
<p>static:保存所有的静态文件；js css images</p>
</li>
<li>
<p>templates:保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat,默认不支持JSP）；可</p>
<p>以使用模板引擎（freemarker.thymeleaf）;</p>
</li>
<li>
<p>application.properties:Spring Boot的默认配置，例如 server.port=9000</p>
</li>
</ul>
</li>
</ul>
<h1 id="二-配置文件">二、配置文件</h1>
<h2 id="1-配置文件">1、配置文件</h2>
<p>Spring Boot使用全局配置文件，配置文件名是固定的；</p>
<ul>
<li>application.properties</li>
<li>application.yml</li>
</ul>
<p>配置文件作用：修改Spring Boot在底层封装好的默认值；</p>
<p>YAML（YAML AIN'T Markup Language）</p>
<p>是一个标记语言</p>
<p>又不是一个标记语言</p>
<p><strong>标记语言：</strong></p>
<p>以前的配置文件；大多数使用的是 xxx.xml文件；</p>
<p>以数据为中心，比json、xml等更适合做配置文件</p>
<p>YAML：配置例子</p>
<pre><code class="language-yaml">server:
	port: 9000 

</code></pre>
<p>XML:</p>
<pre><code class="language-xml">&lt;server&gt;
	&lt;port&gt;9000&lt;/port&gt;
&lt;/server&gt; 

</code></pre>
<h2 id="2-yaml语法">2、YAML语法</h2>
<h3 id="1-基本语法">1、基本语法</h3>
<p>k:(空格)v:表示一堆键值对（空格必须有）；</p>
<p>以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一层级的</p>
<pre><code class="language-yaml">server:
	port: 9000
	path: /hello 

</code></pre>
<p>属性和值也是大小写敏感</p>
<h3 id="2-值的写法">2、值的写法</h3>
<p><strong>字面量：普通的值（数字，字符串，布尔）</strong></p>
<p>k: v:字面直接来写；</p>
<p>字符串默认不用加上单引号或者双引号</p>
<p>&quot;&quot;:<strong>双引号</strong> 不会转义字符串里的特殊字符；特殊字符会作为本身想要表示的意思</p>
<p><code>name:&quot;zhangsan\n lisi&quot;</code> 输出：<code>zhangsan换行 lisi</code></p>
<p>'':<strong>单引号</strong> 会转义特殊字符，特殊字符最终只是一个普通的字符串数据</p>
<p><code>name:'zhangsan\n lisi'</code> 输出：<code>zhangsan\n lisi</code></p>
<p><strong>对象、Map（属性和值）键值对</strong></p>
<p>k :v ：在下一行来写对象的属性和值的关系；注意空格控制缩进</p>
<p>对象还是k:v的方式</p>
<pre><code class="language-yaml">frends:
	lastName: zhangsan
	age: 20 

</code></pre>
<p>行内写法</p>
<pre><code class="language-yaml">friends: {lastName: zhangsan,age: 18} 

</code></pre>
<p><strong>数组（List、Set）:</strong><br>
用-表示数组中的一个元素</p>
<pre><code class="language-yaml">pets:
 ‐ cat
 ‐ dog
 ‐ pig 

</code></pre>
<p>行内写法</p>
<pre><code class="language-yaml">pets: [cat,dog,pig] 

</code></pre>
<p><strong>组合变量</strong></p>
<p>多个组合到一起</p>
<h2 id="3-配置文件值注入">3、配置文件值注入</h2>
<h3 id="1-configurationproperties">1、@ConfigurationProperties</h3>
<p>1、application.yml 配置文件</p>
<pre><code class="language-yaml">person:
  age: 18
  boss: false
  birth: 2017/12/12
  maps: {k1: v1,k2: 12}
  lists:
   - lisi
   - zhaoliu
  dog:
    name: wangwang
    age: 2
  last-name: wanghuahua

</code></pre>
<p><code>application.properties</code> 配置文件（二选一）</p>
<pre><code class="language-properties">idea配置文件utf-8
properties 默认GBK
person.age=12
person.boss=false
person.last-name=张三
person.maps.k1=v1
person.maps.k2=v2
person.lists=a,b,c
person.dog.name=wanghuahu
person.dog.age=15

</code></pre>
<p>所以中文输出乱码，改进settings--&gt;file encoding --&gt;[property--&gt;utf-8 ,勾选转成ascii]</p>
<p>javaBean</p>
<pre><code class="language-java">/**
* 将配置文件的配置每个属性的值，映射到组件中
* @ConfigurationProperties:告诉SpringBoot将文本的所有属性和配置文件中的相关配置进行绑定；
* prefix = &quot;person&quot; 配置文件爱你的那个属性进行一一映射
* *
只有这个组件是容器中的组件，才能提供到容器中
*/
@Component
@ConfigurationProperties(prefix = &quot;person&quot;)
public class Person {
    private String lastName;
    private Integer age;
    private Boolean boss;
    private Map&lt;String,Object&gt; maps;
    private List&lt;Object&gt; lists;
    private Dog dog;

</code></pre>
<p>导入配置文件处理器，以后编写配置就有提示了</p>
<pre><code class="language-xml">&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
	&lt;artifactId&gt;spring‐boot‐configuration‐processor&lt;/artifactId&gt;
	&lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt; 

</code></pre>
<h3 id="2-value注解">2、@Value注解</h3>
<p>更改javaBean中的注解</p>
<pre><code class="language-java">@Component
public class Person {
    /**
     * &lt;bean class=&quot;Person&quot;&gt;
     *     &lt;property name=&quot;lastName&quot; value=&quot;字面量/${key}从环境变量/#{spEL}&quot;&gt;&lt;/property&gt;
     * &lt;/bean&gt;
     */
    @Value(&quot;${person.last-name}&quot;)
    private String lastName;
    @Value(&quot;#{11*2}&quot;)
    private Integer age;
    @Value(&quot;true&quot;)
    private Boolean boss;

</code></pre>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">@ConfigurationProperties</th>
<th style="text-align:center">@Value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">功能</td>
<td style="text-align:center">批量注入配置文件属性</td>
<td style="text-align:center">单个指定</td>
</tr>
<tr>
<td style="text-align:center">松散绑定(语法)</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">不支持</td>
</tr>
<tr>
<td style="text-align:center">spEL</td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">支持</td>
</tr>
<tr>
<td style="text-align:center">JSR303校验</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">不支持</td>
</tr>
<tr>
<td style="text-align:center">复杂类型</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">不支持</td>
</tr>
</tbody>
</table>
<blockquote>
<p>松散语法：javaBean中last-name(或者lastName) --&gt;application.properties中的last-name;</p>
<p>spEL语法：#{11*2}</p>
<p>JSR303：@Value会直接忽略，校验规则</p>
</blockquote>
<p>JSR303校验：</p>
<pre><code class="language-java">@Component
@ConfigurationProperties(prefix = &quot;person&quot;)
@Validated
public class Person {
    @Email
    private String lastName;

</code></pre>
<p>复杂类型栗子：</p>
<pre><code class="language-java">@Component
public class Person {
    /**
     * &lt;bean class=&quot;Person&quot;&gt;
     *     &lt;property name=&quot;lastName&quot; value=&quot;字面量/${key}从环境变量/#{spEL}&quot;&gt;&lt;/property&gt;
     * &lt;/bean&gt;
     */
    private String lastName;
    private Integer age;
    private Boolean boss;
   // @Value(&quot;${person.maps}&quot;)
    private Map&lt;String,Object&gt; maps;

</code></pre>
<p>以上会报错，不支持复杂类型</p>
<p><strong>使用场景分析</strong></p>
<p>​	如果说，我们只是在某个业务逻辑中获取一下配置文件的某一项值，使用@Value；</p>
<p>如果专门编写了一个javaBean和配置文件进行映射，我们直接使用@ConfigurationProperties</p>
<p>举栗子：</p>
<p>1、编写新的Controller文件</p>
<pre><code class="language-java">@RestController
public class HelloController {

    @Value(&quot;${person.last-name}&quot;)
    private String name;
    @RequestMapping(&quot;/hello&quot;)
    public  String sayHello(){
        return &quot;Hello&quot;+ name;
    }
}

</code></pre>
<p>2、配置文件</p>
<pre><code class="language-properties">person.age=12
person.boss=false
person.last-name=李四
person.maps.k1=v1
person.maps.k2=v2
person.lists=a,b,c
person.dog.name=wanghuahu
person.dog.age=15

</code></pre>
<p>3、测试运行</p>
<p>访问 localhost:9000/hello</p>
<p>结果为<code>Hello 李四</code></p>
<h3 id="3-其他注解">3、其他注解</h3>
<p><strong>@PropertySource</strong></p>
<p>作用：加载指定的properties配置文件</p>
<p>1、新建一个person.properties文件</p>
<pre><code class="language-properties">person.age=12
person.boss=false
person.last-name=李四
person.maps.k1=v1
person.maps.k2=v2
person.lists=a,b,c
person.dog.name=wanghuahu
person.dog.age=15

</code></pre>
<p>2、在javaBean中加入@PropertySource注解</p>
<pre><code class="language-java">@PropertySource(value = {&quot;classpath:person.properties&quot;})
@Component
@ConfigurationProperties(prefix = &quot;person&quot;)
public class Person {
    private String lastName;

</code></pre>
<p><strong>@ImportResource</strong></p>
<p>作用：导入Spring配置文件，并且让这个配置文件生效</p>
<p>1、新建一个Spring的配置文件，bean.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;HelloService&quot; class=&quot;com.wdjr.springboot.service.HelloService&quot;&gt;&lt;/bean&gt;
&lt;/beans&gt;

</code></pre>
<p>2、编写测试类，检查容器是否加载Spring配置文件写的bean</p>
<pre><code class="language-java">@Autowired
ApplicationContext ioc;

@Test
public void testHelloService(){
    boolean b = ioc.containsBean(&quot;HelloService&quot;);
    System.out.println(b);
}

</code></pre>
<blockquote>
<p>import org.springframework.context.ApplicationContext;</p>
</blockquote>
<p>3、运行检测</p>
<p>结果为false，没有加载配置的内容</p>
<p>4、使用@ImportResource注解</p>
<p>将@ImportResource标注在主配置类上</p>
<pre><code class="language-java">@ImportResource(locations={&quot;classpath:beans.xml&quot;})
@SpringBootApplication
public class SpringBoot02ConfigApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringBoot02ConfigApplication.class, args);
    }
}

</code></pre>
<p>5、再次运行检测</p>
<p>结果为true</p>
<p>缺点：每次指定xml文件太麻烦</p>
<p>SpringBoot推荐给容器添加组件的方式：</p>
<p>1、配置类=====Spring的xml配置文件（old）</p>
<p>2、全注解方式@Configuration+@Bean（new）</p>
<figure data-type="image" tabindex="2"><img src="https://stormga.github.io//post-images/4.MyAppConfig.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-java">/**
 * @Configuration：指明当前类是一个配置类；就是来代替之前的Spring配置文件
 *
 * 在配置文件中用&lt;bean&gt;&lt;/bean&gt;标签添加组件
 */

@Configuration
public class MyAppConfig {

    //将方法的返回值添加到容器中；容器这个组件id就是方法名
    @Bean
    public HelloService helloService01(){
        System.out.println(&quot;配置类给容器添加了HelloService组件&quot;);
        return new HelloService();
    }
}

</code></pre>
<pre><code class="language-java">@Autowired
ApplicationContext ioc;

@Test
public void testHelloService(){
    boolean b = ioc.containsBean(&quot;helloService01&quot;);
    System.out.println(b);
}

</code></pre>
<p><em>容器这个组件id就是方法名</em></p>
<h2 id="4-配置文件占位符">4、配置文件占位符</h2>
<h4 id="1-随机数">1、随机数</h4>
<pre><code class="language-properties">${random.value} 、${random.int}、${random.long}
${random.int(10)}、${random.int[100,200]}

</code></pre>
<h4 id="2-获取配置值">2、获取配置值</h4>
<pre><code class="language-properties">person.age=${random.int}
person.boss=false
person.last-name=张三${random.uuid}
person.maps.k1=v1
person.maps.k2=v2
person.lists=a,b,c
person.dog.name=${person.last-name}'s wanghuahu
person.dog.age=15

</code></pre>
<p>存在以下两种情况</p>
<p>没有声明<code>person.last-name</code>会报错，新声明的需要加默认值</p>
<pre><code class="language-properties">person.age=${random.int}
person.boss=false
person.last-name=张三${random.uuid}
person.maps.k1=v1
person.maps.k2=v2
person.lists=a,b,c
person.dog.name=${person.hello:hello}'s wanghuahu
person.dog.age=15

</code></pre>
<p>结果：输出<code>hello's wanghuahua</code></p>
<h2 id="5-profile">5、Profile</h2>
<h3 id="1-多profile文件">1、多Profile文件</h3>
<p>我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml</p>
<ul>
<li>application.properties</li>
<li>application-dev.properties</li>
<li>application-prod.properties</li>
</ul>
<p>默认使用application.properties</p>
<p>application.properties配置文件指定</p>
<pre><code class="language-properties">spring.profiles.active=dev

</code></pre>
<h3 id="2-yaml文档块">2、YAML文档块</h3>
<pre><code class="language-yaml">server:
  port: 8081
spring:
  profiles:
    active: dev

---

server:
  port: 9000
spring:
  profiles: dev

---
server:
  port: 80
spring:
  profiles: prod


</code></pre>
<h3 id="3-激活指定profile">3、激活指定profile</h3>
<p>1、在配置文件中激活</p>
<p>2、命令行：</p>
<p>--spring.profiles.active=dev</p>
<figure data-type="image" tabindex="3"><img src="https://stormga.github.io//post-images/5.comandLine.jpg" alt="" loading="lazy"></figure>
<p>优先级大于配置文件</p>
<p>打包 成jar后</p>
<p><code>java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar --spring.profiles.active=dev</code></p>
<p>虚拟机参数</p>
<p><code>-Dspring.profiles.active=dev</code></p>
<h2 id="6-加载配置文件位置">6、加载配置文件位置</h2>
<p>SpringBoot启动扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件</p>
<ul>
<li>file:./config/</li>
<li>file./</li>
<li>classpath:/config/</li>
<li>classpath:/</li>
</ul>
<p>优先级从高到低顺序，高优先级会覆盖低优先级的相同配置；互补配置</p>
<p>也可以通过spring.config.location来改变默认配置</p>
<blockquote>
<pre><code>server.servlet.context-path=/boot03

</code></pre>
</blockquote>
<p>注：spring boot1x 是server.context.path=/boot02</p>
<figure data-type="image" tabindex="4"><img src="https://stormga.github.io//post-images/7.priority.jpg" alt="" loading="lazy"></figure>
<p>还可以通过spring.config.location来改变配置文件的位置</p>
<p>项目打包好了以后，可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认的配置文件会共同起作用，互补配置</p>
<p><code>java -jar spring-boot-config-02-0.0.1-SNAPSHOT.jar --spring.config.location=E:/work/application.properties</code></p>
<p>运维比较有用，从外部加载，不用修改别的文件</p>
<h2 id="7引入外部配置">7.引入外部配置</h2>
<p><strong>SpringBoot也可以从以下位置加载配置；优先级从高到低；高优先级覆盖低优先级，可以互补</strong></p>
<ol>
<li>
<p>命令行参数</p>
<p>java -jar spring-boot-config-02-0.0.1-SNAPSHOT.jar --server.port=9005 --server.context-path=/abc</p>
<p>中间一个空格</p>
</li>
<li>
<p>来自java:comp/env的JNDI属性</p>
</li>
<li>
<p>java系统属性（System.getProperties()）</p>
</li>
<li>
<p>操作系统环境变量</p>
</li>
<li>
<p>RandomValuePropertySource配置的random.*属性值</p>
<p><strong>优先加载profile,    由jar包外到jar包内</strong></p>
</li>
<li>
<p><strong>jar包外部的application-{profile}.properties或application.yml(带Spring.profile)配置文件</strong></p>
</li>
<li>
<p><strong>jar包内部的application-{profile}.properties或application.yml(带Spring.profile)配置文件</strong></p>
</li>
<li>
<p><strong>jar包外部的application.properties或application.yml(带Spring.profile)配置文件</strong></p>
</li>
<li>
<p><strong>jar包内部的application.properties或application.yml(不带spring.profile)配置文件</strong></p>
</li>
<li>
<p>@Configuration注解类的@PropertySource</p>
</li>
<li>
<p>通过SpringApplication.setDefaultProperties指定的默认属性</p>
</li>
</ol>
<p><a href="https://docs.spring.io/spring-boot/docs/2.0.1.RELEASE/reference/htmlsingle/#boot-features-external-config">官方文档</a></p>
<h2 id="8-自动配置">8、自动配置</h2>
<p>配置文件到底怎么写？</p>
<p><a href="https://docs.spring.io/spring-boot/docs/2.0.1.RELEASE/reference/htmlsingle/#common-application-properties">Spring的所有配置参数</a></p>
<p>自动配置原理很关键</p>
<h3 id="1-自动配置原理">1、自动配置原理</h3>
<p>1）、SpringBoot启动的时候加载主配置类，开启自动配置功能，@EnableAutoConfiguration</p>
<p>2）、@EnableAutoConfiguration 作用：</p>
<ul>
<li>利用AutoConfigurationImportSelector给容器中导入一些组件？</li>
<li>可以查看selectImports()方法的内容</li>
<li>获取候选的配置</li>
</ul>
<pre><code class="language-java">List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes);

</code></pre>
<ul>
<li>扫描类路径下的</li>
</ul>
<pre><code class="language-java">  SpringFactoriesLoader.loadFactoryNames(）
  扫描所有jar包类路径下的 MATA-INF/spring.factories
  把扫描到的这些文件的内容包装成properties对象
  从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加到容器中

</code></pre>
<p>将类路径下 MATE-INF/spring.factories里面配置的所有的EnableAutoConfiguration的值加入到了容器中；</p>
<p>3）、每一个自动配置类进行自动配置功能；</p>
<p>4）、以<strong>HttpEncodingAutoConfiguration</strong> 为例</p>
<pre><code class="language-java">@Configuration //表示是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件
@EnableConfigurationProperties({HttpEncodingProperties.class})//启动指定类的Configurationproperties功能；将配置文件中的值和HttpEncodingProperties绑定起来了；并把HttpEncodingProperties加入ioc容器中
@ConditionalOnWebApplication//根据不同的条件，进行判断，如果满足条件，整个配置类里面的配置就会失效，判断是否为web应用；
(
    type = Type.SERVLET
)
@ConditionalOnClass({CharacterEncodingFilter.class})//判断当前项目有没有这个类，解决乱码的过滤器
@ConditionalOnProperty(
    prefix = &quot;spring.http.encoding&quot;,
    value = {&quot;enabled&quot;},
    matchIfMissing = true
)//判断配置文件是否存在某个配置 spring.http.encoding，matchIfMissing = true如果不存在也是成立，即使不配置也生效
public class HttpEncodingAutoConfiguration {
   //给容器添加组件，这个组件的值需要从properties属性中获取
    private final HttpEncodingProperties properties;
	//只有一个有参数构造器情况下，参数的值就会从容器中拿
    public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) {
        this.properties = properties;
    }

    @Bean
    @ConditionalOnMissingBean
    public CharacterEncodingFilter characterEncodingFilter() {
        CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();
        filter.setEncoding(this.properties.getCharset().name());
        filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpEncodingProperties.Type.REQUEST));
        filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpEncodingProperties.Type.RESPONSE));
        return filter;
    }


</code></pre>
<p>5）、所有在配置文件中能配置的属性都是在xxxProperties类中封装着；配置文件能配置什么就可以参照某个功能对应的这个属性类</p>
<pre><code class="language-java">@ConfigurationProperties(prefix = &quot;spring.http.encoding&quot;)//从配置文件中的值进行绑定和bean属性进行绑定
public class HttpEncodingProperties {

</code></pre>
<p>根据当前不同条件判断，决定这个配置类是否生效？</p>
<p>一旦这个配置类生效；这个配置类会给容器添加各种组件；这些组件的属性是从对应的properties中获取的，这些类里面的每个属性又是和配置文件绑定的</p>
<h3 id="2-所有的自动配置组件">2、所有的自动配置组件</h3>
<p>每一个xxxAutoConfiguration这样的类都是容器中的一个组件，都加入到容器中；</p>
<p>作用：用他们做自动配置</p>
<pre><code class="language-properties"># Auto Configure
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\
org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\
org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\
org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\
org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\
org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\
org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\
org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\
org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\
org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\
org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\
org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\
org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\
org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\
org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\
org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\
org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\
org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\
org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\
org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\
org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\
org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\
org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\
org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\
org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\
org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,\
org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,\
org.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,\
org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\
org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\
org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\
org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\
org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\
org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\
org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\
org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\
org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\
org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\
org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\
org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\
org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\
org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\
org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\
org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\
org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,\
org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\
org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\
org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\
org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\
org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\
org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\
org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\
org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\
org.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,\
org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\
org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\
org.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\
org.springframework.boot.autoconfigure.reactor.core.ReactorCoreAutoConfiguration,\
org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\
org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,\
org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,\
org.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,\
org.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,\
org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\
org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\
org.springframework.boot.autoconfigure.security.oauth2.client.OAuth2ClientAutoConfiguration,\
org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\
org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\
org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\
org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\
org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\
org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,\
org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration,\
org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,\
org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,\
org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\
org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,\
org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\
org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\
org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\
org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\
org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\
org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\
org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\
org.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,\
org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,\
org.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,\
org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration


</code></pre>
<h3 id="3-精髓">3、精髓：</h3>
<p>1）、SpringBoot启动会加载大量的自动配置类</p>
<p>2）、我们看我们需要的功能有没有SpringBoot默认写好的默认配置类；</p>
<p>3）、如果有在看这个自动配置类中配置了哪些组件；（只要我们要用的组件有，我们需要再来配置）</p>
<p>4）、给容器中自动配置添加组件的时候，会从properties类中获取属性。我们就可以在配置文件中指定这些属性的值</p>
<p>xxxAutoConfiguration:自动配置类；</p>
<p>给容器中添加组件</p>
<p>xxxProperties:封装配置文件中的属性；</p>
<p>跟之前的Person类一样，配置文件中值加入bean中</p>
<h3 id="4-细节">4、细节</h3>
<h4 id="1-conditional派生注解">1、@Conditional派生注解</h4>
<blockquote>
<p>利用Spring注解版原生的@Conditional作用</p>
</blockquote>
<p>作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；</p>
<table>
<thead>
<tr>
<th>@Conditional派生注解</th>
<th>作用（判断是否满足当前指定条件）</th>
</tr>
</thead>
<tbody>
<tr>
<td>@ConditionalOnJava</td>
<td>系统的java版本是否符合要求</td>
</tr>
<tr>
<td>@ConditionalOnBean</td>
<td>容器中存在指定Bean</td>
</tr>
<tr>
<td>@ConditionalOnMissBean</td>
<td>容器中不存在指定Bean</td>
</tr>
<tr>
<td>@ConditionalOnExpression</td>
<td>满足spEL表达式</td>
</tr>
<tr>
<td>@ConditionalOnClass</td>
<td>系统中有指定的类</td>
</tr>
<tr>
<td>@ConditionalOnMissClass</td>
<td>系统中没有指定的类</td>
</tr>
<tr>
<td>@ConditionalOnSingleCandidate</td>
<td>容器中只有一个指定的Bean,或者这个Bean是首选Bean</td>
</tr>
<tr>
<td>@ConditionalOnProperty</td>
<td>系统中指定的属性是否有指定的值</td>
</tr>
<tr>
<td>@ConditionalOnResource</td>
<td>类路径下是否存在指定的资源文件</td>
</tr>
<tr>
<td>@ConditionalOnWebApplication</td>
<td>当前是web环境</td>
</tr>
<tr>
<td>@ConditionalOnNotWebApplication</td>
<td>当前不是web环境</td>
</tr>
<tr>
<td>@ConditionalOnJndi</td>
<td>JNDI存在指定项</td>
</tr>
</tbody>
</table>
<h4 id="2-自动配置报告">2、自动配置报告</h4>
<p>自动配置类必须在一定条件下生效</p>
<p>我们可以通过启用debug=true属性，配置文件，打印自动配合报告，这样就可以知道自动配置类生效</p>
<pre><code class="language-properties">debug=true

</code></pre>
<p>自动配置报告</p>
<pre><code class="language-java">============================

CONDITIONS EVALUATION REPORT
============================


Positive matches:（启动的，匹配成功的）
-----------------

   CodecsAutoConfiguration matched:
      - @ConditionalOnClass found required class 'org.springframework.http.codec.CodecConfigurer'; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition)
        ......
        
 Negative matches:（没有启动的，没有匹配成功的）
-----------------

   ActiveMQAutoConfiguration:
      Did not match:
         - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' (OnClassCondition)
.....

</code></pre>
<h1 id="三-日志">三、日志</h1>
<blockquote>
<p>Spring Boot2对日志有更改</p>
</blockquote>
<h3 id="1-日志框架">1、日志框架</h3>
<p>小张：开发一个大型系统；</p>
<p>1、System.out.println(&quot;&quot;);将关键数据打印在控制台；去掉？卸载文件中</p>
<p>2、框架记录系统的一些运行信息；日志框架zhanglog.jar</p>
<p>3、高大上功能，异步模式？自动归档？xxx?zhanglog-good.jar?</p>
<p>4、将以前的框架卸下来？换上新的框架，重新修改之前的相关API;zhanglog-perfect.jar;</p>
<p>5、JDBC--数据库驱动；</p>
<p>​	写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar;</p>
<p>​	给项目中导入具体的日志实现就行；我们之前的日志框架都是实现的抽象层；</p>
<p>市面上的日志框架</p>
<table>
<thead>
<tr>
<th>日志抽象层</th>
<th>日志实现</th>
</tr>
</thead>
<tbody>
<tr>
<td><s>JCL(Jakarta Commons Logging)</s> SLF4j(Simple Logging Facade for Java) <s>jboss-logging</s></td>
<td>Log4j <s>JUL(java.util.logging)</s> Log4j2 Logback</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>左边的抽象，右边的实现</p>
<p>SLF4J  -- Logback</p>
<p>Spring Boot:底层是Spring框架，Spring默认框架是JCL；</p>
<p>​	SpringBoot选用SLF4J和logback</p>
<h3 id="2-slf4j使用">2、SLF4J使用</h3>
<h4 id="1-如何在系统中使用slf4j">1、如何在系统中使用SLF4j</h4>
<p>以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法；</p>
<p>应该给系统里面导入slf4j的jar包和logback的实现jar</p>
<pre><code class="language-java">import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class HelloWorld {
  public static void main(String[] args) {
    Logger logger = LoggerFactory.getLogger(HelloWorld.class);
    logger.info(&quot;Hello World&quot;);
  }
}

</code></pre>
<figure data-type="image" tabindex="5"><img src="https://stormga.github.io//post-images/8.slf4j.jpg" alt="" loading="lazy"></figure>
<p>每个日志框架的实现框架都有自己的配置文件。使用slf4j以后，<strong>配置文件还是做成日志实现框架本身的配置文件</strong>；</p>
<h4 id="2-遗留问题">2、遗留问题</h4>
<p>a系统(slf4j+logback)：Spring（commons-logging）、Hibernate（jboss-logging）、Mybatis</p>
<p>统一日志框架，即使是别的框架和我一起统一使用slf4j进行输出；</p>
<p>核心：</p>
<p>1、将系统中其他日志框架排除出去；</p>
<p>2、用中间包来替换原有的日志框架</p>
<p>3、导入slf4j的其他实现</p>
<h3 id="3-spingboot日志框架解析">3、SpingBoot日志框架解析</h3>
<p>打开IDEA ，打开pom文件的依赖图形化显示</p>
<figure data-type="image" tabindex="6"><img src="https://stormga.github.io//post-images/9.IDEAdependencies.jpg" alt="" loading="lazy"></figure>
<p>SpringBoot的基础框架</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;

</code></pre>
<p>SpringBoot的日志功能</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;
    &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;

</code></pre>
<figure data-type="image" tabindex="7"><img src="https://stormga.github.io//post-images/10.slf4jandlogback.jpg" alt="" loading="lazy"></figure>
<p>总结：</p>
<ol>
<li>
<p>SpringBoot底层也是使用SLF4J+log4jback</p>
</li>
<li>
<p>SpringBoot也把其他日志替换成了slf4j</p>
</li>
<li>
<p>起着commons.loggings的名字其实new的SLF4J替换中间包</p>
<p>SpringBoot2中改成了bridge</p>
</li>
<li>
<p>如果要引入其他框架？一定要把这个框架的日志依赖移除掉，而且底层</p>
</li>
</ol>
<h3 id="4-日志的使用">4、日志的使用</h3>
<h4 id="1-默认配置">1、默认配置</h4>
<p>trace-debug-info-warn-error</p>
<p>可以调整需要的日志级别进行输出，不用注释语句。</p>
<pre><code class="language-java">//记录器
Logger logger = LoggerFactory.getLogger(getClass());
@Test
public void contextLoads() {

    //日志的级别
    //从低到高
    //可以调整输出的日志级别；日志就只会在这个级别以后的高级别生效
    logger.trace(&quot;这是trace日志&quot;);
    logger.debug(&quot;这是debug信息&quot;);
    //SpringBoot默认给的是info级别，如果没指定就是默认的root级别
    logger.info(&quot;这是info日志&quot;);
    logger.warn(&quot;这是warn信息&quot;);
    logger.error(&quot;这是Error信息&quot;);
}

</code></pre>
<p>调整指定包的日志级别在配置文件中进行配置</p>
<pre><code class="language-properties">logging.level.cn.lkhcoding=trace

</code></pre>
<p>日志输出格式</p>
<pre><code class="language-properties">#控制台输出的日志格式 
#%d：日期
#%thread：线程号 
#%-5level：靠左 级别 
#%logger{50}：全类名50字符限制,否则按照句号分割
#%msg：消息+换行
#%n：换行
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n

</code></pre>
<p>SpringBoot修改日志的默认配置</p>
<pre><code class="language-properties">logging.level.com.wdjr=trace
#不指定path就是当前目录下生成springboot.log
#logging.file=springboot.log
#当前磁盘下根路径创建spring文件中log文件夹，使用spring.log作为默认
logging.path=/spring/log
#控制台输出的日志格式 日期 + 线程号 + 靠左 级别 +全类名50字符限制+消息+换行
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n
#指定文件中日志输出的格式
logging.pattern.file=xxx

</code></pre>
<h4 id="2-指定配置">2、指定配置</h4>
<p>给类路径下放上每个日志框架自己的配置框架；SpringBoot就不会使用自己默认的配置</p>
<table>
<thead>
<tr>
<th>logging System</th>
<th>Customization</th>
</tr>
</thead>
<tbody>
<tr>
<td>Logback</td>
<td>logback-spring.xml ,logback-spring.groovy,logback.xml or logback.groovy</td>
</tr>
<tr>
<td>Log4J2</td>
<td>log4j2-spring.xml or log4j2.xml</td>
</tr>
<tr>
<td>JDK(Java Util Logging)</td>
<td>logging.properties</td>
</tr>
</tbody>
</table>
<p>logback.xml直接被日志框架识别 ，logback-spring.xml日志框架就不直接加载日志配置项，由SpringBoot加载</p>
<pre><code class="language-xml">&lt;springProfile name=&quot;dev&quot;&gt;
	&lt;!-- 可以指定某段配置只在某个环境下生效 --&gt;
&lt;/springProfile&gt;
&lt;springProfile name!=&quot;dev&quot;&gt;
	&lt;!-- 可以指定某段配置只在某个环境下生效 --&gt;
&lt;/springProfile&gt;

</code></pre>
<p>如何调试开发环境,输入命令行参数</p>
<p>--spring.profiles.active=dev</p>
<p>如果不带后面的xx-spring.xml就会报错</p>
<h3 id="3-切换日志框架">3、切换日志框架</h3>
<p>可以根据slf4j的日志适配图，进行相关切换；</p>
<h4 id="1-log4j">1、log4j</h4>
<p>slf4j+log4j的方式；</p>
<figure data-type="image" tabindex="8"><img src="https://stormga.github.io//post-images/11.log4j.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
&lt;/dependency&gt;

</code></pre>
<p>不推荐使用仅作为演示</p>
<h4 id="2-log4j2">2、log4j2</h4>
<p>切换为log4j2</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;
&lt;/dependency&gt;

</code></pre>
<h1 id="四-web开发">四、web开发</h1>
<h2 id="1-简介">1、简介</h2>
<p>使用SpringBoot;</p>
<p>1)、创建SpringBoot应用，选中我们需要的模块；</p>
<p>2)、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来</p>
<p>3)、自己编写业务代码</p>
<p><strong>自动配置原理？</strong></p>
<p>这个场景的SpringBoot帮我们配置了什么？能不能修改？能修改那些配置？能不能扩展？xxx</p>
<pre><code class="language-java">xxxAutoConfiguration:帮我们给容器中自动配置组件
xxxProperties:配置类来封装配置文件的内容

</code></pre>
<h2 id="2-静态资源文件映射规则">2、静态资源文件映射规则</h2>
<pre><code class="language-java">@ConfigurationProperties(prefix = &quot;spring.resources&quot;, ignoreUnknownFields = false)
public class ResourceProperties implements ResourceLoaderAware, InitializingBean {
    //可以设置和静态资源相关的参数，缓存时间等

</code></pre>
<pre><code class="language-java">@Override
public void addResourceHandlers(ResourceHandlerRegistry registry) {
   if (!this.resourceProperties.isAddMappings()) {
      logger.debug(&quot;Default resource handling disabled&quot;);
      return;
   }
   Integer cachePeriod = this.resourceProperties.getCachePeriod();
   if (!registry.hasMappingForPattern(&quot;/webjars/**&quot;)) {
      customizeResourceHandlerRegistration(registry
            .addResourceHandler(&quot;/webjars/**&quot;)
            .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;)
            .setCachePeriod(cachePeriod));
   }
   String staticPathPattern = this.mvcProperties.getStaticPathPattern();
   if (!registry.hasMappingForPattern(staticPathPattern)) {
      customizeResourceHandlerRegistration(
            registry.addResourceHandler(staticPathPattern)
                  .addResourceLocations(
                        this.resourceProperties.getStaticLocations())
                  .setCachePeriod(cachePeriod));
   }
}

</code></pre>
<h3 id="1-webjar">1、webjar</h3>
<p>1)、所有的/webjars/**，都去classpath:/META-INF/resources/webjars/找资源；</p>
<p>​	webjars：以jar包的方式引入静态资源</p>
<p>http://www.webjars.org/</p>
<figure data-type="image" tabindex="9"><img src="https://stormga.github.io//post-images/12.jquery.jpg" alt="" loading="lazy"></figure>
<p>localhost:8080/webjars/jquery/3.3.1/jquery.js</p>
<h3 id="2-本地资源">2、本地资源</h3>
<pre><code>private String staticPathPattern = &quot;/**&quot;;

</code></pre>
<p>访问任何资源</p>
<p>2、会在这几文件夹下去找静态路径（静态资源文件夹）</p>
<pre><code>&quot;classpath:/META-INF/resources/&quot;, 
&quot;classpath:/resources/&quot;,
&quot;classpath:/static/&quot;, 
&quot;classpath:/public/&quot;,
&quot;/&quot;;当前项目的根路径

</code></pre>
<figure data-type="image" tabindex="10"><img src="https://stormga.github.io//post-images/13.static.jpg" alt="" loading="lazy"></figure>
<p>localhost:8080/abc ==&gt;去静态资源文件夹中找abc</p>
<figure data-type="image" tabindex="11"><img src="https://stormga.github.io//post-images/14.static-css.jpg" alt="" loading="lazy"></figure>
<p>3、index页面欢迎页，静态资源文件夹下所有的index.html页面；被“/**”映射；</p>
<p>localhost:8080/  --&gt;index页面</p>
<pre><code class="language-JAVA">@Bean
public WelcomePageHandlerMapping welcomePageHandlerMapping(
      ResourceProperties resourceProperties) {
   return new WelcomePageHandlerMapping(resourceProperties.getWelcomePage(),
         this.mvcProperties.getStaticPathPattern());
}

</code></pre>
<p>4、喜欢的图标，即网站title的图标favicon</p>
<pre><code class="language-java">@Configuration
@ConditionalOnProperty(value = &quot;spring.mvc.favicon.enabled&quot;, matchIfMissing = true)
public static class FaviconConfiguration {

   private final ResourceProperties resourceProperties;

   public FaviconConfiguration(ResourceProperties resourceProperties) {
      this.resourceProperties = resourceProperties;
   }

   @Bean
   public SimpleUrlHandlerMapping faviconHandlerMapping() {
      SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping();
      mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1);
       //把任何favicon的图标都在静态文件夹下找
      mapping.setUrlMap(Collections.singletonMap(&quot;**/favicon.ico&quot;,
            faviconRequestHandler()));
      return mapping;
   }

   @Bean
   public ResourceHttpRequestHandler faviconRequestHandler() {
      ResourceHttpRequestHandler requestHandler = new ResourceHttpRequestHandler();
      requestHandler
            .setLocations(this.resourceProperties.getFaviconLocations());
      return requestHandler;
   }

}

</code></pre>
<p>可以在配置文件配置静态资源文件夹</p>
<pre><code class="language-properties">spring.resources.static-locations=classpath:xxxx

</code></pre>
<h2 id="3-模板引擎">3、模板引擎</h2>
<p>将html和数据 结合到一起 输出组装处理好的新文件</p>
<p>SpringBoot推荐Thymeleaf;语法简单，功能强大</p>
<h3 id="1-引入thymeleaf-3">1、引入thymeleaf 3</h3>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
&lt;/dependency&gt;

</code></pre>
<p>默认导入thymeleaf2，版本太低 所以使用thymeleaf3.</p>
<p><a href="https://docs.spring.io/spring-boot/docs/1.5.12.RELEASE/reference/htmlsingle/#howto-use-thymeleaf-3">官方导入办法</a></p>
<pre><code class="language-xml">&lt;properties&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
    &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;!--thymeleaf 3的导入--&gt;
    &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt;
    &lt;!--布局功能支持 同时支持thymeleaf3主程序 layout2.0以上版本  --&gt;
    &lt;!--布局功能支持 同时支持thymeleaf2主程序 layout1.0以上版本  --&gt;
    &lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt;
&lt;/properties&gt;

</code></pre>
<h3 id="2-thymeleaf使用和语法">2、Thymeleaf使用和语法</h3>
<pre><code class="language-java">@ConfigurationProperties(prefix = &quot;spring.thymeleaf&quot;)
public class ThymeleafProperties {

   private static final Charset DEFAULT_ENCODING = Charset.forName(&quot;UTF-8&quot;);

   private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf(&quot;text/html&quot;);

   public static final String DEFAULT_PREFIX = &quot;classpath:/templates/&quot;;

   public static final String DEFAULT_SUFFIX = &quot;.html&quot;;
   //只要把HTML文件方法类路径下的template文件夹下，就会自动导入

</code></pre>
<p>只要把HTML页面放到classpath:/templates/,thymeleaf就能自动渲染；</p>
<p>使用：</p>
<p>1、导入thymeleaf的名称空间</p>
<pre><code class="language-html">&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;    

</code></pre>
<p>2、使用thymeleaf语法；</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;  xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;title&gt;success&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;success&lt;/h1&gt;
&lt;!--th:text 将div里面的文本内容设置为--&gt;
&lt;div th:text=&quot;${Lion}&quot;&gt;
前端数据
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<p>3、语法规则</p>
<p>1）、th:text=&quot;${hello}&quot;可以使用任意标签 替换原生的任何属性</p>
<p><strong>在SpringBoot的环境下</strong></p>
<pre><code class="language-html">&lt;div id=&quot;testid&quot; class=&quot;testcalss&quot; th:id=&quot;${Lion}&quot; th:class=&quot;${Lion}&quot; th:text=&quot;${Lion}&quot;&gt;
	前端数据
&lt;/div&gt;

</code></pre>
<figure data-type="image" tabindex="12"><img src="https://stormga.github.io//post-images/15.thtmeleaf-th01.jpg" alt="" loading="lazy"></figure>
<p><strong>直接访问HTML页面</strong></p>
<figure data-type="image" tabindex="13"><img src="https://stormga.github.io//post-images/15.thtmeleaf-th02.jpg" alt="" loading="lazy"></figure>
<p><strong>2)、内联写法注意需要在body上加上 th:inline=&quot;text&quot;敲黑板</strong></p>
<p>不然不起作用</p>
<pre><code class="language-html">&lt;body class=&quot;text-center&quot; th:inline=&quot;text&quot;&gt;&lt;/body&gt;

</code></pre>
<p>th标签的访问优先级</p>
<p>Order Feature Attributes</p>
<h3 id="3-语法规则">3、语法规则</h3>
<table>
<thead>
<tr>
<th></th>
<th>功能</th>
<th>标签</th>
<th>功能和jsp对比</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Fragment inclusion</td>
<td>th:insert th:replace</td>
<td>include(片段包含)</td>
</tr>
<tr>
<td>2</td>
<td>Fragment iteration</td>
<td>th:each</td>
<td>c:forEach(遍历)</td>
</tr>
<tr>
<td>3</td>
<td>Conditional evaluation</td>
<td>th:if th:unless th:switch th:case</td>
<td>c:if(条件判断)</td>
</tr>
<tr>
<td>4</td>
<td>Local variable definition</td>
<td>th:object  th:with</td>
<td>c:set(声明变量)</td>
</tr>
<tr>
<td>5</td>
<td>General attribute modification</td>
<td>th:attr th:attrprepend th:attrappend</td>
<td>属性修改支持前面和后面追加内容</td>
</tr>
<tr>
<td>6</td>
<td>Specific attribute modification</td>
<td>th:value th:href th:src ...</td>
<td>修改任意属性值</td>
</tr>
<tr>
<td>7</td>
<td>Text (tag body modification)</td>
<td>th:text th:utext</td>
<td>修改标签体内容utext：不转义字符<h1>大标题</td>
</tr>
<tr>
<td>8</td>
<td>Fragment specification</td>
<td>th:fragment</td>
<td>声明片段</td>
</tr>
<tr>
<td>9</td>
<td>Fragment removal</td>
<td>th:remove</td>
<td></td>
</tr>
</tbody>
</table>
<pre><code class="language-properties">Simple expressions:(表达式语法)
    Variable Expressions: ${...}
    	1、获取对象属性、调用方法
    	2、使用内置基本对象：
    	    #ctx : the context object.
            #vars: the context variables.
            #locale : the context locale.
            #request : (only in Web Contexts) the HttpServletRequest object.
            #response : (only in Web Contexts) the HttpServletResponse object.
            #session : (only in Web Contexts) the HttpSession object.
            #servletContext : (only in Web Contexts) the ServletContext object.
         3、内置一些工具对象
        	#execInfo : information about the template being processed.
        	#messages : methods for obtaining externalized messages inside variables expressions, in the same way as they
            would be obtained using #{…} syntax.
            #uris : methods for escaping parts of URLs/URIs
            #conversions : methods for executing the configured conversion service (if any).
            #dates : methods for java.util.Date objects: formatting, component extraction, etc.
            #calendars : analogous to #dates , but for java.util.Calendar objects.
            #numbers : methods for formatting numeric objects.
            #strings : methods for String objects: contains, startsWith, prepending/appending, etc.
            #objects : methods for objects in general.
            #bools : methods for boolean evaluation.
            #arrays : methods for arrays.
            #lists : methods for lists.
            #sets : methods for sets.
            #maps : methods for maps.
            #aggregates : methods for creating aggregates on arrays or collections.
            #ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration).
    Selection Variable Expressions: *{...} //选择表达式：和${}功能一样，补充功能
   # 配合th:object使用，object=${object} 以后获取就可以使用*{a}  相当于${object.a}
  	    &lt;div th:object=&quot;${session.user}&quot;&gt;
            &lt;p&gt;Name: &lt;span th:text=&quot;*{firstName}&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt;
            &lt;p&gt;Surname: &lt;span th:text=&quot;*{lastName}&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt;
            &lt;p&gt;Nationality: &lt;span th:text=&quot;*{nationality}&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt;
		&lt;/div&gt;
    Message Expressions: #{...} //获取国际化内容
    Link URL Expressions: @{...} //定义URL链接
    	#&lt;a href=&quot;details.html&quot; th:href=&quot;@{/order/details(orderId=${o.id})}&quot;&gt;view&lt;/a&gt;
    Fragment Expressions: ~{...}//片段文档
    
Literals（字面量）
    Text literals: 'one text' , 'Another one!' ,…
    Number literals: 0 , 34 , 3.0 , 12.3 ,…
    Boolean literals: true , false
    Null literal: null
    Literal tokens: one , sometext , main ,…
Text operations:(文本操作)
    String concatenation: +
    Literal substitutions: |The name is ${name}|
Arithmetic operations:（数学运算）
    Binary operators: + , - , * , / , %
    Minus sign (unary operator): -
Boolean operations:（布尔运算）
    Binary operators: and , or
    Boolean negation (unary operator): ! , not
Comparisons and equality:（比较运算）
    Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le )
    Equality operators: == , != ( eq , ne )
Conditional operators:（条件运算）
    If-then: (if) ? (then)
    If-then-else: (if) ? (then) : (else)
    Default: (value) ?: (defaultvalue)
Special tokens:（空操作）
	No-Operation: _

</code></pre>
<p>inline写法</p>
<pre><code class="language-html">[[]] --&gt;th:text
[()] --&gt;th:utext

</code></pre>
<h2 id="4-springmvc自动配置">4、SpringMVC自动配置</h2>
<h3 id="1-springmvc的自动导入">1、SpringMVC的自动导入</h3>
<p><a href="https://docs.spring.io/spring-boot/docs/1.5.12.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications">Spring框架</a></p>
<p>自动配置好了mvc：</p>
<p>以下是SpringBoot对SpringMVC的默认</p>
<p>Spring Boot provides auto-configuration for Spring MVC that works well with most applications.</p>
<p>The auto-configuration adds the following features on top of Spring’s defaults:</p>
<ul>
<li>
<p>Inclusion of <code>ContentNegotiatingViewResolver</code> and <code>BeanNameViewResolver</code> beans.</p>
<ul>
<li>自动配置了ViewResolver(视图解析器：根据方法的返回值得到视图对象（View）,视图对象决定如何渲染（转发？重定向？）)</li>
<li><code>ContentNegotiatingViewResolver</code>组合所有视图解析器</li>
<li>如何定制：我们可以自己给容器中添加一个视图解析器；自动将其整合进来</li>
</ul>
</li>
<li>
<p>Support for serving static resources, including support for WebJars (see below).静态资源</p>
</li>
<li>
<p>Static <code>index.html</code> support.</p>
</li>
<li>
<p>Custom <code>Favicon</code> support (see below).</p>
</li>
<li>
<p>自动注册 了<code>Converter</code>, <code>GenericConverter</code>, <code>Formatter</code> beans.</p>
<ul>
<li>
<p><code>Converter</code>：类型转换 文本转为字面量</p>
</li>
<li>
<p><code>Formatter</code> ：格式化器 转换后格式转换</p>
<pre><code class="language-java">@Bean
@ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;date-format&quot;)//在文件配置入职格式化的规则
public Formatter&lt;Date&gt; dateFormatter() {
   return new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件
}

</code></pre>
<p>自己添加的格式化转换器，只需要放在容器中即可</p>
</li>
</ul>
</li>
<li>
<p>Support for <code>HttpMessageConverters</code> (see below).</p>
<ul>
<li>
<p><code>HttpMessageConverters</code> ：转换HTTP转换和响应：User - json</p>
</li>
<li>
<p><code>HttpMessageConverters</code> ：是从容器中确定；获取所有的<code>HttpMessageConverters</code>  ，将自己的组件注册在容器中@Bean</p>
</li>
<li>
<p>If you need to add or customize converters you can use Spring Boot’s <code>HttpMessageConverters</code> class:</p>
<pre><code class="language-java">import org.springframework.boot.autoconfigure.web.HttpMessageConverters;
import org.springframework.context.annotation.*;
import org.springframework.http.converter.*;

@Configuration
public class MyConfiguration {

    @Bean
    public HttpMessageConverters customConverters() {
        HttpMessageConverter&lt;?&gt; additional = ...
        HttpMessageConverter&lt;?&gt; another = ...
        return new HttpMessageConverters(additional, another);
    }

}

</code></pre>
</li>
</ul>
</li>
<li>
<p>Automatic registration of <code>MessageCodesResolver</code> (see below).</p>
<ul>
<li>定义错误代码生成规则</li>
</ul>
</li>
<li>
<p>Automatic use of a <code>ConfigurableWebBindingInitializer</code> bean (see below).</p>
<ul>
<li>
<pre><code class="language-java">@Override
protected ConfigurableWebBindingInitializer getConfigurableWebBindingInitializer() {
   try {
      return this.beanFactory.getBean(ConfigurableWebBindingInitializer.class);
   }
   catch (NoSuchBeanDefinitionException ex) {
      return super.getConfigurableWebBindingInitializer();
   }
}

</code></pre>
<p>在beanFactory：中可以自己创建一个，初始化webDataBinder</p>
<p>请求数据 ==》javaBean</p>
</li>
</ul>
</li>
</ul>
<p>If you want to keep Spring Boot MVC features, and you just want to add additional <a href="https://docs.spring.io/spring/docs/4.3.16.RELEASE/spring-framework-reference/htmlsingle#mvc">MVC configuration</a> (interceptors, formatters, view controllers etc.) you can add your own <code>@Configuration</code> class of type <code>WebMvcConfigurerAdapter</code>, but <strong>without</strong> <code>@EnableWebMvc</code>. If you wish to provide custom instances of <code>RequestMappingHandlerMapping</code>, <code>RequestMappingHandlerAdapter</code> or <code>ExceptionHandlerExceptionResolver</code> you can declare a <code>WebMvcRegistrationsAdapter</code> instance providing such components.</p>
<p>If you want to take complete control of Spring MVC, you can add your own <code>@Configuration</code> annotated with <code>@EnableWebMvc</code>.</p>
<p>思想：修改默认配置</p>
<h3 id="2-扩展springmvc">2、扩展SpringMVC</h3>
<p>编写一个配置类，类型是WebMvcConfigurerAdapter(继承)，使用WebMvcConfigurerAdapter可以扩展，不能标注@EnableWebMvc;既保留了配置，也能拓展我们自己的应用</p>
<pre><code class="language-java">@Configuration
public class MyMvcConfig extends WebMvcConfigurerAdapter {

    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
//        super.addViewControllers(registry);
        //浏览器发送wdjr请求，也来到success页面
        registry.addViewController(&quot;/wdjr&quot;).setViewName(&quot;success&quot;);
    }
}

</code></pre>
<p>原理：</p>
<p>1）、WebMvcAutoConfiguration是SpringMVC的自动配置</p>
<p>2）、在做其他自动配置时会导入；@Import(EnableWebMvcConfiguration.class)</p>
<pre><code class="language-java">@Configuration
public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration {
    private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite();

	//从容器中获取所有webMVCconfigurer
	@Autowired(required = false)
	public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) {
		if (!CollectionUtils.isEmpty(configurers)) {
			this.configurers.addWebMvcConfigurers(configurers);
            
            	@Override
                protected void addViewControllers(ViewControllerRegistry registry) {
                    this.configurers.addViewControllers(registry);
                }
            //一个参考实现,将所有的webMVCconfigurer相关配置一起调用（包括自己的配置类）
            	@Override
               // public void addViewControllers(ViewControllerRegistry registry) {
                   // for (WebMvcConfigurer delegate : this.delegates) {
				 //delegate.addViewControllers(registry);
                    //}
                }
		}
	}
    

</code></pre>
<p>3）、自己的配置被调用</p>
<p>效果：SpringMVC的自动配置和我们的扩展配置都会起作用</p>
<h3 id="3-全面接管mvc">3、全面接管mvc</h3>
<p>不需要SpringBoot对SpringMVC的自动配置。</p>
<pre><code class="language-java">@EnableWebMvc
@Configuration
public class MyMvcConfig extends WebMvcConfigurerAdapter {

@Override
public void addViewControllers(ViewControllerRegistry registry) {


//        super.addViewControllers(registry);
        //浏览器发送wdjr请求，也来到success页面
        registry.addViewController(&quot;/wdjr&quot;).setViewName(&quot;success&quot;);
    }
}

</code></pre>
<p>例如静态资源访问，不推荐全面接管</p>
<p>原理：</p>
<p>为什么@EnableWebMvc注解，SpringBoot对SpringMVC的控制就失效了</p>
<p>1）、核心配置</p>
<pre><code class="language-java">@Import(DelegatingWebMvcConfiguration.class)
public @interface EnableWebMvc {
}

</code></pre>
<p>2）、DelegatingWebMvcConfiguration</p>
<pre><code class="language-java">@Configuration
public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport {

</code></pre>
<p>3）、WebMvcAutoConfiguration</p>
<pre><code class="language-java">@Configuration
@ConditionalOnWebApplication
@ConditionalOnClass({ Servlet.class, DispatcherServlet.class,
      WebMvcConfigurerAdapter.class })
//容器没有这个组件的时候，这个自动配置类才生效
@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
@AutoConfigureAfter({ DispatcherServletAutoConfiguration.class,
      ValidationAutoConfiguration.class })
public class WebMvcAutoConfiguration {

</code></pre>
<p>4）、@EnableWebMvc将WebMvcConfigurationSupport导入进来了；</p>
<p>5）、导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能</p>
<h2 id="5-修改springmvc默认配置">5、修改SpringMVC默认配置</h2>
<p>模式:</p>
<p>​	1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来；</p>
<p>​	2）、在SpringBoot中会有 xxxConfigurer帮助我们扩展配置。</p>
<h2 id="6-restfulcrud">6、RestfulCRUD</h2>
<h3 id="1-默认访问首页">1、默认访问首页</h3>
<p>在config/MyConfig.java中编写配置类</p>
<pre><code class="language-java">//所有的webMvcConfigurerAdapter组件会一起起作用
@Bean //註冊到容器去
public WebMvcConfigurerAdapter webMvcConfigurerAdapter(){
    WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() {
        @Override
        public void addViewControllers(ViewControllerRegistry registry) {
            registry.addViewController(&quot;/&quot;).setViewName(&quot;login&quot;);
            registry.addViewController(&quot;/login.html&quot;).setViewName(&quot;login&quot;);
        }
    };
    return adapter;
}

</code></pre>
<p>静态资源引用</p>
<pre><code class="language-html">&lt;link href=&quot;#&quot; th:href=&quot;@{/css/signin.css}&quot; rel=&quot;stylesheet&quot; /&gt;

</code></pre>
<h3 id="2-国际化">2、国际化</h3>
<p>1、编写国际化配置文件</p>
<p>2、使用ResourceBundleMessageSource管理国际化资源文件</p>
<p>3、在页面中使用fmt:message，取出国际化内容</p>
<h4 id="1-浏览器切换国际化">1、浏览器切换国际化</h4>
<p>步骤</p>
<p>1、编写国际化配置文件，抽取页面需要的显示的国际化消息</p>
<figure data-type="image" tabindex="14"><img src="https://stormga.github.io//post-images/16.national.jpg" alt="" loading="lazy"></figure>
<p>2、SpringBoot自动配置好了国际化配置的资源文件</p>
<pre><code class="language-java">@ConfigurationProperties(prefix = &quot;spring.messages&quot;)
public class MessageSourceAutoConfiguration {
    //我们的配置文件可以直接放在类路径下叫messages.properties
    private String basename = &quot;messages&quot;;
    @Bean
	public MessageSource messageSource() {
		ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();
		if (StringUtils.hasText(this.basename)) {
            //设置国际化文件的基础名，去掉语言国家代码
			messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray(
					StringUtils.trimAllWhitespace(this.basename)));
		}
		if (this.encoding != null) {
			messageSource.setDefaultEncoding(this.encoding.name());
		}
		messageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale);
		messageSource.setCacheSeconds(this.cacheSeconds);
		messageSource.setAlwaysUseMessageFormat(this.alwaysUseMessageFormat);
		return messageSource;
	}

</code></pre>
<p>3、对IDEA的编码进行设置</p>
<figure data-type="image" tabindex="15"><img src="https://stormga.github.io//post-images/17.encoding.jpg" alt="" loading="lazy"></figure>
<p>4、login进行标签插入</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;!-- saved from url=(0051)https://getbootstrap.com/docs/4.1/examples/sign-in/ --&gt;
&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;
    
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot; /&gt;
    &lt;meta name=&quot;description&quot; content=&quot;&quot; /&gt;
    &lt;meta name=&quot;author&quot; content=&quot;&quot; /&gt;
    &lt;link rel=&quot;icon&quot; href=&quot;https://getbootstrap.com/favicon.ico&quot; /&gt;

    &lt;title&gt;登录页面&lt;/title&gt;

    &lt;!-- Bootstrap core CSS --&gt;
    &lt;link href=&quot;#&quot; th:href=&quot;@{/css/bootstrap.min.css}&quot; rel=&quot;stylesheet&quot; /&gt;

    &lt;!-- Custom styles for this template --&gt;
    &lt;link href=&quot;./login_files/signin.css&quot; th:href=&quot;@{/css/signin.css}&quot; rel=&quot;stylesheet&quot; /&gt;
  &lt;/head&gt;

  &lt;body class=&quot;text-center&quot;&gt;
    &lt;form class=&quot;form-signin&quot;&gt;
      &lt;img class=&quot;mb-4&quot; src=&quot;./login_files/bootstrap-solid.svg&quot; th:src=&quot;@{/img/bootstrap-solid.svg}&quot; alt=&quot;&quot; width=&quot;72&quot; height=&quot;72&quot; /&gt;
      &lt;h1 class=&quot;h3 mb-3 font-weight-normal&quot; th:text=&quot;#{login.tip}&quot;&gt;Please sign in&lt;/h1&gt;
      &lt;label  class=&quot;sr-only&quot; th:text=&quot;#{login.username}&quot;&gt;Username&lt;/label&gt;
      &lt;input type=&quot;text&quot;  name=&quot;username&quot; class=&quot;form-control&quot; placeholder=&quot;Username&quot; th:placeholder=&quot;#{login.username}&quot; required=&quot;&quot; autofocus=&quot;&quot;/&gt;
      &lt;label for=&quot;inputPassword&quot; class=&quot;sr-only&quot; th:text=&quot;#{login.password}&quot;&gt;Password&lt;/label&gt;
      &lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;inputPassword&quot; class=&quot;form-control&quot; placeholder=&quot;Password&quot; th:placeholder=&quot;#{login.password}&quot; required=&quot;&quot; /&gt;
      &lt;div class=&quot;checkbox mb-3&quot;&gt;
        &lt;label&gt;
          &lt;input type=&quot;checkbox&quot; value=&quot;remember-me&quot; /&gt; [[#{login.remember}]]
        &lt;/label&gt;
      &lt;/div&gt;
      &lt;button class=&quot;btn btn-lg btn-primary btn-block&quot; type=&quot;submit&quot; th:text=&quot;#{login.btn}&quot;&gt;Sign in&lt;/button&gt;
      &lt;p class=&quot;mt-5 mb-3 text-muted&quot;&gt;© 2017-2018&lt;/p&gt;
    &lt;/form&gt;
  

&lt;/body&gt;&lt;/html&gt;

</code></pre>
<p>效果根据浏览器语言的信息切换国际化</p>
<p>原理：</p>
<p>国际化locale（区域信息对象）；LocaleResolver(获取区域对象)；</p>
<pre><code class="language-java">@Bean
@ConditionalOnMissingBean
@ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;locale&quot;)
public LocaleResolver localeResolver() {
    if (this.mvcProperties
        .getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) {
        return new FixedLocaleResolver(this.mvcProperties.getLocale());
    }
    AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver();
    localeResolver.setDefaultLocale(this.mvcProperties.getLocale());
    return localeResolver;
}            


</code></pre>
<p>默认的就是根据请求头带来的区域信息获取local国际化信息（截图就是这么犀利）</p>
<figure data-type="image" tabindex="16"><img src="https://stormga.github.io//post-images/18.accept-language.jpg" alt="" loading="lazy"></figure>
<h4 id="2-点击链接切换国际化">2、点击链接切换国际化</h4>
<p>自己编写localResolver，加到容器中</p>
<p>1、更改HTML代码</p>
<pre><code class="language-html">&lt;p class=&quot;mt-5 mb-3 text-muted&quot;&gt;© 2017-2018&lt;/p&gt;
  &lt;a href=&quot;#&quot; class=&quot;btn btn-sm&quot; th:href=&quot;@{/index.html?lg=zh_CN}&quot;&gt;中文&lt;/a&gt;
  &lt;a href=&quot;#&quot; class=&quot;btn btn-sm&quot; th:href=&quot;@{/index.html?lg=en_US}&quot;&gt;English&lt;/a&gt;

</code></pre>
<p>2、新建一个MyLocaleResolver.class</p>
<pre><code class="language-java">public class MyLocaleResolver implements LocaleResolver {

    //解析区域信息
    @Override
    public Locale resolveLocale(HttpServletRequest request) {
        String l = request.getParameter(&quot;lg&quot;);
        Locale locale = Locale.getDefault();
        if(!StringUtils.isEmpty(l)){
            String[] split = l.split(&quot;_&quot;);
            locale = new Locale(split[0], split[1]);
        }
        return locale;
    }

    @Override
    public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) {

    }
}

</code></pre>
<p>3、将MyLocaleResolver加入到容器中</p>
<pre><code class="language-java">@Bean
public LocaleResolver localeResolver(){
    return new MyLocalResolver();
}

</code></pre>
<p>4、启动演示</p>
<h3 id="3-登录拦截器">3、登录拦截器</h3>
<h4 id="1-登录">1、登录</h4>
<p>开发技巧</p>
<p>​	1、清除模板缓存</p>
<p>​	2、Ctrl+F9刷新</p>
<p>1、新建一个LoginController</p>
<pre><code class="language-java">@Controller
public class LoginController {

    @PostMapping(value =&quot;/user/login&quot;)
    public String login(@RequestParam(&quot;username&quot;)String username,
                        @RequestParam(&quot;password&quot;)String password,
                        Map&lt;String,Object&gt; map){
        if(!StringUtils.isEmpty(username) &amp;&amp; &quot;123456&quot;.equals(password)){
            //登录成功
            return &quot;list&quot;;
        }else{
            map.put(&quot;msg&quot;, &quot;用户名密码错误&quot;);
            return &quot;login&quot;;
        }

    }
}

</code></pre>
<p>2、登录错误消息显示</p>
<pre><code class="language-html">&lt;!--判断--&gt;
&lt;p style=&quot;color: red&quot; th:text=&quot;${msg}&quot; th:if=&quot;${not #strings.isEmpty(msg)}&quot;&gt;&lt;/p&gt;

</code></pre>
<p>3、表单重复提交</p>
<p>表单重复提交事件 --》重定向来到成功页面--》模板引擎解析</p>
<pre><code class="language-java">if(!StringUtils.isEmpty(username) &amp;&amp; &quot;123456&quot;.equals(password)){
    //登录成功,防止重复提交
    return &quot;redirect:/main.html&quot;;
}else{
    map.put(&quot;msg&quot;, &quot;用户名密码错误&quot;);
    return &quot;login&quot;;
}

</code></pre>
<p>模板引擎解析</p>
<pre><code class="language-java">@Override
public void addViewControllers(ViewControllerRegistry registry) {
    registry.addViewController(&quot;/&quot;).setViewName(&quot;login&quot;);
    registry.addViewController(&quot;/index.html&quot;).setViewName(&quot;login&quot;);
    registry.addViewController(&quot;/main.html&quot;).setViewName(&quot;Dashboard&quot;);
}

</code></pre>
<h3 id="4-拦截器">4、拦截器</h3>
<p>作用：实现权限控制，每个页面请求前中后，都会进入到拦截器进行处理（登录权限）</p>
<p>1、在component下新建一个LoginHandlerInterceptor拦截器</p>
<pre><code class="language-java">public class LoginHandlerInterceptor implements HandlerInterceptor {

    //目标方法执行之前
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        Object user = request.getSession().getAttribute(&quot;loginUser&quot;);
        if(user!=null){
            //已经登录
            return true;
        }
        //未经过验证
        request.setAttribute(&quot;msg&quot;, &quot;没权限请先登录&quot;);
        request.getRequestDispatcher(&quot;/index.html&quot;).forward(request, response);

        return false;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {

    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {

    }
}

</code></pre>
<p>2、在MyMvcConfig配置中重写拦截器方法，加入到容器中</p>
<pre><code class="language-java">//所有的webMvcConfigurerAdapter组件会一起起作用
@Bean //註冊到容器去
public WebMvcConfigurerAdapter webMvcConfigurerAdapter(){
    WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() {
        @Override
        public void addViewControllers(ViewControllerRegistry registry) {
            registry.addViewController(&quot;/&quot;).setViewName(&quot;login&quot;);
            registry.addViewController(&quot;/index.html&quot;).setViewName(&quot;login&quot;);
            registry.addViewController(&quot;/main.html&quot;).setViewName(&quot;Dashboard&quot;);
        }
        //注册拦截器
        @Override
        public void addInterceptors(InterceptorRegistry registry) {
            //静态资源 css js img 已经做好了静态资源映射
            registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns(&quot;/**&quot;).
                    excludePathPatterns(&quot;/index.html&quot;,&quot;/&quot;,&quot;/user/login&quot;);
        }
    };
    return adapter;
}

</code></pre>
<p>3、在LoginHandler中添加登录成功写入session</p>
<pre><code class="language-java">@Controller
public class LoginController {

    @PostMapping(value =&quot;/user/login&quot;)
    public String login(@RequestParam(&quot;username&quot;)String username,
                        @RequestParam(&quot;password&quot;)String password,
                        Map&lt;String,Object&gt; map,
                        HttpSession session){
        if(!StringUtils.isEmpty(username) &amp;&amp; &quot;123456&quot;.equals(password)){
            //登录成功,防止重复提交
            session.setAttribute(&quot;loginUser&quot;, username);
            return &quot;redirect:/main.html&quot;;
        }else{
            map.put(&quot;msg&quot;, &quot;用户名密码错误&quot;);
            return &quot;login&quot;;
        }

    }
}

</code></pre>
<h3 id="5-crud-员工列表">5、CRUD-员工列表</h3>
<p>实验要求：</p>
<p>1）、RestfulCRUD：CRUD满足Rest风格</p>
<p>URI:/资源名称/资源标识+HTTP操作</p>
<table>
<thead>
<tr>
<th></th>
<th>普通CRUD</th>
<th>RestfulCRUD</th>
</tr>
</thead>
<tbody>
<tr>
<td>查询</td>
<td>getEmp</td>
<td>emp -- GET</td>
</tr>
<tr>
<td>添加</td>
<td>addEmp?xxx</td>
<td>emp --POST</td>
</tr>
<tr>
<td>修改</td>
<td>updateEmp?id=xxx&amp;xxx=xx</td>
<td>emp/{id} -- PUT</td>
</tr>
<tr>
<td>删除</td>
<td>deleteEmp?id=1</td>
<td>emp/{id} --DELETE</td>
</tr>
</tbody>
</table>
<p>2、实验的请求架构</p>
<table>
<thead>
<tr>
<th></th>
<th>请求URI</th>
<th>请求方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>查询所有员工</td>
<td>emps</td>
<td>GET</td>
</tr>
<tr>
<td>查询某个员工</td>
<td>emp/{id}</td>
<td>GET</td>
</tr>
<tr>
<td>添加页面</td>
<td>emp</td>
<td>GET</td>
</tr>
<tr>
<td>添加员工</td>
<td>emp</td>
<td>POST</td>
</tr>
<tr>
<td>修改页面(回显)</td>
<td>emp/{id}</td>
<td>GET</td>
</tr>
<tr>
<td>修改员工</td>
<td>emp/{id}</td>
<td>PUT</td>
</tr>
<tr>
<td>删除员工</td>
<td>emp/{id}</td>
<td>DELETE</td>
</tr>
</tbody>
</table>
<p>3、员工列表</p>
<h4 id="1-公共页面抽取">1、公共页面抽取</h4>
<p>使用方法</p>
<pre><code class="language-html">1、抽取公共片段
&lt;!--footer.html--&gt;
&lt;div id=&quot;footid&quot; th:fragment=&quot;copy&quot;&gt;xxx&lt;/div&gt;
2、引入公共片段
&lt;!--test.html--&gt;
&lt;div th:insert=~{footer::copy}&gt;&lt;/div&gt;
~{templatename::selector} 模板名::选择器  footer::#footid
~{templatename::fragmentname} 模板名::片段名称 footer::copy
行内写法可以加~{xx::xx} 标签体可以 xx::xx

</code></pre>
<p><strong>三种引用方式</strong></p>
<p><strong>th:insert</strong> :加个外层标签 +1</p>
<p><strong>th:replace</strong> :完全替换 1</p>
<p><strong>th:include</strong>：就替换里面的内容 -1</p>
<p>公共页面</p>
<pre><code class="language-html">&lt;body&gt;
	...
    &lt;div th:insert=&quot;footer :: copy&quot;&gt;&lt;/div&gt;
    &lt;div th:replace=&quot;footer :: copy&quot;&gt;&lt;/div&gt;
    &lt;div th:include=&quot;footer :: copy&quot;&gt;&lt;/div&gt;
&lt;/body&gt;

</code></pre>
<p>结果</p>
<pre><code class="language-html">&lt;body&gt;
...
    &lt;!-- th:insert --&gt;
    &lt;div&gt;
        &lt;footer&gt;
            &amp;copy; 2011 The Good Thymes Virtual Grocery
        &lt;/footer&gt;
    &lt;/div&gt;
    &lt;!--th:replace--&gt;
    &lt;footer&gt;
   		&amp;copy; 2011 The Good Thymes Virtual Grocery
    &lt;/footer&gt;
    &lt;!--th:include--&gt;
    &lt;div&gt;
        &amp;copy; 2011 The Good Thymes Virtual Grocery
    &lt;/div&gt;
&lt;/body&gt;

</code></pre>
<p>用此种方法将公共页面引入</p>
<h4 id="2-列表高亮">2、列表高亮</h4>
<p>引入片段的时候传入参数，新建一个commons文件夹存储公共页面bar.html</p>
<p>模板引入变量名</p>
<p>dashboard</p>
<pre><code class="language-html">&lt;a class=&quot;nav-link active&quot;
   th:class=&quot;${activeUri}=='main.html'?'nav-link active':'nav-link'&quot;
   href=&quot;https://getbootstrap.com/docs/4.1/examples/dashboard/#&quot; th:href=&quot;@{/main.html}&quot;&gt;
    &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; stroke-width=&quot;2&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; class=&quot;feather feather-home&quot;&gt;&lt;path d=&quot;M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z&quot;&gt;&lt;/path&gt;&lt;polyline points=&quot;9 22 9 12 15 12 15 22&quot;&gt;&lt;/polyline&gt;&lt;/svg&gt;
    Dashboard &lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt;
&lt;/a&gt;

</code></pre>
<p>员工管理</p>
<pre><code class="language-html">&lt;li class=&quot;nav-item&quot;&gt;
    &lt;a class=&quot;nav-link&quot;
       th:class=&quot;${activeUri}=='emps'?'nav-link active':'nav-link'&quot;
       href=&quot;https://getbootstrap.com/docs/4.1/examples/dashboard/#&quot; th:href=&quot;@{/emps}&quot;&gt;
        &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; stroke-width=&quot;2&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; class=&quot;feather feather-users&quot;&gt;&lt;path d=&quot;M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2&quot;&gt;&lt;/path&gt;&lt;circle cx=&quot;9&quot; cy=&quot;7&quot; r=&quot;4&quot;&gt;&lt;/circle&gt;&lt;path d=&quot;M23 21v-2a4 4 0 0 0-3-3.87&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M16 3.13a4 4 0 0 1 0 7.75&quot;&gt;&lt;/path&gt;&lt;/svg&gt;
        员工管理
    &lt;/a&gt;

</code></pre>
<p>引入模板的时候传入参数</p>
<p>dashboard.html引入</p>
<pre><code class="language-html">&lt;!--引入侧边栏--&gt;
   &lt;div th:replace=&quot;commons/bar :: sidebar(activeUri='main.html')&quot;&gt;&lt;/div&gt;

</code></pre>
<p>list.html引入</p>
<pre><code class="language-html">&lt;!--引入侧边栏--&gt;
&lt;div th:replace=&quot;commons/bar::sidebar(activeUri='emps')&quot;&gt;&lt;/div&gt;

</code></pre>
<h3 id="6-列表数据显示查">6、列表数据显示（查）</h3>
<h4 id="1-传入员工对象">1、传入员工对象</h4>
<p>EmployeeController类,传入员工对象</p>
<pre><code class="language-java">@Controller
public class EmployeeController {

    @Autowired
    EmployeeDao employeeDao;
    /**
     * 查询所有员工返回列表页面
     */
    @GetMapping(value = &quot;/emps&quot;)
    public String list(Model model){

        Collection&lt;Employee&gt; employees = employeeDao.getAll();
        model.addAttribute(&quot;emps&quot;,employees);
        return &quot;emp/list&quot;;
    }
}

</code></pre>
<h4 id="2-遍历对象">2、 遍历对象</h4>
<p>list.html中 使用模板的 <code>th:each</code>方法</p>
<pre><code class="language-html">table class=&quot;table table-striped table-sm&quot;&gt;
    &lt;thead&gt;
    &lt;tr&gt;
        &lt;th&gt;#&lt;/th&gt;
        &lt;th&gt;lastName&lt;/th&gt;
        &lt;th&gt;email&lt;/th&gt;
        &lt;th&gt;gender&lt;/th&gt;
        &lt;th&gt;department&lt;/th&gt;
        &lt;th&gt;birth&lt;/th&gt;
        &lt;th&gt;操作&lt;/th&gt;
    &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr th:each=&quot;emp:${emps}&quot;&gt;
            &lt;td th:text=&quot;${emp.id}&quot;&gt;1&lt;/td&gt;
            &lt;td th:text=&quot;${emp.lastName}&quot;&gt;1&lt;/td&gt;
            &lt;td th:text=&quot;${emp.email}&quot;&gt;1&lt;/td&gt;
            &lt;td th:text=&quot;${emp.gender}&quot;&gt;1&lt;/td&gt;
            &lt;td th:text=&quot;${emp.department.departmentName}&quot;&gt;1&lt;/td&gt;
            &lt;td th:text=&quot;${#dates.format(emp.birth,'yyyy-MM-dd HH:mm:ss')}&quot;&gt;1&lt;/td&gt;
            &lt;td&gt;
                &lt;button class=&quot;btn btn-sm btn-primary&quot;&gt;编辑&lt;/button&gt;
                &lt;button class=&quot;btn btn-sm btn-danger&quot;&gt;删除&lt;/button&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;

</code></pre>
<h4 id="3-效果显示">3、效果显示</h4>
<p>![](https://stormga.github.io//post-images/19.table list.jpg)</p>
<h3 id="7-员工添加增">7、员工添加（增）</h3>
<p>功能：点击添加按钮，出现新增页面</p>
<h4 id="1-新增页面">1、新增页面</h4>
<pre><code class="language-html">&lt;form&gt;
    &lt;!-- LastName --&gt;
    &lt;div class=&quot;form-group&quot;&gt;
        &lt;label for=&quot;LastName&quot;&gt;LastName&lt;/label&gt;
        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;LastName&quot;  placeholder=&quot;LastName&quot;&gt;
    &lt;/div&gt;
    &lt;!-- Email --&gt;
    &lt;div class=&quot;form-group&quot;&gt;
        &lt;label for=&quot;Email&quot;&gt;Email&lt;/label&gt;
        &lt;input type=&quot;email&quot; class=&quot;form-control&quot; id=&quot;Email&quot;  placeholder=&quot;zhangsan@163.com&quot;&gt;
    &lt;/div&gt;
    &lt;!--gender--&gt;
    &lt;div class=&quot;form-group&quot;&gt;
        &lt;label &gt;Gender&lt;/label&gt;&lt;br/&gt;
        &lt;div class=&quot;form-check form-check-inline&quot;&gt;
            &lt;input class=&quot;form-check-input&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot;&gt;
            &lt;label class=&quot;form-check-label&quot; &gt;男&lt;/label&gt;
        &lt;/div&gt;
        &lt;div class=&quot;form-check form-check-inline&quot;&gt;
            &lt;input class=&quot;form-check-input&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot;&gt;
            &lt;label class=&quot;form-check-label&quot; &gt;女&lt;/label&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;!-- department --&gt;
    &lt;div class=&quot;form-group&quot;&gt;
        &lt;label for=&quot;exampleFormControlSelect1&quot;&gt;department&lt;/label&gt;
        &lt;select class=&quot;form-control&quot; id=&quot;exampleFormControlSelect1&quot;&gt;
            &lt;option th:each=&quot;dept:${depts}&quot; th:value=&quot;${dept.id}&quot; th:text=&quot;${dept.departmentName}&quot;&gt;&lt;/option&gt;
        &lt;/select&gt;
    &lt;/div&gt;
    &lt;!--Birth--&gt;
    &lt;div class=&quot;form-group&quot;&gt;
        &lt;label for=&quot;birthDate&quot;&gt;Birth&lt;/label&gt;
        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;birthDate&quot; placeholder=&quot;2012-12-12&quot;&gt;
    &lt;/div&gt;
    &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;添 加&lt;/button&gt;
&lt;/form&gt;

</code></pre>
<h4 id="2-页面跳转">2、页面跳转</h4>
<p>在EmployeeController中添加addEmpPage方法</p>
<pre><code class="language-java">/**
 * 添加员工
 */
@GetMapping(value = &quot;/emp&quot;)
public String toAddPage(Model model){
    //来到添加页面,查出所有部门显示
    Collection&lt;Department&gt; depts = departmentDao.getDepartments();
    model.addAttribute(&quot;depts&quot;,depts);
    return &quot;emp/add&quot;;
}

</code></pre>
<p>关键点：在添加部门页面要遍历部门信息，所以在方法中出入部门信息</p>
<h4 id="3-添加功能完成">3、添加功能完成</h4>
<p>新建一个PostMapping</p>
<blockquote>
<p>ThymeleafViewResolver 查看redirect和forward,原生的sendredirect方法；</p>
</blockquote>
<p>1、新建一个postMapping的方法用来接受页面的添加POST请求</p>
<pre><code class="language-java">/**
 * 员工添加
 */
@PostMapping(value = &quot;/emp&quot;)
public String addEmp(Employee employee){

    employeeDao.save(employee);
    //来到员工列表页面、redirect:重定向到一个地址，forward转发到一个地址
    return &quot;redirect:/emps&quot;;
}

</code></pre>
<p>2、修改添加页面，添加name属性</p>
<pre><code class="language-html">&lt;form th:action=&quot;@{/emp}&quot; method=&quot;post&quot;&gt;
    &lt;!-- LastName --&gt;
    &lt;div class=&quot;form-group&quot;&gt;
        &lt;label for=&quot;LastName&quot;&gt;LastName&lt;/label&gt;
        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;LastName&quot; name=&quot;lastName&quot; placeholder=&quot;LastName&quot;&gt;
    &lt;/div&gt;
    &lt;!-- Email --&gt;
    &lt;div class=&quot;form-group&quot;&gt;
        &lt;label for=&quot;Email&quot;&gt;Email&lt;/label&gt;
        &lt;input type=&quot;email&quot; class=&quot;form-control&quot; id=&quot;Email&quot;  name=&quot;email&quot; placeholder=&quot;zhangsan@163.com&quot;&gt;
    &lt;/div&gt;
    &lt;!--gender--&gt;
    &lt;div class=&quot;form-group&quot;&gt;
        &lt;label &gt;Gender&lt;/label&gt;&lt;br/&gt;
        &lt;div class=&quot;form-check form-check-inline&quot;&gt;
            &lt;input class=&quot;form-check-input&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot;&gt;
            &lt;label class=&quot;form-check-label&quot; &gt;男&lt;/label&gt;
        &lt;/div&gt;
        &lt;div class=&quot;form-check form-check-inline&quot;&gt;
            &lt;input class=&quot;form-check-input&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot;&gt;
            &lt;label class=&quot;form-check-label&quot; &gt;女&lt;/label&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;!-- department --&gt;
    &lt;div class=&quot;form-group&quot;&gt;
        &lt;label &gt;department&lt;/label&gt;
        &lt;select class=&quot;form-control&quot;  name=&quot;department.id&quot;&gt;
            &lt;option th:each=&quot;dept:${depts}&quot; th:value=&quot;${dept.id}&quot; th:text=&quot;${dept.departmentName}&quot;&gt;&lt;/option&gt;
        &lt;/select&gt;
    &lt;/div&gt;
    &lt;div class=&quot;form-group&quot;&gt;
        &lt;label for=&quot;birthDate&quot;&gt;Birth&lt;/label&gt;
        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;birthDate&quot; placeholder=&quot;2012-12-12&quot; name=&quot;birth&quot;&gt;
    &lt;/div&gt;
    &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;添 加&lt;/button&gt;
&lt;/form&gt;

</code></pre>
<p>1、部门对象问题？</p>
<pre><code class="language-html">&lt;select class=&quot;form-control&quot;  name=&quot;department.id&quot;&gt;

</code></pre>
<p>2、日期格式化？</p>
<p>属性中添加 date-formate 默认是 /</p>
<pre><code class="language-java">@Bean
@ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;date-format&quot;)
public Formatter&lt;Date&gt; dateFormatter() {
   return new DateFormatter(this.mvcProperties.getDateFormat());
}

@Override
public MessageCodesResolver getMessageCodesResolver() {
   if (this.mvcProperties.getMessageCodesResolverFormat() != null) {
      DefaultMessageCodesResolver resolver = new DefaultMessageCodesResolver();
      resolver.setMessageCodeFormatter(
            this.mvcProperties.getMessageCodesResolverFormat());
      return resolver;
   }
   return null;
}

</code></pre>
<pre><code class="language-properties">spring.mvc.date-format=yyyy-MM-dd

</code></pre>
<h3 id="8-员工编辑改">8、员工编辑（改）</h3>
<p>思路使用add页面，并且数据回显，然后区分添加，PUT请求</p>
<h4 id="1-修改按钮">1、修改按钮</h4>
<p>在list.html的<code>编辑</code>按钮加上链接</p>
<pre><code class="language-html">&lt;td&gt;
    &lt;a  href=&quot;#&quot; th:href=&quot;@{/emp/}+${emp.id}&quot; class=&quot;btn btn-sm btn-primary&quot;&gt;编辑&lt;/a&gt;
    &lt;button class=&quot;btn btn-sm btn-danger&quot;&gt;删除&lt;/button&gt;
&lt;/td&gt;

</code></pre>
<h4 id="2-编写跳转页面">2、编写跳转页面</h4>
<p>跳转到员工编辑页面的Controller</p>
<pre><code class="language-java">/**
 * 员工编辑页面
 */
@GetMapping(value = &quot;/emp/{id}&quot;)
public String toEditPage(@PathVariable(&quot;id&quot;) Integer id ,Model model){
    Employee emp = employeeDao.getEmpById(id);
    Collection&lt;Department&gt; departments = departmentDao.getDepartments();
    model.addAttribute(&quot;emp&quot;,emp);
    model.addAttribute(&quot;depts&quot;,departments);
    return &quot;emp/add&quot;;
}
   

</code></pre>
<h4 id="3-对页面修改">3、对页面修改</h4>
<p>对add页面进行修改</p>
<p>1）、添加回显</p>
<p>2）、添加判断是否emp!=null（区分add or edit）</p>
<p>3）、添加put请求 --两个input的hidden标签</p>
<pre><code class="language-html"> &lt;form th:action=&quot;@{/emp}&quot; method=&quot;post&quot;&gt;
        &lt;!--发送put请求--&gt;
        &lt;!--1.SpringMVC配置HiddenHttpMethodFilter
            2.页面创建一个post表单
            3.创建一个 input name_method 值就是我们请求的方式--&gt;
        &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;put&quot; th:if=&quot;${emp!=null}&quot;&gt;

        &lt;input type=&quot;hidden&quot; name=&quot;id&quot; th:value=&quot;${emp.id}&quot; th:if=&quot;${emp!=null}&quot;&gt;
        &lt;!-- LastName --&gt;
        &lt;div class=&quot;form-group&quot;&gt;
            &lt;label for=&quot;LastName&quot;&gt;LastName&lt;/label&gt;
            &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;LastName&quot; name=&quot;lastName&quot; placeholder=&quot;LastName&quot; th:value=&quot;${emp!=null}?${emp.lastName}&quot;&gt;
        &lt;/div&gt;
        &lt;!-- Email --&gt;
        &lt;div class=&quot;form-group&quot;&gt;
            &lt;label for=&quot;Email&quot;&gt;Email&lt;/label&gt;
            &lt;input type=&quot;email&quot; class=&quot;form-control&quot; id=&quot;Email&quot;  name=&quot;email&quot; placeholder=&quot;zhangsan@163.com&quot; th:value=&quot;${emp!=null}?${emp.email}&quot;&gt;
        &lt;/div&gt;
        &lt;!--gender--&gt;
        &lt;div class=&quot;form-group&quot;&gt;
            &lt;label &gt;Gender&lt;/label&gt;&lt;br/&gt;
            &lt;div class=&quot;form-check form-check-inline&quot;&gt;
                &lt;input class=&quot;form-check-input&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot; th:checked=&quot;${emp!=null}?${emp.gender}==1&quot;&gt;
                &lt;label class=&quot;form-check-label&quot; &gt;男&lt;/label&gt;
            &lt;/div&gt;
            &lt;div class=&quot;form-check form-check-inline&quot;&gt;
                &lt;input class=&quot;form-check-input&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot; th:checked=&quot;${emp!=null}?${emp.gender}==0&quot;&gt;
                &lt;label class=&quot;form-check-label&quot; &gt;女&lt;/label&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;!-- department --&gt;
        &lt;div class=&quot;form-group&quot;&gt;
            &lt;label &gt;department&lt;/label&gt;
            &lt;select class=&quot;form-control&quot;  name=&quot;department.id&quot; &gt;
                &lt;option th:selected=&quot;${emp!=null}?${dept.id == emp.department.id}&quot; th:each=&quot;dept:${depts}&quot; th:value=&quot;${dept.id}&quot; th:text=&quot;${dept.departmentName}&quot;&gt;&lt;/option&gt;
            &lt;/select&gt;
        &lt;/div&gt;
        &lt;div class=&quot;form-group&quot;&gt;
            &lt;label for=&quot;birthDate&quot;&gt;Birth&lt;/label&gt;
            &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;birthDate&quot; placeholder=&quot;2012-12-12&quot; name=&quot;birth&quot; th:value=&quot;${emp!=null}?${#dates.format(emp.birth,'yyyy-MM-dd HH:mm:ss')}&quot;&gt;
        &lt;/div&gt;
        &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot; th:text=&quot;${emp!=null}?'修改':'添加'&quot;&gt;添 加&lt;/button&gt;
    &lt;/form&gt;
&lt;/main&gt;

</code></pre>
<h3 id="9-员工删除删">9、员工删除（删）</h3>
<h4 id="1-新建contoller">1、新建Contoller</h4>
<pre><code class="language-java">/**
 * 员工删除
 */
@DeleteMapping(value = &quot;/emp/{id}&quot;)
public String deleteEmp(@PathVariable(&quot;id&quot;) Integer id){
    employeeDao.deleteEmpById(id);
    return &quot;redirect:/emps&quot;;
}

</code></pre>
<h4 id="2-修改删除标签">2、修改删除标签</h4>
<pre><code class="language-html">&lt;button th:attr=&quot;del_uri=@{/emp/}+${emp.id}&quot;  class=&quot;btn btn-sm btn-danger deleteBtn&quot;&gt;
    删除
&lt;/button&gt;

</code></pre>
<h4 id="3-写form表单">3、写Form表单</h4>
<p>form表单卸载外面，input 中 name=&quot;_method&quot; value=&quot;delete&quot; 模拟delete请求</p>
<pre><code class="language-html">                &lt;/tbody&gt;
            &lt;/table&gt;
        &lt;/div&gt;
    &lt;/main&gt;
    &lt;form id=&quot;deleteEmpForm&quot; method=&quot;post&quot;&gt;
        &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;delete&quot;&gt;
    &lt;/form&gt;
&lt;/div&gt;

</code></pre>
<h4 id="4-写js提交">4、写JS提交</h4>
<pre><code class="language-javascript">&lt;script&gt;
    $(&quot;.deleteBtn&quot;).click(function () {
        $(&quot;#deleteEmpForm&quot;).attr(&quot;action&quot;,$(this).attr(&quot;del_uri&quot;)).submit();
        return false;
    })
&lt;/script&gt;

</code></pre>
<blockquote>
<p>return false;禁用btn提交效果</p>
</blockquote>
<h2 id="7-错误机制的处理">7、错误机制的处理</h2>
<h3 id="1-默认的错误处理机制">1、默认的错误处理机制</h3>
<p>默认错误页面</p>
<figure data-type="image" tabindex="17"><img src="https://stormga.github.io//post-images/20.error.jpg" alt="" loading="lazy"></figure>
<p>原理参照</p>
<p>ErrorMvcAutoConfiguration:错误处理的自动配置</p>
<pre><code>org\springframework\boot\spring-boot-autoconfigure\1.5.12.RELEASE\spring-boot-autoconfigure-1.5.12.RELEASE.jar!\org\springframework\boot\autoconfigure\web\ErrorMvcAutoConfiguration.class


</code></pre>
<ul>
<li>
<p>DefaultErrorAttributes</p>
<p>帮我们在页面共享信息</p>
<pre><code class="language-java">@Override
public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes,
      boolean includeStackTrace) {
   Map&lt;String, Object&gt; errorAttributes = new LinkedHashMap&lt;String, Object&gt;();
   errorAttributes.put(&quot;timestamp&quot;, new Date());
   addStatus(errorAttributes, requestAttributes);
   addErrorDetails(errorAttributes, requestAttributes, includeStackTrace);
   addPath(errorAttributes, requestAttributes);
   return errorAttributes;
}

</code></pre>
</li>
<li>
<p>BasicErrorController</p>
<pre><code class="language-java">@Controller
@RequestMapping(&quot;${server.error.path:${error.path:/error}}&quot;)
public class BasicErrorController extends AbstractErrorController {
    //产生HTML数据
    @RequestMapping(produces = &quot;text/html&quot;)
	public ModelAndView errorHtml(HttpServletRequest request,
			HttpServletResponse response) {
		HttpStatus status = getStatus(request);
		Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes(
				request, isIncludeStackTrace(request, MediaType.TEXT_HTML)));
		response.setStatus(status.value());
		ModelAndView modelAndView = resolveErrorView(request, response, status, model);
		return (modelAndView == null ? new ModelAndView(&quot;error&quot;, model) : modelAndView);
	}
	//产生Json数据
	@RequestMapping
	@ResponseBody
	public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) {
		Map&lt;String, Object&gt; body = getErrorAttributes(request,
				isIncludeStackTrace(request, MediaType.ALL));
		HttpStatus status = getStatus(request);
		return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status);
	}

</code></pre>
</li>
<li>
<p>ErrorPageCustomizer</p>
<pre><code class="language-java">@Value(&quot;${error.path:/error}&quot;)
private String path = &quot;/error&quot;;//系统出现错误以后来到error请求进行处理，(web.xml)

</code></pre>
</li>
<li>
<p>DefaultErrorViewResolver</p>
<pre><code class="language-java">@Override
public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status,
      Map&lt;String, Object&gt; model) {
   ModelAndView modelAndView = resolve(String.valueOf(status), model);
   if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) {
      modelAndView = resolve(SERIES_VIEWS.get(status.series()), model);
   }
   return modelAndView;
}

private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) {
    //默认SpringBoot可以找到一个页面？error/状态码
   String errorViewName = &quot;error/&quot; + viewName;
    //如果模板引擎可以解析地址，就返回模板引擎解析
   TemplateAvailabilityProvider provider = this.templateAvailabilityProviders
         .getProvider(errorViewName, this.applicationContext);
   if (provider != null) {
       //有模板引擎就返回到errorViewName指定的视图地址
      return new ModelAndView(errorViewName, model);
   }
    //自己的文件 就在静态文件夹下找静态文件 /静态资源文件夹/404.html
   return resolveResource(errorViewName, model);
}

</code></pre>
</li>
</ul>
<p>一旦系统出现4xx或者5xx错误 ErrorPageCustomizer就回来定制错误的响应规则,就会来到 /error请求,BasicErrorController处理，就是一个Controller</p>
<p>1.响应页面,去哪个页面是由 DefaultErrorViewResolver 拿到所有的错误视图</p>
<pre><code class="language-java">protected ModelAndView resolveErrorView(HttpServletRequest request,
      HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model) {
   for (ErrorViewResolver resolver : this.errorViewResolvers) {
      ModelAndView modelAndView = resolver.resolveErrorView(request, status, model);
      if (modelAndView != null) {
         return modelAndView;
      }
   }
   return null;
}

</code></pre>
<p>l浏览器发送请求 accpt:text/html</p>
<p>客户端请求：accept:/*</p>
<h3 id="2-如何定制错误响应">2、如何定制错误响应</h3>
<p>​	1）、如何定制错误的页面</p>
<p>​		1.有模板引擎：静态资源/404.html,什么错误什么页面；所有以4开头的 4xx.html 5开头的5xx.html</p>
<p>​		有精确的404和4xx优先选择404</p>
<p>​		页面获得的数据</p>
<p>​			timestamp：时间戳</p>
<p>​			status：状态码</p>
<p>​			error：错误提示</p>
<p>​			exception：异常对象</p>
<p>​			message：异常信息</p>
<p>​			errors:JSR303有关</p>
<p>​		2.没有放在模板引擎，放在静态文件夹，也可以显示，就是没法使用模板取值</p>
<p>​		3.没有放模板引擎，没放静态，会显示默认的错误</p>
<p>​	2）、如何定义错误的数据</p>
<p>举例子：新建4xx和5xx文件</p>
<figure data-type="image" tabindex="18"><img src="https://stormga.github.io//post-images/21.error-static.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-html">&lt;body &gt;
    &lt;p&gt;status: [[${status}]]&lt;/p&gt;
    &lt;p&gt;timestamp: [[${timestamp}]]&lt;/p&gt;
    &lt;p&gt;error: [[${error}]]&lt;/p&gt;
    &lt;p&gt;message: [[${message}]]&lt;/p&gt;
    &lt;p&gt;exception: [[${exception}]]&lt;/p&gt;
&lt;/body&gt;

</code></pre>
<figure data-type="image" tabindex="19"><img src="https://stormga.github.io//post-images/22.4xxhtml.jpg" alt="" loading="lazy"></figure>
<h3 id="3-如何定制json数据">3、如何定制Json数据</h3>
<h4 id="1-仅发送json数据">1、仅发送json数据</h4>
<pre><code class="language-java">public class UserNotExitsException extends  RuntimeException {
    public UserNotExitsException(){
        super(&quot;用户不存在&quot;);
    }
}

</code></pre>
<pre><code class="language-java">/**
 * 异常处理器
 */
@ControllerAdvice
public class MyExceptionHandler {

    @ResponseBody
    @ExceptionHandler(UserNotExitsException.class)
    public Map&lt;String ,Object&gt; handlerException(Exception e){
        Map&lt;String ,Object&gt; map =new HashMap&lt;&gt;();
        map.put(&quot;code&quot;, &quot;user not exist&quot;);
        map.put(&quot;message&quot;, e.getMessage());
        return map;
    }
}

</code></pre>
<p>无法自适应 都是返回的json数据</p>
<h4 id="2-转发到error自适应处理">2、转发到error自适应处理</h4>
<pre><code class="language-java">@ExceptionHandler(UserNotExitsException.class)
public String handlerException(Exception e, HttpServletRequest request){
    Map&lt;String ,Object&gt; map =new HashMap&lt;&gt;();
    //传入自己的状态码
    request.setAttribute(&quot;javax.servlet.error.status_code&quot;, 432);
    map.put(&quot;code&quot;, &quot;user not exist&quot;);
    map.put(&quot;message&quot;, e.getMessage());
    //转发到error
    return &quot;forward:/error&quot;;
}

</code></pre>
<p>程序默认获取状态码</p>
<pre><code class="language-java">protected HttpStatus getStatus(HttpServletRequest request) {
   Integer statusCode = (Integer) request
         .getAttribute(&quot;javax.servlet.error.status_code&quot;);
   if (statusCode == null) {
      return HttpStatus.INTERNAL_SERVER_ERROR;
   }
   try {
      return HttpStatus.valueOf(statusCode);
   }
   catch (Exception ex) {
      return HttpStatus.INTERNAL_SERVER_ERROR;
   }

</code></pre>
<p>没有自己写的自定义异常数据</p>
<h4 id="3-自适应和定制数据传入">3、自适应和定制数据传入</h4>
<p>Spring 默认的原理，出现错误后回来到error请求，会被BasicErrorController处理,响应出去的数据是由BasicErrorController的父类AbstractErrorController(ErrorController)规定的方法getAttributes得到的；</p>
<p>1、编写一个ErrorController的实现类【或者AbstractErrorController的子类】，放在容器中；</p>
<p>2、页面上能用的数据，或者是json数据返回能用的数据都是通过errorAttributes.getErrorAttributes得到；</p>
<p>容器中的DefaultErrorAtrributes.getErrorAtrributees();默认进行数据处理</p>
<pre><code class="language-java">public class MyErrorAttributes extends DefaultErrorAttributes {
    @Override
    public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) {
        Map&lt;String, Object&gt; map = super.getErrorAttributes(requestAttributes, includeStackTrace);
        map.put(&quot;company&quot;, &quot;wdjr&quot;);
        return map;
    }
}

</code></pre>
<p>异常处理：把map方法请求域中</p>
<pre><code class="language-java">    @ExceptionHandler(UserNotExitsException.class)
    public String handlerException(Exception e, HttpServletRequest request){
        Map&lt;String ,Object&gt; map =new HashMap&lt;&gt;();
        //传入自己的状态码
        request.setAttribute(&quot;javax.servlet.error.status_code&quot;, 432);
        map.put(&quot;code&quot;, &quot;user not exist&quot;);
        map.put(&quot;message&quot;, e.getMessage());
        request.setAttribute(&quot;ext&quot;, map);
        //转发到error
        return &quot;forward:/error&quot;;
    }
}

</code></pre>
<p>在上面的MyErrorAttributes类中加上</p>
<pre><code class="language-java">//我们的异常处理器
Map&lt;String,Object&gt; ext = (Map&lt;String, Object&gt;) requestAttributes.getAttribute(&quot;ext&quot;, 0);
map.put(&quot;ext&quot;, ext);

</code></pre>
<h2 id="8-配置嵌入式servlet容器">8、配置嵌入式servlet容器</h2>
<h3 id="1-定制和修改servlet容器">1、定制和修改Servlet容器</h3>
<p>SpringBoot默认使用Tomcat作为嵌入式的Servlet容器；</p>
<p>![](https://stormga.github.io//post-images/23.tomcat emd.jpg)</p>
<p>问题？</p>
<p>1）、如何定制和修改Servlet容器；</p>
<p>1、 修改Server相关的配置文件 application.properties</p>
<pre><code class="language-properties">#通用的servlet容器配置
server.xxx
#tomcat的配置
server.tomcat.xxxx

</code></pre>
<p>2、编写一个EmbeddedServletContainerCustomizer;嵌入式的Servlet容器的定制器；来修改Servlet的容器配置</p>
<pre><code class="language-java">@Bean
public EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer(){
    return new EmbeddedServletContainerCustomizer() {
        //定制嵌入式Servlet的容器相关规则
        @Override
        public void customize(ConfigurableEmbeddedServletContainer container) {
            container.setPort(8999);
        }
    };
}

</code></pre>
<p>其实同理，都是实现EmbeddedServletContainerCustomizer</p>
<h3 id="2-注册servlet三大组件">2、注册Servlet三大组件</h3>
<p>三大组件 Servlet Filter Listener</p>
<p>由于SprringBoot默认是以jar包启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml</p>
<p>注册三大组件</p>
<h4 id="servletregistrationbean">ServletRegistrationBean</h4>
<pre><code class="language-java">@Bean
public ServletRegistrationBean myServlet(){
    ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean(new MyServlet(),&quot;/servlet&quot;);
    return servletRegistrationBean;
}

</code></pre>
<p>MyServlet</p>
<pre><code class="language-java">public class MyServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.getWriter().write(&quot;Hello Servlet&quot;);
    }
}

</code></pre>
<h4 id="filterregistrationbean">FilterRegistrationBean</h4>
<pre><code class="language-java">@Bean
public FilterRegistrationBean myFilter(){
    FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean();
    filterRegistrationBean.setFilter(new MyFilter());
    filterRegistrationBean.setUrlPatterns(Arrays.asList(&quot;/hello&quot;,&quot;/myServlet&quot;));
    return filterRegistrationBean;
}

</code></pre>
<p>MyFilter</p>
<pre><code class="language-java">public class MyFilter implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        System.out.println(&quot;MyFilter process&quot;);
        chain.doFilter(request, response);
    }

    @Override
    public void destroy() {

    }
}

</code></pre>
<h4 id="servletlistenerregistrationbean">ServletListenerRegistrationBean</h4>
<pre><code class="language-java">@Bean
public ServletListenerRegistrationBean myListener(){
    ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean = new ServletListenerRegistrationBean&lt;&gt;(new MyListener());
    return registrationBean;
}

</code></pre>
<p>MyListener</p>
<pre><code class="language-java">public class MyListener implements ServletContextListener {
    @Override
    public void contextInitialized(ServletContextEvent sce) {
        System.out.println(&quot;.........web应用启动..........&quot;);
    }

    @Override
    public void contextDestroyed(ServletContextEvent sce) {
        System.out.println(&quot;.........web应用销毁..........&quot;);
    }
}

</code></pre>
<p>SpringBoot帮助我们自动配置SpringMVC的时候，自动注册SpringMVC的前端控制器；DispatcherServlet;</p>
<pre><code class="language-java">@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)
@ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)
   public ServletRegistrationBean dispatcherServletRegistration(
         DispatcherServlet dispatcherServlet) {
      ServletRegistrationBean registration = new ServletRegistrationBean(
            dispatcherServlet, this.serverProperties.getServletMapping());
       //默认拦截 /所有请求 包括静态资源 不包括jsp
       //可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径
      registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME);
      registration.setLoadOnStartup(
            this.webMvcProperties.getServlet().getLoadOnStartup());
      if (this.multipartConfig != null) {
         registration.setMultipartConfig(this.multipartConfig);
      }
      return registration;
   }

}

</code></pre>
<h3 id="3-切换其他的servlet容器">3、切换其他的Servlet容器</h3>
<p>在ServerProperties中</p>
<pre><code class="language-java">private final Tomcat tomcat = new Tomcat();

private final Jetty jetty = new Jetty();

private final Undertow undertow = new Undertow();

</code></pre>
<p>tomcat(默认支持)</p>
<p>jetty（长连接）</p>
<p>undertow（多并发）</p>
<p>切换容器 仅仅需要修改pom文件的依赖就可以</p>
<pre><code class="language-xml">        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;
        &lt;/dependency&gt;
&lt;!--        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt;
        &lt;/dependency&gt;--&gt;

</code></pre>
<h3 id="4-嵌入式servlet容器自动配置原理">4、嵌入式Servlet容器自动配置原理</h3>
<pre><code class="language-java">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
@Configuration
@ConditionalOnWebApplication
@Import(BeanPostProcessorsRegistrar.class)
//给容器导入组件 后置处理器 在Bean初始化前后执行前置后置的逻辑 创建完对象还没属性赋值进行初始化工作
public class EmbeddedServletContainerAutoConfiguration {
    @Configuration
	@ConditionalOnClass({ Servlet.class, Tomcat.class })//当前是否引入tomcat依赖
    //判断当前容器没有用户自定义EmbeddedServletContainerFactory，就会创建默认的嵌入式容器
	@ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)
	public static class EmbeddedTomcat {

		@Bean
		public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() {
			return new TomcatEmbeddedServletContainerFactory();
		}

</code></pre>
<p>1）、EmbeddedServletContainerFactory（嵌入式Servlet容器工厂）</p>
<pre><code class="language-java">public interface EmbeddedServletContainerFactory {
	//获取嵌入式的Servlet容器
   EmbeddedServletContainer getEmbeddedServletContainer(
         ServletContextInitializer... initializers);

}

</code></pre>
<p>继承关系</p>
<figure data-type="image" tabindex="20"><img src="https://stormga.github.io//post-images/24.EmdServletFactory.jpg" alt="" loading="lazy"></figure>
<p>2）、EmbeddedServletContainer:(嵌入式的Servlet容器)</p>
<figure data-type="image" tabindex="21"><img src="https://stormga.github.io//post-images/25.EmdServletContainer.jpg" alt="" loading="lazy"></figure>
<p>3）、TomcatEmbeddedServletContainerFactory为例</p>
<pre><code class="language-java">@Override
public EmbeddedServletContainer getEmbeddedServletContainer(
      ServletContextInitializer... initializers) {
   Tomcat tomcat = new Tomcat();
    //配置tomcat的基本环节
   File baseDir = (this.baseDirectory != null ? this.baseDirectory
         : createTempDir(&quot;tomcat&quot;));
   tomcat.setBaseDir(baseDir.getAbsolutePath());
   Connector connector = new Connector(this.protocol);
   tomcat.getService().addConnector(connector);
   customizeConnector(connector);
   tomcat.setConnector(connector);
   tomcat.getHost().setAutoDeploy(false);
   configureEngine(tomcat.getEngine());
   for (Connector additionalConnector : this.additionalTomcatConnectors) {
      tomcat.getService().addConnector(additionalConnector);
   }
   prepareContext(tomcat.getHost(), initializers);
    //将配置好的tomcat传入进去；并且启动tomcat容器
   return getTomcatEmbeddedServletContainer(tomcat);
}

</code></pre>
<p>4）、嵌入式配置修改</p>
<pre><code>ServerProperties、EmbeddedServletContainerCustomizer

</code></pre>
<p>EmbeddedServletContainerCustomizer:定制器帮我们修改了Servlet容器配置？</p>
<p>怎么修改？</p>
<p>5）、容器中导入了<strong>EmbeddedServletContainerCustomizerBeanPostProcessor</strong></p>
<pre><code class="language-java">@Override
public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,
      BeanDefinitionRegistry registry) {
   if (this.beanFactory == null) {
      return;
   }
   registerSyntheticBeanIfMissing(registry,
         &quot;embeddedServletContainerCustomizerBeanPostProcessor&quot;,
         EmbeddedServletContainerCustomizerBeanPostProcessor.class);
   registerSyntheticBeanIfMissing(registry,
         &quot;errorPageRegistrarBeanPostProcessor&quot;,
         ErrorPageRegistrarBeanPostProcessor.class);
}

</code></pre>
<pre><code class="language-java">@Override
public Object postProcessBeforeInitialization(Object bean, String beanName)
      throws BeansException {
    //如果当前初始化的是一个ConfigurableEmbeddedServletContainer
   if (bean instanceof ConfigurableEmbeddedServletContainer) {
      postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean);
   }
   return bean;
}

private void postProcessBeforeInitialization(
    ConfigurableEmbeddedServletContainer bean) {
    //获取所有的定制器，调用每个定制器的customer方法给Servlet容器进行赋值
    for (EmbeddedServletContainerCustomizer customizer : getCustomizers()) {
        customizer.customize(bean);
    }
}

private Collection&lt;EmbeddedServletContainerCustomizer&gt; getCustomizers() {
    if (this.customizers == null) {
        // Look up does not include the parent context
        this.customizers = new ArrayList&lt;EmbeddedServletContainerCustomizer&gt;(
            this.beanFactory
            //从容器中获取所有的这个类型的组件：EmbeddedServletContainerCustomizer
            //定制Servlet,给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件
            .getBeansOfType(EmbeddedServletContainerCustomizer.class,
                            false, false)
            .values());
        Collections.sort(this.customizers, AnnotationAwareOrderComparator.INSTANCE);
        this.customizers = Collections.unmodifiableList(this.customizers);
    }
    return this.customizers;
}

</code></pre>
<p>ServerProperties也是EmbeddedServletContainerCustomizer定制器</p>
<p>步骤：</p>
<p>1）、SpringBoot根据导入的依赖情况，给容器中添加响应的容器工厂 例：tomcat</p>
<p>EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】</p>
<p>2）、容器中某个组件要创建对象就要通过后置处理器；</p>
<pre><code class="language-java">EmbeddedServletContainerCustomizerBeanPostProcessor

</code></pre>
<p>只要是嵌入式的Servlet容器工厂，后置处理器就工作；</p>
<p>3）、后置处理器，从容器中获取的所有的EmbeddedServletContainerCustomizer，调用定制器的定制方法</p>
<h3 id="5-嵌入式servlet容器启动原理">5、嵌入式Servlet容器启动原理</h3>
<p>什么时候创建嵌入式的Servlet的容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat;</p>
<p>获取嵌入式的容器工厂</p>
<p>1）、SpringBoot应用启动Run方法</p>
<p>2）、刷新IOC容器对象【创建IOC容器对象，并初始化容器，创建容器的每一个组件】；如果是web环境AnnotationConfigEmbeddedWebApplicationContext,如果不是AnnotationConfigApplicationContext</p>
<pre><code class="language-JAVA">if (contextClass == null) {
   try {
      contextClass = Class.forName(this.webEnvironment
            ? DEFAULT_WEB_CONTEXT_CLASS : DEFAULT_CONTEXT_CLASS);
   }

</code></pre>
<p>3）、refresh(context);刷新创建好的IOC容器</p>
<pre><code class="language-java">try {
   // Allows post-processing of the bean factory in context subclasses.
   postProcessBeanFactory(beanFactory);

   // Invoke factory processors registered as beans in the context.
   invokeBeanFactoryPostProcessors(beanFactory);

   // Register bean processors that intercept bean creation.
   registerBeanPostProcessors(beanFactory);

   // Initialize message source for this context.
   initMessageSource();

   // Initialize event multicaster for this context.
   initApplicationEventMulticaster();

   // Initialize other special beans in specific context subclasses.
   onRefresh();

   // Check for listener beans and register them.
   registerListeners();

   // Instantiate all remaining (non-lazy-init) singletons.
   finishBeanFactoryInitialization(beanFactory);

   // Last step: publish corresponding event.
   finishRefresh();
}

</code></pre>
<p>4）、 onRefresh();web的ioc容器重写了onRefresh方法</p>
<p>5）、webioc会创建嵌入式的Servlet容器；createEmbeddedServletContainer</p>
<p>6）、获取嵌入式的Servlet容器工厂；</p>
<pre><code class="language-java">EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory();

</code></pre>
<p>从ioc容器中获取EmbeddedServletContainerFactory组件；</p>
<pre><code class="language-java">@Bean
public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() {
return new TomcatEmbeddedServletContainerFactory();
}

</code></pre>
<p>TomcatEmbeddedServletContainerFactory创建对象，后置处理器看这个对象，就来获取所有的定制器来定制Servlet容器的相关配置；</p>
<p>7）、使用容器工厂获取嵌入式的Servlet容器</p>
<p>8）、嵌入式的Servlet容器创建对象并启动Servlet容器；</p>
<p>先启动嵌入式的Servlet容器，在将ioc容器中剩下的没有创建出的对象获取出来</p>
<p>ioc启动创建Servlet容器</p>
<h2 id="9-使用外置的servlet容器">9、使用外置的Servlet容器</h2>
<p>嵌入式的Servlet容器：应用达成jar包</p>
<p>​	优点：简单、便携</p>
<p>​	缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义定制器】，自己来编写嵌入式的容器工厂）</p>
<p>外置的Servlet容器：外面安装Tomcat是以war包的方式打包。</p>
<h3 id="1-idea操作外部servlet">1、IDEA操作外部Servlet</h3>
<p>1、创建程序为war程序</p>
<figure data-type="image" tabindex="22"><img src="https://stormga.github.io//post-images/26.tomcat1.jpg" alt="" loading="lazy"></figure>
<p>2、选择版本</p>
<figure data-type="image" tabindex="23"><img src="https://stormga.github.io//post-images/27.tomcat2.jpg" alt="" loading="lazy"></figure>
<p>3、添加tomcat</p>
<figure data-type="image" tabindex="24"><img src="https://stormga.github.io//post-images/28.tomcat3.jpg" alt="" loading="lazy"></figure>
<p>4、选择tomcat</p>
<figure data-type="image" tabindex="25"><img src="https://stormga.github.io//post-images/30.tomcat4.jpg" alt="" loading="lazy"></figure>
<p>5、选择本地的Tomcat</p>
<figure data-type="image" tabindex="26"><img src="https://stormga.github.io//post-images/31.tomcat5.jpg" alt="" loading="lazy"></figure>
<p>6、配置tomcat路径</p>
<figure data-type="image" tabindex="27"><img src="https://stormga.github.io//post-images/32.tomcat6.jpg" alt="" loading="lazy"></figure>
<p>7、添加服务器</p>
<figure data-type="image" tabindex="28"><img src="https://stormga.github.io//post-images/33.tomcat7.jpg" alt="" loading="lazy"></figure>
<p>8、添加exploded的war配置，应用OK tomcat配置完成</p>
<figure data-type="image" tabindex="29"><img src="https://stormga.github.io//post-images/34.tomcat8.jpg" alt="" loading="lazy"></figure>
<p>二、配置webapp文件夹</p>
<p>1、点击配置</p>
<figure data-type="image" tabindex="30"><img src="https://stormga.github.io//post-images/35.tomcat9.jpg" alt="" loading="lazy"></figure>
<p>2、添加webapp目录</p>
<figure data-type="image" tabindex="31"><img src="https://stormga.github.io//post-images/36.tomcat10.jpg" alt="" loading="lazy"></figure>
<p>3、默认配置就可以</p>
<figure data-type="image" tabindex="32"><img src="https://stormga.github.io//post-images/37.tomcat11.jpg" alt="" loading="lazy"></figure>
<p>4、配置web.xml文件</p>
<figure data-type="image" tabindex="33"><img src="https://stormga.github.io//post-images/38.tomcat12.jpg" alt="" loading="lazy"></figure>
<p>5、文档目录结构</p>
<figure data-type="image" tabindex="34"><img src="https://stormga.github.io//post-images/39.tomcat13.jpg" alt="" loading="lazy"></figure>
<h3 id="2-运行一个示例">2、运行一个示例</h3>
<p>1、项目目录</p>
<figure data-type="image" tabindex="35"><img src="https://stormga.github.io//post-images/40.demo1.jpg" alt="" loading="lazy"></figure>
<p>2、配置文件写视图解析前后缀</p>
<pre><code class="language-properties">spring.mvc.view.prefix=/WEB-INF/jsp/

spring.mvc.view.suffix=.jsp

</code></pre>
<p>3、HelloController</p>
<pre><code class="language-java">@Controller
public class HelloController {
    @GetMapping(&quot;/hello&quot;)
    public String hello(Model model){
        model.addAttribute(&quot;message&quot;,&quot;这是Controller传过来的message&quot;);
        return &quot;success&quot;;
    }
}

</code></pre>
<p>4、success.jsp</p>
<pre><code class="language-jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Success&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Success&lt;/h1&gt;
message:${message}
&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<p>5、运行结果</p>
<figure data-type="image" tabindex="36"><img src="https://stormga.github.io//post-images/41.demo2.jpg" alt="" loading="lazy"></figure>
<p>步骤</p>
<p>1、必须创建一个war项目；</p>
<p>2、将嵌入式的Tomcat指定为provided</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;

</code></pre>
<p>3、必须编写一个SpringBootServletInitializer的子类，并调用configure方法里面的固定写法</p>
<pre><code class="language-java">public class ServletInitializer extends SpringBootServletInitializer {

    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
        //传入SpringBoot的主程序，
        return application.sources(SpringBoot04WebJspApplication.class);
    }

}

</code></pre>
<p>4、启动服务器就可以；</p>
<h3 id="3-原理">3、原理</h3>
<p>jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet的容器；</p>
<p>war包：启动服务器，服务器启动SpringBoot应用，【SpringBootServletInitializer】启动ioc容器</p>
<p>servlet3.0规范</p>
<p>8.2.4 共享库和运行时插件</p>
<p>规则：</p>
<p>1、服务器启动（web应用启动），会创建当前的web应用里面每一个jar包里面ServletContrainerInitializer的实现类的实例</p>
<p>2、SpringBootServletInitializer这个类的实现需要放在jar包下的META-INF/services文件夹下，有一个命名为javax.servlet.ServletContainerInitalizer的文件，内容就是ServletContainerInitializer的实现类全类名</p>
<p>3、还可以使用@HandlerTypes注解，在应用启动的时候可以启动我们感兴趣的类</p>
<p>流程：</p>
<p>1、启动Tomcat服务器</p>
<p>2、spring web模块里有这个文件</p>
<figure data-type="image" tabindex="37"><img src="https://stormga.github.io//post-images/42.servletContainerInit.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-java">org.springframework.web.SpringServletContainerInitializer

</code></pre>
<p>3、SpringServletContainerInitializer将handlerTypes标注的所有类型的类传入到onStartip方法的Set&lt;Class&lt;?&gt;&gt;;为这些感兴趣类创建实例</p>
<p>4、每个创建好的WebApplicationInitializer调用自己的onStratup</p>
<p>5、相当于我们的SpringBootServletInitializer的类会被创建对象，并执行onStartup方法</p>
<p>6、SpringBootServletInitializer执行onStartup方法会创建createRootApplicationContext</p>
<pre><code class="language-java">protected WebApplicationContext createRootApplicationContext(ServletContext servletContext) {
    SpringApplicationBuilder builder = this.createSpringApplicationBuilder();
    //环境构建器
    StandardServletEnvironment environment = new StandardServletEnvironment();
    environment.initPropertySources(servletContext, (ServletConfig)null);
    builder.environment(environment);
    builder.main(this.getClass());
    ApplicationContext parent = this.getExistingRootWebApplicationContext(servletContext);
    if (parent != null) {
        this.logger.info(&quot;Root context already created (using as parent).&quot;);
        servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, (Object)null);
        builder.initializers(new ApplicationContextInitializer[]{new ParentContextApplicationContextInitializer(parent)});
    }
	
    builder.initializers(new ApplicationContextInitializer[]{new ServletContextApplicationContextInitializer(servletContext)});
    builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class);
    //调用Configure,子类重写了这个方法，将SpringBoot的主程序类传入进来
    builder = this.configure(builder);
    //创建一个spring应用
    SpringApplication application = builder.build();
    if (application.getSources().isEmpty() &amp;&amp; AnnotationUtils.findAnnotation(this.getClass(), Configuration.class) != null) {
        application.getSources().add(this.getClass());
    }

    Assert.state(!application.getSources().isEmpty(), &quot;No SpringApplication sources have been defined. Either override the configure method or add an @Configuration annotation&quot;);
    if (this.registerErrorPageFilter) {
        application.getSources().add(ErrorPageFilterConfiguration.class);
    }
	//最后启动Spring容器
    return this.run(application);
}

</code></pre>
<p>7、Spring的应用就启动完了并且创建IOC容器；</p>
<pre><code class="language-java">public ConfigurableApplicationContext run(String... args) {
   StopWatch stopWatch = new StopWatch();
   stopWatch.start();
   ConfigurableApplicationContext context = null;
   FailureAnalyzers analyzers = null;
   configureHeadlessProperty();
   SpringApplicationRunListeners listeners = getRunListeners(args);
   listeners.starting();
   try {
      ApplicationArguments applicationArguments = new DefaultApplicationArguments(
            args);
      ConfigurableEnvironment environment = prepareEnvironment(listeners,
            applicationArguments);
      Banner printedBanner = printBanner(environment);
      context = createApplicationContext();
      analyzers = new FailureAnalyzers(context);
      prepareContext(context, environment, listeners, applicationArguments,
            printedBanner);
      refreshContext(context);
      afterRefresh(context, applicationArguments);
      listeners.finished(context, null);
      stopWatch.stop();
      if (this.logStartupInfo) {
         new StartupInfoLogger(this.mainApplicationClass)
               .logStarted(getApplicationLog(), stopWatch);
      }
      return context;
   }
   catch (Throwable ex) {
      handleRunFailure(context, listeners, analyzers, ex);
      throw new IllegalStateException(ex);
   }
}

</code></pre>
<h1 id="五-docker">五、Docker</h1>
<h2 id="1-简介-2">1、简介</h2>
<p>Docker是一个开源的应用容器引擎</p>
<p>将软件编译成一个镜像；然后在镜像里各种软件做好配置，将镜像发布出去，其他的使用这就可以直接使用这个镜像。运行中的这个镜像叫做容器，容器启动速度快，类似ghost操作系统，安装好了什么都有了；</p>
<h2 id="2-docker的核心概念">2、Docker的核心概念</h2>
<p>docker主机（HOST）:安装了Docker程序的机器（Docker直接安装在操作系统上的）</p>
<p>docker客户端（Client）:操作docker主机</p>
<p>docker仓库（Registry）：用来保存打包好的软件镜像</p>
<p>docker镜像（Image）:软件打好包的镜像，放到docker的仓库中</p>
<p>docker容器（Container）:镜像启动后的实例（5个容器启动5次镜像）</p>
<p>docker的步骤：</p>
<p>​	1、安装Docker</p>
<p>​	2、去Docker仓库找到这个软件对应的镜像；</p>
<p>​	3、使用Docker运行的这个镜像，镜像就会生成一个容器</p>
<p>​	4、对容器的启动停止，就是对软件的启动和停止</p>
<h2 id="3-安装docker">3、安装Docker</h2>
<h3 id="1-安装linux">1、安装Linux</h3>
<p><a href="http://note.youdao.com/noteshare?id=06ccb673d253fea78fe35430465758e1">安装vxbox并且安装ubuntu</a></p>
<h3 id="2-在linux上安装docker">2、在linux上安装docker</h3>
<pre><code class="language-shell">1、查看centos版本
# uname -r
3.10.0-693.el7.x86_64
要求：大于3.10
如果小于的话升级*（选做）
# yum update
2、安装docker
# yum install docker
3、启动docker
# systemctl start docker
# docker -v
4、开机启动docker
# systemctl enable docker
5、停止docker
# systemctl stop docker

</code></pre>
<h2 id="4-docker的常用操作">4、docker的常用操作</h2>
<h3 id="1-镜像操作">1、镜像操作</h3>
<p>1、搜索</p>
<pre><code class="language-shell">docker search mysql

</code></pre>
<p>默认去docker hub网站查找 <img src="https://stormga.github.io//post-images/44.docker1.jpg" alt="" loading="lazy"></p>
<p>2、拉取</p>
<pre><code class="language-shell">默认最新版本
# docekr pull mysql
安装指定版本
# docker pull mysql:5.5

</code></pre>
<p>3、查看</p>
<pre><code class="language-shell">docker images

</code></pre>
<p>4、删除</p>
<pre><code>docker rmi imageid

</code></pre>
<h3 id="2-容器操作">2、容器操作</h3>
<p>软件的镜像（qq.exe） -- 运行镜像 -- 产生一个容器（正在运行的软件）</p>
<pre><code class="language-shell">1、搜索镜像
# docker search tomcat
2、拉取镜像
# docker pull tomcat
3、根据镜像启动容器
[root@lion ~]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
docker.io/tomcat    latest              d3d38d61e402        35 hours ago        549 MB
[root@lion ~]# docker run --name mytomcat -d tomcat:latest
2f0348702f5f2a2777082198795d8059d83e5ee38f430d2d44199939cc63e249
4、查看那个进程正在进行
[root@lion ~]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
2f0348702f5f        tomcat:latest       &quot;catalina.sh run&quot;   41 seconds ago      Up 39 seconds       8080/tcp            mytomcat
5、停止运行中容器
[root@lion ~]# docker stop 2f0348702f5f
2f0348702f5f
6、查看所有容器
[root@lion ~]# docker ps -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                       PORTS               NAMES
2f0348702f5f        tomcat:latest       &quot;catalina.sh run&quot;   52 minutes ago      Exited (143) 2 minutes ago                       mytomcat
7、启动容器
[root@lion ~]# docker start 2f0348702f5f
8、删除docker容器
[root@lion ~]# docker rm 2f0348702f5f
2f0348702f5f
9、端口映射
[root@lion ~]# docker run --name mytomcat -d -p 8888:8080 tomcat
692c408c220128014df32ecb6324fb388427d1ecd0ec56325580135c58f63b29
虚拟机:8888
容器的:8080
-d:后台运行
-p:主机端口映射到容器端口
浏览器：192.168.179.129:8888
10、docker的日志
[root@lion ~]# docker logs 692c408c2201
11、多个启动
[root@lion ~]# docker run -d -p 9000:8080 --name mytomcat2 tomcat
浏览器：192.168.179.129:9000

</code></pre>
<p>更多命令参考docker镜像文档</p>
<h3 id="3-安装mysql">3、安装Mysql</h3>
<pre><code class="language-shell">docker pull mysql
docker run --name mysql001 -e MYSQL_ROOT_PASSWORD -d -p 3307:3306 mysql

</code></pre>
<h1 id="六-数据访问">六、数据访问</h1>
<h2 id="1-整合jdbc数据源">1、整合JDBC数据源</h2>
<p>1、新建项目 spring-boot-06-data-jdbc</p>
<ul>
<li>WEB</li>
<li>Mysql</li>
<li>JDBC</li>
<li>SpringBoot1.5</li>
</ul>
<p>2、编写配置文件appliction.yml</p>
<pre><code class="language-yaml">spring:
  datasource:
    username: root
    password: Welcome_1
    url: jdbc:mysql://192.168.179.131:3306/jdbc
    driver-class-name: com.mysql.jdbc.Driver

</code></pre>
<p>3、编写测试类测试</p>
<pre><code class="language-java">@RunWith(SpringRunner.class)
@SpringBootTest
public class SpringBoot06DataJdbcApplicationTests {

    @Autowired
    DataSource dataSource;

    @Test
    public void contextLoads() throws SQLException {
        System.out.println(dataSource.getClass());

        Connection connection = dataSource.getConnection();
        System.out.println(connection);
        connection.close();
    }

}

</code></pre>
<p>4、测试结果</p>
<pre><code>class org.apache.tomcat.jdbc.pool.DataSource
ProxyConnection[PooledConnection[com.mysql.jdbc.JDBC4Connection@c35af2a]]

</code></pre>
<p>数据源相关配置都在DataSourceProperties属性里</p>
<p>自动配置原理</p>
<p>E:\Develop\Maven_Repo\org\springframework\boot\spring-boot-autoconfigure\1.5.13.RELEASE\spring-boot-autoconfigure-1.5.13.RELEASE.jar!\org\springframework\boot\autoconfigure\jdbc</p>
<h3 id="1-datasource">1、DataSource</h3>
<p>参考DataSourceConfiguration,根据配置创建数据源，默认是使用tomcat连接池，可以使用spring.datasource.type指定自定义的数据源</p>
<h3 id="2-springboot默认支持">2、SpringBoot默认支持</h3>
<pre><code>Tomcat数据源
HikariDataSource
dbcp.BasicDataSource
dbcp2.BasicDataSource

</code></pre>
<h3 id="3-自定义数据源">3、自定义数据源</h3>
<pre><code class="language-java"> */
@ConditionalOnMissingBean(DataSource.class)
@ConditionalOnProperty(name = &quot;spring.datasource.type&quot;)
static class Generic {

   @Bean
   public DataSource dataSource(DataSourceProperties properties) {
       //使用builder创建数据源，利用反射创建相应的type数据源，并绑定数据源
      return properties.initializeDataSourceBuilder().build();
   }

}

</code></pre>
<h3 id="4-运行sql建表">4、运行sql建表</h3>
<p>在DataSourceAutoConfiguration中<strong>DataSourceInitializer</strong>类</p>
<p>监听器</p>
<p>作用：</p>
<p>1）、postConstruct -》runSchemaScript 运行建表sql文件</p>
<p>2）、runDataScript运行插入数据的sql语句；</p>
<p>默认只需要将文件命名为：</p>
<pre><code class="language-sql">schema-*.sql data-*.sql
默认规则：schema.sql ,schema-all.sql;

</code></pre>
<p><strong>举个栗子</strong></p>
<p>创建department表</p>
<p>1、department.sql</p>
<pre><code class="language-sql">/*
Navicat MySQL Data Transfer

Source Server         : 192.168.179.131
Source Server Version : 50719
Source Host           : 192.168.179.131:3306
Source Database       : jdbc

Target Server Type    : MYSQL
Target Server Version : 50719
File Encoding         : 65001

Date: 2018-05-14 14:28:52
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for department
-- ----------------------------
DROP TABLE IF EXISTS `department`;
CREATE TABLE `department` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `departmentName` varchar(255) DEFAULT '',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;


</code></pre>
<p>2、将department.sql命名为schema-all.sql</p>
<figure data-type="image" tabindex="38"><img src="https://stormga.github.io//post-images/45.schema-all.jpg" alt="" loading="lazy"></figure>
<p>3、运行测试类</p>
<p>自定义sql的文件名，department.sql在配置文件中</p>
<pre><code class="language-yaml">schema:
  - classpath:department.sql

</code></pre>
<hr>
<h3 id="5-操作jdbctemplate">5、操作JdbcTemplate</h3>
<p><strong>FBI warning</strong>:将department.sql删除或者改名，因为运行文件会将表中数据清除</p>
<p>1、新建一个Controller</p>
<pre><code class="language-java">@Controller
public class HelloController {

    @Autowired
    JdbcTemplate jdbcTemplate;

    @ResponseBody
    @GetMapping(&quot;/hello&quot;)
    public Map&lt;String ,Object&gt; hello(){

        List&lt;Map&lt;String, Object&gt;&gt; list = jdbcTemplate.queryForList(&quot;select * from department&quot;);
        return list.get(0);
    }
}

</code></pre>
<p>2、表中添加数据</p>
<figure data-type="image" tabindex="39"><img src="https://stormga.github.io//post-images/46.department.jpg" alt="" loading="lazy"></figure>
<p>3、访问请求查询数据</p>
<figure data-type="image" tabindex="40"><img src="https://stormga.github.io//post-images/47.hello.jpg" alt="" loading="lazy"></figure>
<h2 id="2-自定义数据源">2、自定义数据源</h2>
<p>1、导入Druid的依赖</p>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;druid&lt;/artifactId&gt;
    &lt;version&gt;1.1.9&lt;/version&gt;
&lt;/dependency&gt;


</code></pre>
<p>2、修改配置文件</p>
<pre><code class="language-yaml">spring:
  datasource:
    username: root
    password: Welcome_1
    url: jdbc:mysql://192.168.179.131:3306/jdbc
    driver-class-name: com.mysql.jdbc.Driver
    type: com.alibaba.druid.pool.DruidDataSource
#    schema:
#      - classpath:department.sql
server:
  port: 9000

</code></pre>
<p>已经替换了原来的tomcat数据源</p>
<p>3、配置Druid数据源配置</p>
<pre><code class="language-yaml">spring:
  datasource:
    username: root
    password: Welcome_1
    url: jdbc:mysql://192.168.179.131:3306/jdbc
    driver-class-name: com.mysql.jdbc.Driver
    type: com.alibaba.druid.pool.DruidDataSource
	# 初始化大小，最小，最大  
    initialSize: 5
    minIdle: 5
    maxActive: 20
    # 配置获取连接等待超时的时间  
    maxWait: 60000
    # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 
    timeBetweenEvictionRunsMillis: 60000
    # 配置一个连接在池中最小生存的时间，单位是毫秒 
    minEvictableIdleTimeMillis: 300000
    validationQuery: SELECT 1 FROM DUAL
    testWhileIdle: true
    testOnBorrow: false
    testOnReturn: false
    poolPreparedStatements: true
    # 配置监控统计拦截的filters,去掉监控界面sql无法统计，‘wall’用于防火墙
    filters: stat,wall,log4j
    maxPoolPreparedStatementPerConnectionSize: 20
    userGlobalDataSourceStat: true
    # 通过connectProperties属性来打开mergeSql功能；慢SQL记录  
    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500
#    schema:
#      - classpath:department.sql
server:
  port: 9000

</code></pre>
<p>4、Druid配置监控</p>
<pre><code class="language-java">@Configuration
public class DruidConfig {

    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)
    @Bean
    public DataSource druid(){
        return  new DruidDataSource();
    }

    //配置Druid的监控
    //1、配置一个管理后台
    @Bean
    public ServletRegistrationBean statViewServlet(){
        ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(),&quot;/druid/*&quot;);
        Map&lt;String,String&gt; initParams =new HashMap&lt;&gt;();
        initParams.put(&quot;loginUsername&quot;, &quot;admin&quot;);
        initParams.put(&quot;loginPassword&quot;, &quot;123456&quot;);
        bean.setInitParameters(initParams);
        return bean;
    }
    //2、配置监控的filter
    @Bean
    public FilterRegistrationBean webstatFilter(){
        FilterRegistrationBean bean = new FilterRegistrationBean();
        bean.setFilter(new WebStatFilter());

        Map&lt;String,String&gt; initParams =new HashMap&lt;&gt;();
        initParams.put(&quot;exclusions&quot;, &quot;*.js,*.css,/druid/*&quot;);
        bean.setInitParameters(initParams);
        bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;));
        return bean;
    }

}

</code></pre>
<p>5、运行测试，访问 localhost:9000/druid</p>
<figure data-type="image" tabindex="41"><img src="https://stormga.github.io//post-images/48.druid.jpg" alt="" loading="lazy"></figure>
<p>输入刚才调好的用户名密码即可访问</p>
<h2 id="3-整合mybatis">3、整合Mybatis</h2>
<p>1、新建工程，SpringBoot1.5+web+JDBC+Mysql</p>
<p>导入依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.3.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;druid&lt;/artifactId&gt;
    &lt;version&gt;1.1.9&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;
&lt;/dependency&gt;

</code></pre>
<p>2、导入配置文件中关于Druid的配置</p>
<p>​	2.1、导入依赖</p>
<p>​	2.2、配置文件application.yml（指定用户名密码...配置Druid的配置参数，修改sql文件加载的默认名）</p>
<p>​	2.3、将Druid组件加入到容器中（监控）重点</p>
<p>​	具体同上</p>
<p>3、创建数据表department和employee表</p>
<p>​	3.1、根据sql文件，新建两张表</p>
<p>​	3.2、修改加载的sql名（默认为schema.sql和schema-all.sql）</p>
<pre><code class="language-yaml">spring:
  datasource:
    schema:
      - classpath:sql/department.sql
      - classpath:sql/employeee.sql

</code></pre>
<p>​	3.3、运行程序检查数据库是否创建成功</p>
<p>4、创建数据库对应的JavaBean （驼峰命名，getter/setter toString/注释掉schema防止重复创建）</p>
<p>在配置文件中修改驼峰命名开启 ,不写配置文件就写配置类</p>
<pre><code class="language-yaml">mybatis:
  configuration:
    map-underscore-to-camel-case: true

</code></pre>
<pre><code class="language-java">//类名冲突所以全类名
@org.springframework.context.annotation.Configuration
public class MyBatisConfig {

    @Bean
    public ConfigurationCustomizer configurationCustomizer(){

        return new ConfigurationCustomizer() {
            @Override
            public void customize(Configuration configuration) {
                configuration.setMapUnderscoreToCamelCase(true);
            }
        };
    }
}

</code></pre>
<h3 id="注解方式">注解方式</h3>
<p>5、新建mapper</p>
<pre><code class="language-yaml">//指定是一个mapper
@Mapper
public interface DepartmentMapper {

    @Insert(&quot;insert into department(dept_name) value(#{deptName})&quot;)
    public int insertDept(Department department);

    @Delete(&quot;delete from department where id=#{id}&quot;)
    public int deleteDeptById(Integer id);

    @Update(&quot;update department set dept_Name=#{deptName} where id=#{id}&quot;)
    public int updateDept(Department department);

    @Select(&quot;select * from department where id=#{id}&quot;)
    public Department getDeptById(Integer id);

}

</code></pre>
<p>6、编写controller测试</p>
<pre><code class="language-java">@RestController
public class DeptController {

    @Autowired
    DepartmentMapper departmentMapper;

    @RequestMapping(&quot;/getDept/{id}&quot;)
    public Department getDepartment(@PathVariable(&quot;id&quot;) Integer id){
        return departmentMapper.getDeptById(id);
    }

    @RequestMapping(&quot;/delDept/{id}&quot;)
    public int delDept(@PathVariable(&quot;id&quot;) Integer id){
        return departmentMapper.deleteDeptById(id);
    }

    @RequestMapping(&quot;/update/{id}&quot;)
    public int updateDept(@PathVariable(&quot;id&quot;) Integer id){
        return departmentMapper.updateDept(new Department(id, &quot;开发部&quot;));
    }

    @GetMapping(&quot;/insert&quot;)
    public int insertDept(Department department){
        return departmentMapper.insertDept(department);
    }
}

</code></pre>
<p>问题：</p>
<p>mapper文件夹下有多个mapper文件，加麻烦，可以直接扫描整个mapper文</p>
<p>件夹下的mapper</p>
<pre><code class="language-java">//主配置类或者mybatis配置类
@MapperScan(value = &quot;com.wdjr.springboot.mapper&quot;)

</code></pre>
<h3 id="配置文件方式">配置文件方式</h3>
<p>1、新建文件</p>
<figure data-type="image" tabindex="42"><img src="https://stormga.github.io//post-images/50.mybatisxml.jpg" alt="" loading="lazy"></figure>
<p>2、新建mybatis的配置文件</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;settings&gt;
        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
    &lt;/settings&gt;
&lt;/configuration&gt;

</code></pre>
<p>3、新建Employee的接口方法</p>
<pre><code class="language-java">public interface EmployeeMapper {

    public Employee getEmpById(Integer id);

    public void insetEmp(Employee employee);
}

</code></pre>
<p>4、新建Employee的mapper.xml的映射文件</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.wdjr.springboot.mapper.EmployeeMapper&quot;&gt;
    &lt;select id=&quot;getEmpById&quot; resultType=&quot;com.wdjr.springboot.bean.Employee&quot;&gt;
      select * from employee where id=#{id}
   &lt;/select&gt;

    &lt;insert id=&quot;insetEmp&quot;&gt;
        INSERT  INTO employee(last_name,email,gender,d_id) VALUES (#{lastName},#{email},#{gender},#{dId})
    &lt;/insert&gt;
&lt;/mapper&gt;

</code></pre>
<p>5、修改application.yml配置文件</p>
<pre><code class="language-yaml">mybatis:
  config-location: classpath:mybatis/mybatis-config.xml
  mapper-locations: classpath:mybatis/mapper/*.xml

</code></pre>
<p>6、新建一个Controller访问方法</p>
<pre><code class="language-java">@RestController
public class EmployeeController {
    @Autowired
    EmployeeMapper employeeMapper;

    @RequestMapping(&quot;/getEmp/{id}&quot;)
    public Employee getEmp(@PathVariable(&quot;id&quot;) Integer id){
        return employeeMapper.getEmpById(id);
    }

    @GetMapping(&quot;/insertEmp&quot;)
    public Employee insertEmp(Employee employee){
        employeeMapper.insetEmp(employee);
        return employee;
    }
}

</code></pre>
<h2 id="4-jpa数据访问">4、JPA数据访问</h2>
<p>新建工程 springBoot1.5+Web+JPA+MYSQL+JDBC</p>
<p>目录结构</p>
<figure data-type="image" tabindex="43"><img src="https://stormga.github.io//post-images/51.JPA.jpg" alt="" loading="lazy"></figure>
<p>1、新建一个实体类User</p>
<pre><code class="language-java">//使用JPA注解配置映射关系
@Entity//告诉JPA这是一个实体类（和数据表映射的类）
@Table(name=&quot;tbl_user&quot;) //@Table来指定和那个数据表对应，如果省略默认表明就是user;

public class User {

    @Id //这是一个主键
    @GeneratedValue(strategy = GenerationType.IDENTITY)//自增组件
    private Integer id ;

    @Column(name=&quot;last_name&quot;,length = 50) //这是和数据表对应的一个列
    private String lastName;
    @Column//省略默认列名就是属性名
    private String email;
    @Column
    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }
}

</code></pre>
<p>2、新建一个UserRepository来继承jpa的绝大多数功能</p>
<pre><code class="language-java">//继承jpaRepository
public interface UserRepository extends JpaRepository&lt;User,Integer&gt; {

}

</code></pre>
<p>3、编写配置文件application.yml</p>
<pre><code class="language-yaml">spring:
  datasource:
    url: jdbc:mysql://192.168.179.131/jpa
    username: root
    password: Welcome_1
    driver-class-name: com.mysql.jdbc.Driver
  jpa:
    hibernate:
    #更新或创建
      ddl-auto: update
    show-sql: true

</code></pre>
<p>4、编写Controller测试</p>
<pre><code class="language-java">@RestController
public class UserController {
    @Autowired
    UserRepository userRepository;

    @GetMapping(&quot;/user/{id}&quot;)
    public User getUser(@PathVariable(&quot;id&quot;) Integer id){
        User user = userRepository.findOne(id);
        return user;
    }

    @GetMapping(&quot;/insert&quot;)
    public User insertUser(User user){
        User user1 = userRepository.save(user);
        return  user1;
    }
}

</code></pre>
<h1 id="七-启动配置原理">七、启动配置原理</h1>
<p>几个重要的事件回调机制</p>
<p>加载配置文件META-INF/spring.factories</p>
<p>​	ApplicationContextInitializer</p>
<p>​	SpringApplicationRunListener</p>
<p>ioc容器中</p>
<p>​	ApplicationRunner</p>
<p>​	CommandLineRunner</p>
<p>启动流程</p>
<h2 id="1-创建springapplicaiotn对象">1、创建SpringApplicaiotn对象</h2>
<pre><code class="language-java">private void initialize(Object[] sources) {
    //保存主配置类
   if (sources != null &amp;&amp; sources.length &gt; 0) {
      this.sources.addAll(Arrays.asList(sources));
   }
    //判断当前是否是个web应用
   this.webEnvironment = deduceWebEnvironment();
    //从类路径下找到META-INF/spring.factories配置中的所有ApplicationInitializer 然后保存起来
   setInitializers((Collection) getSpringFactoriesInstances(
         ApplicationContextInitializer.class));
    //从类路径下找到META-INF/spring.factories配置中的所有ApplicationListener 然后保存起来
   setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
    //决定哪一个是主程序
   this.mainApplicationClass = deduceMainApplicationClass();
}

</code></pre>
<p>ApplicationInitializer</p>
<figure data-type="image" tabindex="44"><img src="https://stormga.github.io//post-images/52.applicationCotextInitializer.jpg" alt="" loading="lazy"></figure>
<p>ApplicationListener</p>
<figure data-type="image" tabindex="45"><img src="https://stormga.github.io//post-images/53.Listener.jpg" alt="" loading="lazy"></figure>
<h2 id="2-运行run方法">2、运行Run方法</h2>
<pre><code class="language-java">public ConfigurableApplicationContext run(String... args) {
   StopWatch stopWatch = new StopWatch();
   stopWatch.start();
   ConfigurableApplicationContext context = null;
   FailureAnalyzers analyzers = null;
   configureHeadlessProperty();
    //获取SpringApplicationRunListeners;从类路径下META-INF/spring.factory
   SpringApplicationRunListeners listeners = getRunListeners(args);
    //回调所有的SpringApplicationRunListener.starting()方法
   listeners.starting();
   try {
       //封装命令行参数
      ApplicationArguments applicationArguments = new DefaultApplicationArguments(
            args);
       //准备环境
      ConfigurableEnvironment environment = prepareEnvironment(listeners,
            applicationArguments);
       //创建环境，完成后回调SpringApplicationRunListener.environmentPrepared环境准备完成
       //打印SpringBoot图标
      Banner printedBanner = printBanner(environment);
       //创建ApplicationContext，决定创建web的ioc容器还是普通的ioc
      context = createApplicationContext();
       //异常分析
      analyzers = new FailureAnalyzers(context);
       //重点：将environment保存的ioc中，applyInitializers初始化器上面那6个的获取，并且回调ApplicationContextInitializer.initialize方法
       
       //回调所有的SpringApplicationRunListener的contextPrepare()
       //告诉prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded
      prepareContext(context, environment, listeners, applicationArguments,
            printedBanner);
       //重要：刷新所有组件 ioc容器初始化，如果是web应用还会创建嵌入式的tomcat
       //扫描 创建加载所有组件的地方
      refreshContext(context);
       //从ioc中获取所有的ApplicationRunner和CommandLineRunner
       //ApplicationRunner先回调
      afterRefresh(context, applicationArguments);
       //所有的SpringApplicationRunListener回调finished方法
      listeners.finished(context, null);
       //保存应用状态
      stopWatch.stop();
      if (this.logStartupInfo) {
         new StartupInfoLogger(this.mainApplicationClass)
               .logStarted(getApplicationLog(), stopWatch);
      }
       //整个springboot启动完成以后返回启动的ioc容器
      return context;
   }
   catch (Throwable ex) {
      handleRunFailure(context, listeners, analyzers, ex);
      throw new IllegalStateException(ex);
   }
}

</code></pre>
<h2 id="3-事件监听机制">3、事件监听机制</h2>
<p>新建listener监听</p>
<p>文件目录</p>
<figure data-type="image" tabindex="46"><img src="https://stormga.github.io//post-images/54.listener2.jpg" alt="" loading="lazy"></figure>
<p>1、HelloApplicationContextInitializer</p>
<pre><code class="language-java">//泛型监听ioc容器
public class HelloApplicationContextInitializer implements ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; {
    @Override
    public void initialize(ConfigurableApplicationContext applicationContext) {
        System.out.println(&quot;ApplicationContextInitializer...跑起来了.....&quot;+applicationContext);
    }
}

</code></pre>
<p>2、HelloSpringApplicationRunListener</p>
<p>加构造器</p>
<pre><code class="language-java">public class HelloSpringApplicationRunListener implements SpringApplicationRunListener {

    public HelloSpringApplicationRunListener(SpringApplication application, String[] args){

    }

    @Override
    public void starting() {
        System.out.println(&quot;监听容器开始......&quot;);
    }

    @Override
    public void environmentPrepared(ConfigurableEnvironment environment) {
        System.out.println(&quot;环境准备好了......&quot;+environment.getSystemProperties().get(&quot;os.name&quot;));
    }

    @Override
    public void contextPrepared(ConfigurableApplicationContext context) {
        System.out.println(&quot;ioc容器准备好了......&quot;);
    }

    @Override
    public void contextLoaded(ConfigurableApplicationContext context) {
        System.out.println(&quot;容器环境已经加载完成......&quot;);
    }

    @Override
    public void finished(ConfigurableApplicationContext context, Throwable exception) {
        System.out.println(&quot;全部加载完成......&quot;);
    }
}

</code></pre>
<p>3、HelloApplicationRunner</p>
<pre><code class="language-java">@Component
public class HelloApplicationRunner implements ApplicationRunner {
    @Override
    public void run(ApplicationArguments args) throws Exception {
        System.out.println(&quot;ApplicationRunner.....run....&quot;);
    }
}

</code></pre>
<p>4、HelloCommandLineRunner</p>
<pre><code class="language-java">@Component
public class HelloCommandLineRunner implements CommandLineRunner {
    @Override
    public void run(String... args) throws Exception {
        System.out.println(&quot;CommandLineRunner......run.....&quot;+Arrays.asList(args));
    }
}

</code></pre>
<p>事件运行方法</p>
<p>HelloApplicationContextInitializer和HelloSpringApplicationRunListener文件META-INF/spring.factories中加入</p>
<pre><code># Initializers
org.springframework.context.ApplicationContextInitializer=\
com.wdjr.springboot.listener.HelloApplicationContextInitializer

org.springframework.boot.SpringApplicationRunListener=\
com.wdjr.springboot.listener.HelloSpringApplicationRunListener

</code></pre>
<p>HelloApplicationRunner和HelloCommandLineRunner ioc加入</p>
<p>@Component</p>
<h1 id="八-springboot的自定义starter">八、SpringBoot的自定义starter</h1>
<p>starter：场景启动器</p>
<p>1、场景需要使用什么依赖？</p>
<p>2、如何编写自动配置</p>
<pre><code class="language-java">@Configuration //指定这个类是一个配置类
@ConditionalOnXXX //在指定条件下成立的情况下自动配置类生效
@AutoConfigureAfter //指定自动配置类的顺序
@Bean //给容器中添加组件

@ConfigurationProperties //结合相关xxxProperties类来绑定相关的配置
@EnableConfigurationProperties //让xxxProperties生效加到容器中

自动配置类要能加载
将需要启动就加载的自动配置类，配置在META-INF/spring.factories
# Auto Configure
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\
org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\

</code></pre>
<p>3、模式</p>
<p>启动器空的jar只需要做依赖管理导入；</p>
<p>专门写一个自动配置模块；</p>
<p>启动器依赖自动配置，别人只需要引入starter</p>
<p>xxx-spring-boot-starter</p>
<h3 id="新建一个starter">新建一个starter</h3>
<blockquote>
<p>绕的你怀疑人生</p>
</blockquote>
<h4 id="1-新建一个空项目工程">1、新建一个空项目工程</h4>
<figure data-type="image" tabindex="47"><img src="https://stormga.github.io//post-images/56.starter01.jpg" alt="" loading="lazy"></figure>
<p>2、项目命名</p>
<figure data-type="image" tabindex="48"><img src="https://stormga.github.io//post-images/57.starter02.jpg" alt="" loading="lazy"></figure>
<p>3、导入module</p>
<figure data-type="image" tabindex="49"><img src="https://stormga.github.io//post-images/58.starter03.jpg" alt="" loading="lazy"></figure>
<p>4、新建一个Maven工程</p>
<figure data-type="image" tabindex="50"><img src="https://stormga.github.io//post-images/59.starter04.jpg" alt="" loading="lazy"></figure>
<p>5、项目命名</p>
<figure data-type="image" tabindex="51"><img src="https://stormga.github.io//post-images/60.starter05.jpg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="52"><img src="https://stormga.github.io//post-images/61.starter06.jpg" alt="" loading="lazy"></figure>
<p>6、在新建一个autoconfiguration类的spring</p>
<figure data-type="image" tabindex="53"><img src="https://stormga.github.io//post-images/62.starter07.jpg" alt="" loading="lazy"></figure>
<p>7、项目命名</p>
<figure data-type="image" tabindex="54"><img src="https://stormga.github.io//post-images/63.starter08.jpg" alt="" loading="lazy"></figure>
<p>8、无需导入依赖</p>
<figure data-type="image" tabindex="55"><img src="https://stormga.github.io//post-images/64.starter09.jpg" alt="" loading="lazy"></figure>
<p>9、next</p>
<figure data-type="image" tabindex="56"><img src="https://stormga.github.io//post-images/65.starter10.jpg" alt="" loading="lazy"></figure>
<p>最后配置完成</p>
<h4 id="2-编写starter">2、编写starter</h4>
<h5 id="autoconfigurer">autoconfigurer</h5>
<p>对<strong>lkh-spring-boot-starter-autoconfigurer</strong>进行删减</p>
<p>目录</p>
<figure data-type="image" tabindex="57"><img src="https://stormga.github.io//post-images/66.starter-build01.jpg" alt="" loading="lazy"></figure>
<p>2、pom文件修改</p>
<pre><code class="language-xml">    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;

    &lt;/dependencies&gt;


&lt;/project&gt;

</code></pre>
<p>3、编写相关的类</p>
<figure data-type="image" tabindex="58"><img src="https://stormga.github.io//post-images/67.starter-build02.jpg" alt="" loading="lazy"></figure>
<p>4、HelloProperties</p>
<pre><code class="language-java">package com.lkh.starter;


import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties(prefix = &quot;lkh.hello&quot;)
public class HelloProperties {
    private String prefix;
    private String suffix;

    public String getPrefix() {
        return prefix;
    }

    public void setPrefix(String prefix) {
        this.prefix = prefix;
    }

    public String getSuffix() {
        return suffix;
    }

    public void setSuffix(String suffix) {
        this.suffix = suffix;
    }
}

</code></pre>
<p>5、HelloService</p>
<pre><code class="language-java">package com.lkh.starter;

public class HelloService {

    HelloProperties helloProperties;

    public HelloProperties getHelloProperties() {
        return helloProperties;
    }

    public void setHelloProperties(HelloProperties helloProperties) {
        this.helloProperties = helloProperties;
    }

    public String sayHello(String name){
        return helloProperties.getPrefix()+name+helloProperties.getSuffix();
    }
}

</code></pre>
<p>6、HelloServiceAutoConfiguration</p>
<pre><code class="language-java">package com.lkh.starter;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@ConditionalOnWebApplication
@EnableConfigurationProperties(HelloProperties.class)
public class HelloServiceAutoConfiguration {

    @Autowired
    HelloProperties helloProperties;
    @Bean
    public HelloService helloService(){
        HelloService service = new HelloService();
        service.setHelloProperties(helloProperties);
        return service;
    }

}

</code></pre>
<p>7、配置文件</p>
<pre><code>org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.lkh.starter.HelloServiceAutoConfiguration

</code></pre>
<p>8、修改lkh-spring-boot-starter 也就是之前的Maven项目，修改pom文件引入autoconfiguration依赖</p>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.lkh.starter&lt;/groupId&gt;
        &lt;artifactId&gt;lkh-spring-boot-starter-autoconfigurer&lt;/artifactId&gt;
        &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

</code></pre>
<p>9、install生成</p>
<figure data-type="image" tabindex="59"><img src="https://stormga.github.io//post-images/68.starter-build03.jpg" alt="" loading="lazy"></figure>
<h4 id="3-测试">3、测试</h4>
<p>新建一个springboot 1.5+web</p>
<p>1、引入starter</p>
<pre><code class="language-xml">    &lt;dependency&gt;
        &lt;groupId&gt;com.lkh.starter&lt;/groupId&gt;
        &lt;artifactId&gt;lkh-spring-boot-starter&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;

&lt;/dependencies&gt;

</code></pre>
<p>2、新建一个Controller用来测试</p>
<pre><code class="language-java">@RestController
public class HelloController {

    @Autowired
    HelloService helloService;

    @GetMapping
    public  String hello(){
        return helloService.sayHello(&quot;test&quot;);
    }
}

</code></pre>
<p>3、编写配置文件制定前缀和后缀名</p>
<pre><code class="language-properties">lkh.hello.prefix=Starter-
lkh.hello.suffix=-Success

</code></pre>
<p>4、运行访问http://localhost:8080/hello</p>
<figure data-type="image" tabindex="60"><img src="https://stormga.github.io//post-images/70.starter-build05.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis主从复制]]></title>
        <id>https://stormga.github.io/post/redis-replication/</id>
        <link href="https://stormga.github.io/post/redis-replication/">
        </link>
        <updated>2020-03-09T09:44:55.000Z</updated>
        <summary type="html"><![CDATA[<p>我们通过持久化功能，redis保证了即使服务器重启也不会丢失数据，但是由于数据存储在一台服务器上，如果该服务器出现故障，比如硬盘损坏也会导致数据丢失。所以我们为了避免单点故障，进行主从复制操作。</p>
]]></summary>
        <content type="html"><![CDATA[<p>我们通过持久化功能，redis保证了即使服务器重启也不会丢失数据，但是由于数据存储在一台服务器上，如果该服务器出现故障，比如硬盘损坏也会导致数据丢失。所以我们为了避免单点故障，进行主从复制操作。</p>
<!-- more -->
<h1 id="主从复制">主从复制</h1>
<ul>
<li>为了避免单点故障，我们需要将数据复制多份复制多份部署在多台不同的服务器上，即使一台初夏年故障，依然可以提供服务</li>
<li>这要求一台服务器的数据更新后，自动将更新的数据同步到其他服务器，怎么实现呢？-------redis的主从复制</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://stormga.github.io//post-images/redis%E4%B8%80%E4%B8%BB%E5%A4%9A%E4%BB%8E%E6%9E%B6%E6%9E%84.png" alt="" loading="lazy"></figure>
<ul>
<li>master用于写，slave用于读，向slave写数据会导致错误</li>
</ul>
<h3 id="主从复制实现">主从复制实现</h3>
<ul>
<li>方式一：修改配置文件</li>
<li>方式二：./redis-server --slaveof <master-ip> <master-port>，在启动redis时指定当前服务成为某个主Redis服务的从Slave</li>
</ul>
<h4 id="方式一修改配置文件实现方式">方式一修改配置文件实现方式</h4>
<ul>
<li>模拟多台redis服务器，运行多个redis应用，模拟多个服务器。</li>
</ul>
<h5 id="步骤">步骤：</h5>
<ul>
<li>
<p>复制三份redis.conf</p>
<ul>
<li>redis6380.conf</li>
<li>redis6382.conf</li>
<li>redis6384.conf</li>
</ul>
</li>
<li>
<p>编辑redis6380.conf</p>
<pre><code class="language-shell">include /usr/local/redis-3.2.9/redis.conf
daemonize yes
port 6380
pidfile /var/run/redis_6380.pid
logfile 6380.log
dbfilename dump6380.rdb
</code></pre>
<ul>
<li>include ： 包含原来的配置文件内容。/usr/local/redis-3.2.9/redis.conf按照自己的目录设置。</li>
<li>daemonize：yes 后台启动应用，相当于 ./redis-server &amp; , &amp;的作用。</li>
<li>port : 自定义的端口号</li>
<li>pidfile : 自定义的文件，表示当前程序的pid ,进程id。</li>
<li>logfile：日志文件名</li>
<li>dbfilename：持久化的rdb文件名</li>
</ul>
</li>
<li>
<p>编辑slave配置文件</p>
<ul>
<li>slaveof ： 表示当前Redis是谁的从。当前是127.0.0.0 端口6380这个Master的从</li>
</ul>
</li>
</ul>
<h4 id="启动服务器masterslave">启动服务器master/slave</h4>
<ul>
<li>./redis-cli -p 6380</li>
<li>./redis-cli -p 6382</li>
<li>./redis-cli -p 6384</li>
</ul>
<h4 id="总结">总结：</h4>
<p>这样6380写入数据，6382，6384都会同步</p>
<h3 id="容灾处理">容灾处理</h3>
<p>当Master服务出现故障，需手动将slave中的一个提升为master， 剩下的slave挂至新的master上（冷处理：机器挂掉了，再处理）</p>
<h1 id="高可用sentinel哨兵">高可用Sentinel哨兵</h1>
<ul>
<li>搭建集群会使用投票机制，所以我们搭建集群要搭建奇数台机器</li>
<li>可以有几个redis，配几个哨兵</li>
</ul>
<h3 id="sentinel系统的任务">Sentinel系统的任务</h3>
<ul>
<li>监控：Sentinel不断的检查主服务和从服务器是否按照预期正常工作。</li>
<li>提醒：被监控的Redis出现问题时，Sentinel会通知管理员或其他应用程序。</li>
<li>自动故障转移：监控的主Redis不能正常工作，Sentinel会开始进行故障迁移操作。将一个从服务器升级新的主服务器。 让其他从服务器挂到新的主服务器。同时向客户端提供新的主服务器地址。</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://stormga.github.io//post-images/redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.png" alt="" loading="lazy"></figure>
<ul>
<li>当主服务器宕机后，哨兵会进行投票，少数服从多数，选举出新的主服务器。</li>
<li>如果宕机的主服务器恢复服务后，此时会称为新的主服务器的从服务器，不再具有写权限。然后在一段时间内和其他从服务器同步，保证数据一致性。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis五种数据类型的基本操作]]></title>
        <id>https://stormga.github.io/post/redis-data/</id>
        <link href="https://stormga.github.io/post/redis-data/">
        </link>
        <updated>2020-03-09T09:17:52.000Z</updated>
        <summary type="html"><![CDATA[<p>redis五种数据类型的介绍和基本操作</p>
]]></summary>
        <content type="html"><![CDATA[<p>redis五种数据类型的介绍和基本操作</p>
<!-- more -->
<h1 id="五种数据类型">五种数据类型</h1>
<h2 id="字符串string">字符串：string</h2>
<p>字符串类型是Redis中最基本的数据类型，它能存储任何形式的字符串，包括二进制数据，序列化后的数据，JSON化的对象甚至是一张图片。最大512M。</p>
<figure data-type="image" tabindex="1"><img src="https://stormga.github.io//post-images/1583746374280.png" alt="" loading="lazy"></figure>
<h2 id="哈希类型hash">哈希类型：hash</h2>
<p>Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p>
<h2 id="列表类型list">列表类型：list</h2>
<p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）</p>
<figure data-type="image" tabindex="2"><img src="https://stormga.github.io//post-images/1583746636205.png" alt="" loading="lazy"></figure>
<h2 id="集合类型set">集合类型：set</h2>
<p>Redis的Set是string类型的无序集合，集合成员是唯一的，即集合中不能出现重复的数据.</p>
<figure data-type="image" tabindex="3"><img src="https://stormga.github.io//post-images/1583746677040.png" alt="" loading="lazy"></figure>
<h2 id="有序集合类型zsetsorted-set">有序集合类型：zset（sorted set）</h2>
<p>Redis 有序集合zset和集合set一样也是string类型元素的集合，且不允许重复的成员。</p>
<p>不同的是zset的每个元素都会关联一个分数（分数可以重复），redis通过分数来为集合中的成员进行从小到大的排序。</p>
<figure data-type="image" tabindex="4"><img src="https://stormga.github.io//post-images/1548561480140.png" alt="" loading="lazy"></figure>
<h1 id="基本操作命令">基本操作命令</h1>
<h2 id="字符串">字符串</h2>
<p>（1）将字符串值 value 设置到 key 中，查看已插入的key</p>
<p>语法：set key value</p>
<figure data-type="image" tabindex="5"><img src="https://stormga.github.io//post-images/1548561624959.png" alt="" loading="lazy"></figure>
<p>（2）获取 key 中设置的字符串值</p>
<p>语法： get key</p>
<figure data-type="image" tabindex="6"><img src="https://stormga.github.io//post-images/1548561659485.png" alt="" loading="lazy"></figure>
<p>（3）将 key 中储存的数字值加1，如果 key 不存在，则 key 的值先被初始化为 0 再执行 incr 操作（只能对数字类型的数据操作）</p>
<p>语法：incr key</p>
<figure data-type="image" tabindex="7"><img src="https://stormga.github.io//post-images/1548561725099.png" alt="" loading="lazy"></figure>
<p>（4）将 key 中储存的数字值减1，如果 key 不存在，则么 key 的值先被初始化为 0 再执行 decr  操作（只能对数字类型的数据操作）</p>
<p>语法：decr key</p>
<figure data-type="image" tabindex="8"><img src="https://stormga.github.io//post-images/1548561761899.png" alt="" loading="lazy"></figure>
<p><strong>incr ，decr 在实现关注人数上，文章的点击数上。</strong></p>
<p>（5）语法：append key value</p>
<p>说明：如果 key 存在， 则将 value 追加到 key 原来旧值的末尾</p>
<p>如果 key 不存在， 则将key 设置值为 value</p>
<p>返回值：追加字符串之后的总长度</p>
<figure data-type="image" tabindex="9"><img src="https://stormga.github.io//post-images/1548561900420.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>语法：strlen key</p>
<p>说明：返回 key 所储存的字符串值的长度</p>
<p>返回值：</p>
<p>​     ①：如果key存在，返回字符串值的长度</p>
<p>​     ②：key不存在，返回0</p>
<figure data-type="image" tabindex="10"><img src="https://stormga.github.io//post-images/1548564400282.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>语法：getrange key start end</p>
<p>作用：获取 key 中字符串值从 start 开始 到 end 结束 的子字符串,包括start和end, 负数表示从字符串的末尾开始， -1 表示最后一个字符，-2表示倒数第二个字符。位置从0开始</p>
<p>返回值：截取的子字符串。</p>
<figure data-type="image" tabindex="11"><img src="https://stormga.github.io//post-images/1548564561755.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>语法：setrange key offset value</p>
<p>说明：用value覆盖（替换）key的存储的值从offset开始,不存在的key做空白字符串。</p>
<p>返回值：修改后的字符串的长度</p>
<figure data-type="image" tabindex="12"><img src="https://stormga.github.io//post-images/1548564742768.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>语法：mset key value [key value…]</p>
<p>说明：同时设置一个或多个 key-value 对</p>
<p>返回值： OK</p>
<figure data-type="image" tabindex="13"><img src="https://stormga.github.io//post-images/1548564796144.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>语法：mget key [key …]</p>
<p>作用：获取所有(一个或多个)给定 key 的值</p>
<p>返回值：包含所有key的列表</p>
<figure data-type="image" tabindex="14"><img src="https://stormga.github.io//post-images/1548564833435.png" alt="" loading="lazy"></figure>
</li>
</ul>
<h2 id="哈希类型">哈希类型</h2>
<ul>
<li><strong>hset</strong></li>
</ul>
<p>语法：hset  hash表的key  field  value</p>
<p>作用：将哈希表 key 中的域 field 的值设为 value ，如果key不存在，则新建hash表，执行赋值，如果有field ,则覆盖值。</p>
<p>返回值：</p>
<p>①如果field是hash表中新field，且设置值成功，返回1</p>
<p>②如果field已经存在，旧值覆盖新值，返回0</p>
<figure data-type="image" tabindex="15"><img src="https://stormga.github.io//post-images/1548565057765.png" alt="" loading="lazy"></figure>
<ul>
<li><strong>hget</strong></li>
</ul>
<p>语法：hget key field</p>
<p>作用：获取哈希表 key 中给定域 field 的值</p>
<p>返回值：field域的值，如果key不存在或者field不存在返回nil</p>
<figure data-type="image" tabindex="16"><img src="https://stormga.github.io//post-images/1548565117165.png" alt="" loading="lazy"></figure>
<ul>
<li><strong>hmset</strong></li>
</ul>
<p>语法：hmset key  field value [field value…]</p>
<p>说明：同时将多个 field-value (域-值)设置到哈希表 key 中，此命令会覆盖已经存在的field，hash表key不存在，创建空的hash表，执行hmset.</p>
<p>返回值：设置成功返回ok， 如果失败返回一个错误</p>
<figure data-type="image" tabindex="17"><img src="https://stormga.github.io//post-images/1548565192160.png" alt="" loading="lazy"></figure>
<ul>
<li><strong>hmget</strong></li>
</ul>
<p>语法：hmget key field [field…]</p>
<p>作用:获取哈希表 key 中一个或多个给定域的值</p>
<p>返回值：返回和field顺序对应的值，如果field不存在，返回nil</p>
<figure data-type="image" tabindex="18"><img src="https://stormga.github.io//post-images/1548565538725.png" alt="" loading="lazy"></figure>
<ul>
<li><strong>hgetall</strong></li>
</ul>
<p>语法：hgetall key</p>
<p>作用：获取哈希表 key 中所有的域和值</p>
<p>返回值：以列表形式返回hash中域和域的值 ，key 不存在，返回空hash</p>
<figure data-type="image" tabindex="19"><img src="https://stormga.github.io//post-images/1548565574923.png" alt="" loading="lazy"></figure>
<ul>
<li><strong>hdel</strong></li>
</ul>
<p>语法：hdel key field [field…]</p>
<p>作用：删除哈希表 key 中的一个或多个指定域field，不存在field直接忽略</p>
<p>返回值：成功删除的field的数量</p>
<figure data-type="image" tabindex="20"><img src="https://stormga.github.io//post-images/1548565640106.png" alt="" loading="lazy"></figure>
<ul>
<li><strong>hkeys</strong></li>
</ul>
<p>语法：hkeys key</p>
<p>作用：查看哈希表 key 中的所有field域</p>
<p>返回值：包含所有field的列表，key不存在返回空列表</p>
<figure data-type="image" tabindex="21"><img src="https://stormga.github.io//post-images/1548565665188.png" alt="" loading="lazy"></figure>
<ul>
<li><strong>hvals</strong></li>
</ul>
<p>语法：hvals key</p>
<p>作用：返回哈希表 中所有域的值</p>
<p>返回值：包含哈希表所有域值的列表，key不存在返回空列表</p>
<figure data-type="image" tabindex="22"><img src="https://stormga.github.io//post-images/1548565738515.png" alt="" loading="lazy"></figure>
<ul>
<li>hexists</li>
</ul>
<p>语法：hexists key field</p>
<p>作用：查看哈希表 key 中，给定域 field 是否存在</p>
<p>返回值：如果field存在，返回1， 其他返回0</p>
<figure data-type="image" tabindex="23"><img src="https://stormga.github.io//post-images/1548565785552.png" alt="" loading="lazy"></figure>
<h2 id="列表">列表</h2>
<ul>
<li><strong>lpush</strong></li>
</ul>
<p>语法：lpush key value [value…]</p>
<p>作用：将一个或多个值 value 插入到列表 key 的表头（最左边），从左边开始加入值，从左到右的顺序依次插入到表头</p>
<p>返回值：数字，新列表的长度</p>
<p><strong><img src="https://stormga.github.io//post-images/1548565857589.png" alt="" loading="lazy"></strong></p>
<figure data-type="image" tabindex="24"><img src="https://stormga.github.io//post-images/1548566059007.png" alt="" loading="lazy"></figure>
<p>在 redis-desktop-manager显示</p>
<figure data-type="image" tabindex="25"><img src="https://stormga.github.io//post-images/1548566162551.png" alt="" loading="lazy"></figure>
<p>插入重复值</p>
<figure data-type="image" tabindex="26"><img src="https://stormga.github.io//post-images/1548566212605.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="27"><img src="https://stormga.github.io//post-images/1548566230069.png" alt="" loading="lazy"></figure>
<ul>
<li><strong>rpush</strong></li>
</ul>
<p>语法：rpush key value [value…]</p>
<p>作用：将一个或多个值 value 插入到列表 key 的表尾（最右边），各个 value 值按从左到右的顺序依次插入到表尾</p>
<p>返回值：数字，新列表的长度</p>
<figure data-type="image" tabindex="28"><img src="https://stormga.github.io//post-images/1548566275748.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="29"><img src="https://stormga.github.io//post-images/1548566294159.png" alt="" loading="lazy"></figure>
<ul>
<li><strong>lrange</strong></li>
</ul>
<p>语法：lrange key start stop</p>
<p>作用：获取列表 key 中指定区间内的元素，0 表示列表的第一个元素，以 1 表示列表的第二个元素；start , stop 是列表的下标值，也可以负数的下标， -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。 start ，stop超出列表的范围不会出现错误。</p>
<p>返回值：指定区间的列表</p>
<figure data-type="image" tabindex="30"><img src="https://stormga.github.io//post-images/1548566342100.png" alt="" loading="lazy"></figure>
<ul>
<li><strong>lindex</strong></li>
</ul>
<p>语法：lindex key index</p>
<p>作用：获取列表 key 中下标为指定 index 的元素，列表元素不删除，只是查询。0 表示列表的第一个元素，以 1 表示列表的第二个元素；start , stop 是列表的下标值，也可以负数的下标， -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</p>
<p>返回值：指定下标的元素；index不在列表范围，返回nil</p>
<figure data-type="image" tabindex="31"><img src="https://stormga.github.io//post-images/1548566365030.png" alt="" loading="lazy"></figure>
<ul>
<li><strong>llen</strong></li>
</ul>
<p>语法：llen key</p>
<p>作用：获取列表 key 的长度</p>
<p>返回值：数值，列表的长度； key不存在返回0</p>
<figure data-type="image" tabindex="32"><img src="https://stormga.github.io//post-images/1548566394443.png" alt="" loading="lazy"></figure>
<ul>
<li><strong>lrem</strong></li>
</ul>
<p>语法：lrem key count value</p>
<p>作用：根据参数 count 的值，移除列表中与参数 value 相等的元素， count &gt;0 ，从列表的左侧向右开始移除； count &lt; 0 从列表的尾部开始移除；count = 0移除表中所有与 value 相等的值。</p>
<p>返回值：数值，移除的元素个数</p>
<figure data-type="image" tabindex="33"><img src="https://stormga.github.io//post-images/1548566520410.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="34"><img src="https://stormga.github.io//post-images/1548566581052.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="35"><img src="https://stormga.github.io//post-images/1548566568423.png" alt="" loading="lazy"></figure>
<ul>
<li><strong>lset</strong></li>
</ul>
<p>语法：lset key index value</p>
<p>作用：将列表 key 下标为 index 的元素的值设置为 value。</p>
<p>返回值：设置成功返回ok ; key不存在或者index超出范围返回错误信息</p>
<figure data-type="image" tabindex="36"><img src="https://stormga.github.io//post-images/1548566820411.png" alt="" loading="lazy"></figure>
<ul>
<li><strong>linsert</strong></li>
</ul>
<p>语法：linsert key BEFORE|ALFTER pivot value</p>
<p>作用：将值 value 插入到列表 key 当中位于值 pivot 之前或之后的位置。key不存在，pivot不在列表中，不执行任何操作。</p>
<p>返回值：命令执行成功，返回新列表的长度。没有找到pivot返回 -1， key不存在返回0。</p>
<p>​          <strong>将python插入到java之前</strong></p>
<figure data-type="image" tabindex="37"><img src="https://stormga.github.io//post-images/1548567424622.png" alt="" loading="lazy"></figure>
<h2 id="集合">集合</h2>
<ul>
<li><strong>sadd</strong></li>
</ul>
<p>语法：sadd key member [member…]</p>
<p>作用：将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽略，不会再加入。</p>
<p>返回值：加入到集合的新元素的个数。不包括被忽略的元素。</p>
<figure data-type="image" tabindex="38"><img src="https://stormga.github.io//post-images/1548567651325.png" alt="" loading="lazy"></figure>
<ul>
<li><strong>smembers</strong></li>
</ul>
<p>语法：smembers key</p>
<p>作用：获取集合 key 中的所有成员元素，不存在的key视为空集合</p>
<figure data-type="image" tabindex="39"><img src="https://stormga.github.io//post-images/1548567691405.png" alt="" loading="lazy"></figure>
<ul>
<li><strong>sismember</strong></li>
</ul>
<p>语法：sismember key member</p>
<p>作用：判断 member 元素是否是集合 key 的成员</p>
<p>返回值：member是集合成员返回1，其他返回 0 。</p>
<figure data-type="image" tabindex="40"><img src="https://stormga.github.io//post-images/1548567734490.png" alt="" loading="lazy"></figure>
<ul>
<li><strong>scard</strong></li>
</ul>
<p>语法：scard key</p>
<p>作用：获取集合里面的元素个数</p>
<p>返回值：数字，key的元素个数。 其他情况返回 0 。</p>
<figure data-type="image" tabindex="41"><img src="https://stormga.github.io//post-images/1548567761685.png" alt="" loading="lazy"></figure>
<ul>
<li><strong>srem</strong></li>
</ul>
<p>语法：srem key member [member…]</p>
<p>作用：删除集合 key 中的一个或多个 member 元素，不存在的元素被忽略。</p>
<p>返回值：数字，成功删除的元素个数，不包括被忽略的元素。</p>
<figure data-type="image" tabindex="42"><img src="https://stormga.github.io//post-images/1548567840926.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="43"><img src="https://stormga.github.io//post-images/1548567854136.png" alt="" loading="lazy"></figure>
<ul>
<li><strong>srandmember</strong></li>
</ul>
<p>语法：srandmember key [count]</p>
<p>作用：只提供key，随机返回集合中一个元素，元素不删除，依然在集合中；提供了count时，count 正数, 返回包含count个数元素的集合， 集合元素各不相同。count 是负数，返回一个count绝对值的长度的集合， 集合中元素可能会重复多次。</p>
<p>返回值：一个元素；多个元素的集合</p>
<figure data-type="image" tabindex="44"><img src="https://stormga.github.io//post-images/1548567925391.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="45"><img src="https://stormga.github.io//post-images/1548567938119.png" alt="" loading="lazy"></figure>
<ul>
<li><strong>spop</strong></li>
</ul>
<p>语法：spop key [count]</p>
<p>作用：随机从集合中删除一个元素, count是删除的元素个数。</p>
<p>返回值：被删除的元素，key不存在或空集合返回nil</p>
<figure data-type="image" tabindex="46"><img src="https://stormga.github.io//post-images/1548568005949.png" alt="" loading="lazy"></figure>
<p>随机删除2个元素</p>
<figure data-type="image" tabindex="47"><img src="https://stormga.github.io//post-images/1548568056171.png" alt="" loading="lazy"></figure>
<h2 id="有序集合zset">有序集合zset</h2>
<ul>
<li><strong>zadd</strong></li>
</ul>
<p>语法：zadd key score member [score member…]</p>
<p>作用：将一个或多个 member 元素及其 score 值加入到有序集合 key 中，如果member存在集合中，则更新值；score可以是整数或浮点数</p>
<p>返回值：数字，新添加的元素个数</p>
<figure data-type="image" tabindex="48"><img src="https://stormga.github.io//post-images/1548568187813.png" alt="" loading="lazy"></figure>
<ul>
<li><strong>zrange</strong></li>
</ul>
<p>语法：zrange key start stop [WITHSCORES]</p>
<p>作用：查询有序集合，指定区间的内的元素。集合成员按score值从小到大来排序。 start， stop都是从0开始。0是第一个元素，1 是第二个元素，依次类推。以 -1表示最后一个成员，-2 表示倒数第二个成员。WITHSCORES选项让score和value一同返回。</p>
<p>返回值：自定区间的成员集合</p>
<p>（1）显示集合的全部元素，不显示score，不使用WITHSCORES</p>
<figure data-type="image" tabindex="49"><img src="https://stormga.github.io//post-images/1548568601821.png" alt="" loading="lazy"></figure>
<p>（2）显示集合全部元素，并使用WITHSCORES</p>
<figure data-type="image" tabindex="50"><img src="https://stormga.github.io//post-images/1548568660273.png" alt="" loading="lazy"></figure>
<ul>
<li><strong>zrevrange</strong></li>
</ul>
<p>语法：zrevrange key start stop [WITHSCORES]</p>
<p>作用：返回有序集 key 中，指定区间内的成员。其中成员的位置按 score 值递减(从大到小)来排列。其它同zrange命令。</p>
<p>返回值：自定区间的成员集合</p>
<figure data-type="image" tabindex="51"><img src="https://stormga.github.io//post-images/1548569040783.png" alt="" loading="lazy"></figure>
<ul>
<li><strong>zrem</strong></li>
</ul>
<p>语法：zrem key member [member…]</p>
<p>作用：删除有序集合 key 中的一个或多个成员，不存在的成员被忽略</p>
<p>返回值：被成功删除的成员数量，不包括被忽略的成员。</p>
<figure data-type="image" tabindex="52"><img src="https://stormga.github.io//post-images/548569116524.png" alt="" loading="lazy"></figure>
<ul>
<li><strong>zcard</strong></li>
</ul>
<p>语法：zcard key</p>
<p>作用：获取有序集 key 的元素成员的个数</p>
<p>返回值：key存在返回集合元素的个数， key不存在，返回0</p>
<figure data-type="image" tabindex="53"><img src="https://stormga.github.io//post-images/1548569148453.png" alt="" loading="lazy"></figure>
<ul>
<li><strong>zrangebyscore</strong></li>
</ul>
<p>语法：zrangebyscore key min max [WITHSCORES ][LIMIT offset count]</p>
<p>作用：获取有序集 key 中，所有 score 值介于 min 和 max 之间（包括min和max）的成员，有序成员是按递增（从小到大）排序。</p>
<p>​      min ,max是包括在内 ， 使用符号 ( 表示不包括。 min，max 可以使用 -inf  ，+inf表示最小和最大</p>
<p>​     limit 用来限制返回结果的数量和区间。</p>
<p>​     withscores 显示score 和 value</p>
<p>返回值：指定区间的集合数据</p>
<p>（1） 显示指定具体区间的数据</p>
<figure data-type="image" tabindex="54"><img src="https://stormga.github.io//post-images/1548569328020.png" alt="" loading="lazy"></figure>
<p>（2）显示指定具体区间的集合数据，开区间（不包括min，max）</p>
<figure data-type="image" tabindex="55"><img src="https://stormga.github.io//post-images/1548569412159.png" alt="" loading="lazy"></figure>
<p>（3）显示整个集合的所有数据</p>
<figure data-type="image" tabindex="56"><img src="https://stormga.github.io//post-images/1548569462467.png" alt="" loading="lazy"></figure>
<p>（4）使用limit  0是开始位置 2是数量</p>
<figure data-type="image" tabindex="57"><img src="https://stormga.github.io//post-images/1548569509068.png" alt="" loading="lazy"></figure>
<ul>
<li><strong>zrevrangebyscore</strong></li>
</ul>
<p>语法：zrevrangebyscore key max min  [WITHSCORES].[LIMIT offset count]</p>
<p>作用：返回有序集 key 中， score 值介于 max 和 min 之间(默认包括等于 max 或 min )的所有的成员。有序集成员按 score 值递减(从大到小)的次序排列。其他同zrangebyscore</p>
<figure data-type="image" tabindex="58"><img src="https://stormga.github.io//post-images/1548569655175.png" alt="" loading="lazy"></figure>
<ul>
<li><strong>zcount</strong></li>
</ul>
<p>语法：zcount key min max</p>
<p>作用：返回有序集 key 中， score 值在 min 和 max 之间(默认包括 score 值等于 min 或 max )的成员的数量</p>
<figure data-type="image" tabindex="59"><img src="https://stormga.github.io//post-images/1548569707391.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis持久化]]></title>
        <id>https://stormga.github.io/post/redis-persistence/</id>
        <link href="https://stormga.github.io/post/redis-persistence/">
        </link>
        <updated>2020-03-09T09:04:48.000Z</updated>
        <summary type="html"><![CDATA[<p>Redis有两种持久化的方式：快照（RDB文件）和追加式文件（AOF文件）：</p>
<p>RDB持久化方式会在一个特定的间隔保存那个时间点的一个数据快照。<br>
AOF持久化方式则会记录每一个服务器收到的写操作。在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据。写操作命令记录的格式跟Redis协议一致，以追加的方式进行保存。<br>
Redis的持久化是可以禁用的，就是说你可以让数据的生命周期只存在于服务器的运行时间里。<br>
两种方式的持久化是可以同时存在的，但是当Redis重启时，AOF文件会被优先用于重建数据。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Redis有两种持久化的方式：快照（RDB文件）和追加式文件（AOF文件）：</p>
<p>RDB持久化方式会在一个特定的间隔保存那个时间点的一个数据快照。<br>
AOF持久化方式则会记录每一个服务器收到的写操作。在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据。写操作命令记录的格式跟Redis协议一致，以追加的方式进行保存。<br>
Redis的持久化是可以禁用的，就是说你可以让数据的生命周期只存在于服务器的运行时间里。<br>
两种方式的持久化是可以同时存在的，但是当Redis重启时，AOF文件会被优先用于重建数据。</p>
<!-- more -->
<h1 id="rdb方式">RDB方式</h1>
<p>Redis Database：就是在指定的时间间隔内将内存中的数据集快照写入磁盘，数据恢复时将快照文件直接再读到内存。<br>
RDB保存了某一个时间点的数据集，存储在一个二进制文件中，默认名为dump.rdb。RDB技术适合做备份，可以保存最近一个小时，一i谈，一个月的全部数据<br>
** RDB恢复数据比AOF速度快 **</p>
<h2 id="rdb如何实现">RDB如何实现</h2>
<ul>
<li>在redis.conf文件中配置即可。默认配置是启用的。</li>
<li>在redis.conf中修改SNAPSHOTTING中的配置</li>
<li>修改dbfilename mydump.db</li>
</ul>
<h2 id="优缺点">优缺点</h2>
<p>优点：</p>
<ul>
<li>存储的是数据快照文件，恢复数据方便，比较快</li>
</ul>
<p>缺点：</p>
<ul>
<li>会丢失最后一次快照以后更改的数据，如果你的应用能容忍一定数据的丢失，可以使用rdb。</li>
<li>rdb会经常操作磁盘，redis会分出一个子进程。如果redis数据库比较大，子进程占用的时间太多的话，可能会影响redis暂停服务（millisecond级别），如果数据库超级大，并且CPU比较弱，可能会达到一秒。</li>
</ul>
<h1 id="aof方式">AOF方式</h1>
<p>Append-only File,Redis每次接收到一条改变数据的命令时，它将把该命令写到一个AOF文件中（只记录写操作，读操作不记录），当Redis重启时，它通过执行AOF文件中所有的命令来恢复数据。</p>
<h2 id="配置方式">配置方式</h2>
<ul>
<li>appendonly :默认为no，改为yes即开启了持久化</li>
<li>appendfilename：指定AOF文件名，默认文件名为appendonly.aof</li>
<li>dir: RDB,AOF文件存储的目录，默认为./</li>
<li>appendfsync:配置向aof文件写命令数据的策略
<ul>
<li>no：不主动进行同步操作，由操作系统来做（每30s一次），快但是不安全</li>
<li>always：每次写入都会执行同步，慢一些但是比较安全。</li>
<li>everysec：每秒执行一次同步操作，比较平衡，介于速度和安全之间。默认项</li>
</ul>
</li>
<li>Redis每次接收到一条改变数据的命令时，它将把该命令写到一个AOF文件中（只记录写操作，读操作不记录），当Redis重启时，它通过执行AOF文件中所有的命令来恢复数据。</li>
</ul>
<h2 id="优缺点-2">优缺点</h2>
<ul>
<li>AOF文件在操作的时候会变得越来越大，例如做100次假发计算，在数据库中会得到最终的值而AOF中会存在100条记录，但99条是没有用的，但是redis支持在不影响服务的前提下后台重构AOF文件。</li>
<li>可以同时使用这两种方法，redis默认优先加载aof文件（数据最完整）</li>
</ul>
<h1 id="性能与实践">性能与实践</h1>
<h2 id="性能分析">性能分析</h2>
<p>RDB的快照、AOF的重写都需要fork，这是一个重量级操作，会对Redis造成阻塞。因此为了不影响Redis主进程响应，我们需要尽可能降低阻塞。</p>
<ol>
<li>降低fork的频率，比如可以手动来触发RDB生成快照、与AOF重写；</li>
<li>控制Redis最大使用内存，防止fork耗时过长；</li>
<li>使用更牛逼的硬件；</li>
<li>合理配置Linux的内存分配策略，避免因为物理内存不足导致fork失败。</li>
</ol>
<h2 id="实践经验">实践经验</h2>
<ul>
<li>如果Redis中的数据并不是特别敏感或者可以通过其它方式重写生成数据，可以关闭持久化，如果丢失数据可以通过其它途径补回；</li>
<li>自己制定策略定期检查Redis的情况，然后可以手动触发备份、重写数据；</li>
<li>单机如果部署多个实例，要防止多个机器同时运行持久化、重写操作，防止出现内存、CPU、IO资源竞争，让持久化变为串行；</li>
<li>可以加入主从机器，利用一台从机器进行备份处理，其它机器正常响应客户端的命令；</li>
<li>RDB持久化与AOF持久化可以同时存在，配合使用。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java-集合]]></title>
        <id>https://stormga.github.io/post/java-jihe/</id>
        <link href="https://stormga.github.io/post/java-jihe/">
        </link>
        <updated>2020-03-09T08:11:17.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇文章主要对java集合的框架进行介绍，使大家对java集合的整体框架有个了解。具体介绍了Collection接口，Map接口以及Collection接口的三个子接口Set，List，Queue。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇文章主要对java集合的框架进行介绍，使大家对java集合的整体框架有个了解。具体介绍了Collection接口，Map接口以及Collection接口的三个子接口Set，List，Queue。</p>
<!-- more -->
<h1 id="集合">集合</h1>
<ul>
<li>集合是用来存储类型数据的容器</li>
<li>集合是用来存储对象的引用</li>
</ul>
<h2 id="collection集合常用方法">Collection集合常用方法</h2>
<table>
<thead>
<tr>
<th>boolean</th>
<th><a href="#add-E-">add</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/Collection.html">E</a> e) 向集合中添加元素e</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td><a href="#addAll-java.util.Collection-">addAll</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/Collection.html">Collection</a>&lt;? extends <a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/Collection.html">E</a>&gt; c)  把c集合中的所有元素添加到当前集合中</td>
</tr>
<tr>
<td>void</td>
<td><a href="#clear--">clear</a>() 清空集合中所有元素.</td>
</tr>
<tr>
<td>boolean</td>
<td><a href="#contains-java.lang.Object-">contains</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/lang/Object.html">Object</a> o) 判断当前集合是否包含指定元素o.</td>
</tr>
<tr>
<td>boolean</td>
<td><a href="#containsAll-java.util.Collection-">containsAll</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/Collection.html">Collection</a>&lt;?&gt; c) 判断当前集合是否包含c集合中的所有元素</td>
</tr>
<tr>
<td>boolean</td>
<td><a href="#equals-java.lang.Object-">equals</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/lang/Object.html">Object</a> o).</td>
</tr>
<tr>
<td>int</td>
<td><a href="#hashCode--">hashCode</a>().</td>
</tr>
<tr>
<td>boolean</td>
<td><a href="#isEmpty--">isEmpty</a>() 判断集合是否为空.</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/Iterator.html">Iterator</a><E></td>
<td><a href="#iterator--">iterator</a>() 返回集合的迭代器.</td>
</tr>
<tr>
<td>boolean</td>
<td><a href="#remove-java.lang.Object-">remove</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/lang/Object.html">Object</a> o) 在当前集合中删除第一个与元素o匹配的元素.</td>
</tr>
<tr>
<td>boolean</td>
<td><a href="#removeAll-java.util.Collection-">removeAll</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/Collection.html">Collection</a>&lt;?&gt; c) 在当前集合中删除所有出现在c集合中的元素.</td>
</tr>
<tr>
<td>boolean</td>
<td><a href="#retainAll-java.util.Collection-">retainAll</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/Collection.html">Collection</a>&lt;?&gt; c) 只保留在集合c中出现的元素,其他的元素都删除.</td>
</tr>
<tr>
<td>int</td>
<td><a href="#size--">size</a>() 返回元素的个数.</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/lang/Object.html">Object</a>[]</td>
<td><a href="#toArray--">toArray</a>() 集合转数组.</td>
</tr>
<tr>
<td><T> T[]</td>
<td><a href="#toArray-T:A-">toArray</a>(T[] a)</td>
</tr>
</tbody>
</table>
<h2 id="list集合">List集合</h2>
<ul>
<li>继承了Collection,Collection所有的操作,List都有</li>
<li>List存储特点: 有序,可重复</li>
<li>List集合为每个元素指定一个索引值, 主要增加了针对索引值的操作</li>
</ul>
<table>
<thead>
<tr>
<th>void</th>
<th><a href="#add-int-E-">add</a>(int index, <a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/List.html">E</a> element) 在指定位置添加元素</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td><a href="#addAll-int-java.util.Collection-">addAll</a>(int index, <a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/Collection.html">Collection</a>&lt;? extends <a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/List.html">E</a>&gt; c)</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/List.html">E</a></td>
<td><a href="#get-int-">get</a>(int index) 返回指定位置元素的值</td>
</tr>
<tr>
<td>int</td>
<td><a href="#indexOf-java.lang.Object-">indexOf</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/lang/Object.html">Object</a> o) 返回元素o第一次出现的位置</td>
</tr>
<tr>
<td>int</td>
<td><a href="#lastIndexOf-java.lang.Object-">lastIndexOf</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/lang/Object.html">Object</a> o) 返回元素o最后一次出现的索引值</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/ListIterator.html">ListIterator</a><E></td>
<td><a href="#listIterator--">listIterator</a>() 返回ListIterator迭代器</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/List.html">E</a></td>
<td><a href="#remove-int-">remove</a>(int index)</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/List.html">E</a></td>
<td><a href="#set-int-E-">set</a>(int index, <a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/List.html">E</a> element)</td>
</tr>
<tr>
<td>void</td>
<td><a href="#sort-java.util.Comparator-">sort</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/Comparator.html">Comparator</a>&lt;? super <a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/List.html">E</a>&gt; c)</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/List.html">List</a><E></td>
<td><a href="#subList-int-int-">subList</a>(int fromIndex, int toIndex) 返回子列表</td>
</tr>
</tbody>
</table>
<h3 id="arraylist和vector">ArrayList和Vector</h3>
<ul>
<li>底层都是数组</li>
<li>默认初始化容量: 10</li>
<li>ArrayList扩容: 1.5倍,  Vector默认按2倍大小扩容</li>
<li>Vector提供的操作都使用synchronized修饰, 是线程安全的, ArrayList不是线程安全的</li>
</ul>
<h3 id="linkedlist">LinkedList</h3>
<ul>
<li>底层是双向链表</li>
<li>常用操作</li>
</ul>
<table>
<thead>
<tr>
<th>void</th>
<th><a href="#addFirst-E-">addFirst</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/LinkedList.html">E</a> e) 把元素e添加到链表的头部</th>
</tr>
</thead>
<tbody>
<tr>
<td>void</td>
<td><a href="#addLast-E-">addLast</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/LinkedList.html">E</a> e)  把元素e添加到最后</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/Iterator.html">Iterator</a><E></td>
<td><a href="#descendingIterator--">descendingIterator</a>() 逆序迭代</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/LinkedList.html">E</a></td>
<td><a href="#element--">element</a>() 返回第一个元素.</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/LinkedList.html">E</a></td>
<td><a href="#getFirst--">getFirst</a>()返回第一个元素.</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/LinkedList.html">E</a></td>
<td><a href="#getLast--">getLast</a>()返回最后一个元素</td>
</tr>
<tr>
<td>boolean</td>
<td><a href="#offer-E-">offer</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/LinkedList.html">E</a> e) 把元素e添加到最后.</td>
</tr>
<tr>
<td>boolean</td>
<td><a href="#offerFirst-E-">offerFirst</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/LinkedList.html">E</a> e) 把元素e添加到最前面,链表的头部</td>
</tr>
<tr>
<td>boolean</td>
<td><a href="#offerLast-E-">offerLast</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/LinkedList.html">E</a> e) 把元素e添加到最后</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/LinkedList.html">E</a></td>
<td><a href="#peek--">peek</a>().返回第一个元素.</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/LinkedList.html">E</a></td>
<td><a href="#peekFirst--">peekFirst</a>()返回第一个元素.</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/LinkedList.html">E</a></td>
<td><a href="#peekLast--">peekLast</a>()返回最后一个元素.</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/LinkedList.html">E</a></td>
<td><a href="#poll--">poll</a>() 删除第一个元素,并把删除的元素返回.</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/LinkedList.html">E</a></td>
<td><a href="#pollFirst--">pollFirst</a>()删除第一个元素,并把删除的元素返回..</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/LinkedList.html">E</a></td>
<td><a href="#pollLast--">pollLast</a>()删除最后一个元素,并把删除的元素返回.</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/LinkedList.html">E</a></td>
<td><a href="#pop--">pop</a>()删除第一个元素,并把删除的元素返回.</td>
</tr>
<tr>
<td>void</td>
<td><a href="#push-E-">push</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/LinkedList.html">E</a> e) 把元素e添加到链表的头部</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/LinkedList.html">E</a></td>
<td><a href="#removeFirst--">removeFirst</a>()删除第一个元素,并把删除的元素返回.</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/LinkedList.html">E</a></td>
<td><a href="#removeLast--">removeLast</a>()删除最后一个元素,并把删除的元素返回.</td>
</tr>
</tbody>
</table>
<h2 id="set集合">Set集合</h2>
<p>** 特点：无序，不可重复 **</p>
<h3 id="hashset">HashSet</h3>
<ul>
<li>
<p>HashSet底层是HashMap, HashSet的无参构造给hashMap进行了初始化</p>
</li>
<li>
<p>向hashSet中通过add(e)添加一个元素, 实际上是把这个元素作为 键,添加到了底层的hashMap中</p>
<p>map.put(e, PRESENT)</p>
</li>
<li>
<p>HashSet实际上是就是底层HashMap的键的集合</p>
</li>
<li>
<p>因为Map中的键不允许重复,所以HashSet也不能存储重复的元素</p>
</li>
</ul>
<h3 id="treeset">TreeSet</h3>
<ul>
<li>
<p>TreeSet 实现了SortedSet, 可以对存储的元素进行自然排序</p>
</li>
<li>
<p>TreeSet要求存储的元素必须是可比较的</p>
<ul>
<li>要么指定Comparator比较器</li>
<li>没有Comparator比较器,元素的类要实现Comparable接口</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/TreeSet.html">E</a></th>
<th><a href="#ceiling-E-">ceiling</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/TreeSet.html">E</a> e) 返回Set集合中大于等于指定元素e的最小元素.</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/Iterator.html">Iterator</a><E></td>
<td><a href="#descendingIterator--">descendingIterator</a>() 返回TreeSet集合的逆序迭代.</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/NavigableSet.html">NavigableSet</a><E></td>
<td><a href="#descendingSet--">descendingSet</a>() 返回TreeSet集合的逆序.</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/TreeSet.html">E</a></td>
<td><a href="#first--">first</a>() 返回TreeSet集合中的第一个元素</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/TreeSet.html">E</a></td>
<td><a href="#floor-E-">floor</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/TreeSet.html">E</a> e) 返回Set集合中小于等于指定元素e的最大元素.</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/SortedSet.html">SortedSet</a><E></td>
<td><a href="#headSet-E-">headSet</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/TreeSet.html">E</a> toElement) 返回TreeSet集合从开始到指定元素toElement之间的视图</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/NavigableSet.html">NavigableSet</a><E></td>
<td><a href="#headSet-E-boolean-">headSet</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/TreeSet.html">E</a> toElement, boolean inclusive).</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/TreeSet.html">E</a></td>
<td><a href="#higher-E-">higher</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/TreeSet.html">E</a> e). 返回TreeSet集合中大于指定元素e的最小元素</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/TreeSet.html">E</a></td>
<td><a href="#last--">last</a>()返回TreeSet集合最后一个元素</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/TreeSet.html">E</a></td>
<td><a href="#lower-E-">lower</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/TreeSet.html">E</a> e) 返回TreeSet集合中小于指定元素e的最大元素</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/TreeSet.html">E</a></td>
<td><a href="#pollFirst--">pollFirst</a>() 删除TreeSet集合的第一个元素,并把删除的元素返回.</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/TreeSet.html">E</a></td>
<td><a href="#pollLast--">pollLast</a>()删除TreeSet集合的最后一个元素,并把删除的元素返回</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/SortedSet.html">SortedSet</a><E></td>
<td><a href="#subSet-E-E-">subSet</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/TreeSet.html">E</a> fromElement, <a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/TreeSet.html">E</a> toElement) 返回TreeSet指定范围[fromElement, toElement)内的视图 .</td>
</tr>
<tr>
<td><a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/SortedSet.html">SortedSet</a><E></td>
<td><a href="#tailSet-E-">tailSet</a>(<a href="mk:MSITStore:D:%5Ccourse%5C03-JavaSE%5Cresources%5Cjdk1_8.chm::/java/util/TreeSet.html">E</a> fromElement).返回从指定元素fromElement到最后的一个子视图</td>
</tr>
</tbody>
</table>
<p><strong>注意:</strong></p>
<ul>
<li>
<p>TreeSet集合的contains()/remove()方法是根据Comparator或者Comparable的比较结果是否为0来判断元素是否存在</p>
</li>
<li>
<p>如何选择Comparator还是Comparable??</p>
<p>通过Comparator可以定义多种比较器</p>
<p>类实现了Comparable接口之后 ,排序规则就固定了, 可以把它当作默认的排序</p>
</li>
</ul>
<h2 id="迭代器">迭代器</h2>
<p><strong>集合继承Iterable接口，用集合的iteartor()方法得到迭代器对象</strong></p>
<h3 id="collection集合中使用迭代器">Collection集合中使用迭代器</h3>
<pre><code class="language-java">Iterator&lt;String&gt; iterator = collection.iterator();
		/*
		 * 1)刚刚获得迭代器对象时, 迭代器的游标指向第一个元素的前面
		 * 2) hasNext()判断是否还有没有访问到的元素
		 * 3) next()把下一个没访问的元素返回, 游标下移
		 */
		while( iterator.hasNext()){
			String next = iterator.next();
			System.out.println( next );
		}
</code></pre>
<p>###迭代器中有两个重要方法</p>
<ul>
<li>hasNext() 判断游标后面还有 没有访问到的元素</li>
<li>next() 把下一个没有访问的元素返回，游标下移</li>
</ul>
<h3 id="使用迭代器的注意事项">使用迭代器的注意事项</h3>
<ul>
<li>
<p>每次迭代完后，游标就在最后一个元素后面，如果我们还想使用迭代器我们需要重新获取</p>
</li>
<li>
<pre><code class="language-java">Iterator&lt;String&gt; iterator = collection.iterator();
      while(iterator.hasNext()){
          collection.remove(&quot;abc&quot;);
      
</code></pre>
</li>
</ul>
<pre><code>  **这段代码是错误的**

  我们阅读源码会发现：

  Iterator在创建的时候会返回一个Itr对象

  源码：

  ```java
      public Iterator&lt;E&gt; iterator() {
          return new Itr();
      }
</code></pre>
<p>而这个Itr是集合的内部类，我们以ArrayList分析</p>
<pre><code class="language-java">  private class Itr implements Iterator&lt;E&gt; {
      int cursor;       // index of next element to return
      int lastRet = -1; // index of last element returned; -1 if no such
      int expectedModCount = modCount;

      // prevent creating a synthetic constructor
      Itr() {}

</code></pre>
<p>这个modCount是ArrayList的一个成员变量</p>
<p>​</p>
<pre><code class="language-java">protected transient int modCount = 0;
</code></pre>
<p>每次ArrayList进行 remove,add操作就会改变modCount的值。</p>
<p>而迭代器的next方法会检查这两个值是否一样，不一样会抛异常。</p>
<p><strong>结论：</strong></p>
<p><strong>当我们创建的Iterator时，我们就不能使用集合自身的remove，add等方法了，否则我们进行迭代的时候会抛异常。由于foreach循环是底层是迭代器实现的，所以我们在foreach循环的时候也不能使用remove，add，clear等方法</strong></p>
<h2 id="map集合">Map集合</h2>
<h3 id="linkedhashmap">LinkedHashMap</h3>
<pre><code class="language-java">public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt;
</code></pre>
<p>继承自HashMap，一个有序的Map接口实现，这里的有序指的是元素可以按插入顺序或访问顺序排列；与HashMap相比，因为LinkedHashMap是继承自HashMap，因此LinkedHashMap：</p>
<ul>
<li>同样是基于散列表实现。</li>
<li>同时实现了Serializable 和 Cloneable接口，支持序列化和克隆。</li>
<li>并且同样不是线程安全的。</li>
</ul>
<p>区别是其内部维护了一个双向循环链表，该链表是有序的，可以按元素插入顺序或元素最近访问顺序(LRU)排列。</p>
<h4 id="linkedhashmap源码分析">LinkedHashMap源码分析</h4>
<ul>
<li>
<p>由于LinkedHashMap继承自HashMap，所以它不仅像HashMap那样对其进行基于哈希表和单链表的Entry数组+ next链表的存储方式，而且还结合了LinkedList的优点，为每个Entry节点增加了前驱和后继，并增加了一个为header头结点，构造了一个双向循环链表。<strong>（多一个以header为头结点的双向循环链表，也就是说，每次put进来KV，除了将其保存到对哈希表中的对应位置外，还要将其插入到双向循环链表的尾部。）</strong></p>
</li>
<li>
<p>LinkedHashMap的属性比HashMap多了一个accessOrder属性。<strong>当它false时，表示双向链表中的元素按照Entry插入LinkedHashMap到中的先后顺序排序</strong>，即每次put到LinkedHashMap中的Entry都放在双向链表的尾部，这样遍历双向链表时，Entry的输出顺序便和插入的顺序一致，这也是默认的双向链表的存储顺序；<strong>当它为true时，表示双向链表中的元素按照访问的先后顺序排列</strong>，可以看到，虽然Entry插入链表的顺序依然是按照其put到LinkedHashMap中的顺序，但put和get方法均有调用recordAccess方法（put方法在key相同，覆盖原有的Entry的情况下调用recordAccess方法），该方法判断accessOrder是否为true，如果是，则将当前访问的Entry（put进来的Entry或get出来的Entry）移到双向链表的尾部（key不相同时，put新Entry时，会调用addEntry，它会调用creatEntry，该方法同样将新插入的元素放入到双向链表的尾部，既符合插入的先后顺序，又符合访问的先后顺序，因为这时该Entry也被访问了），否则，什么也不做。</p>
</li>
<li>
<p>构造函数中有设置accessOrder的方法，如果我们需要实现LRU算法时，就需要将accessOrder的值设定为TRUE。</p>
</li>
<li>
<p>在HashMap的put方法中，如果key不为null时且哈希表中已经在存在时，循环遍历table[i]中的链表时会调用recordAccess方法，而在HashMap中这个方法是个空方法，在LinkedHashMap中则实现了该方法，该方法会判断accessOrder是否为true，如果为true，它会将当前访问的Entry（在这里指put进来的Entry）移动到双向循环链表的尾部，从而实现双向链表中的元素按照访问顺序来排序（最近访问的Entry放到链表的最后，这样多次下来，前面就是最近没有被访问的元素，在实现、LRU算法时，当双向链表中的节点数达到最大值时，将前面的元素删去即可，因为前面的元素是最近最少使用的），否则什么也不做。</p>
</li>
</ul>
<h1 id="自定义类型的集合进行排序">自定义类型的集合进行排序</h1>
<h2 id="实现comparable接口">实现comparable接口</h2>
<pre><code class="language-java">public class SortTest1 {
    public static void main(String[] args) {
        List &lt;Person&gt; personList = new ArrayList&lt;&gt;();
        personList.add(new Person(&quot;a&quot;, 15));
        personList.add(new Person(&quot;b&quot;, 11));
        personList.add(new Person(&quot;c&quot;, 18));
        personList.add(new Person(&quot;d&quot;, 10));
        Collections.sort(personList);
        System.out.println(personList);
    }

    static class Person implements Comparable&lt;Person&gt;{
        String name;
        int age;

        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }

        @Override
        public String toString() {
            return &quot;Person{&quot; +
                    &quot;name='&quot; + name + '\'' +
                    &quot;, age=&quot; + age +
                    '}';
        }

        @Override
        public int compareTo(Person o) {
            return this.age - o.age;
        }
    }
}
</code></pre>
<h2 id="实现comparator比较器">实现comparator比较器</h2>
<pre><code class="language-java">public class SortTest2 {
    public static void main(String[] args) {
        List &lt;Person&gt; personList = new ArrayList&lt;&gt;();
        personList.add(new Person(&quot;a&quot;, 15));
        personList.add(new Person(&quot;b&quot;, 11));
        personList.add(new Person(&quot;c&quot;, 18));
        personList.add(new Person(&quot;d&quot;, 10));
        Collections.sort(personList);
        System.out.println(personList);
    }

    static class Person implements Comparable&lt;Person&gt;{
        String name;
        int age;

        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }

        @Override
        public String toString() {
            return &quot;Person{&quot; +
                    &quot;name='&quot; + name + '\'' +
                    &quot;, age=&quot; + age +
                    '}';
        }

        @Override
        public int compareTo(Person o) {
            return this.age - o.age;
        }
    }
}
</code></pre>
<h2 id="在treeset中的一些排序和方法异常">在TreeSet中的一些排序和方法异常</h2>
<h3 id="一创建自定义treeset时出错">一.创建自定义TreeSet时出错</h3>
<pre><code class="language-java">public class TreeSetTest {
    public static void main(String[] args) {
        TreeSet&lt;Computer&gt; computers = new TreeSet&lt;&gt;();
        computers.add(new Computer(&quot;Asus&quot;,5800,8));
        computers.add(new Computer(&quot;Lenovo&quot;,4800,16));
        computers.add(new Computer(&quot;Dell&quot;,3800,8));
        computers.add(new Computer(&quot;Mac&quot;,15800,16));
        System.out.println(computers);
    }

    static class Computer {
        String brand;        //品牌
        int price;            //价格
        int memorySize;    //内存大小

        public Computer(String brand, int price, int memorySize) {
            super();
            this.brand = brand;
            this.price = price;
            this.memorySize = memorySize;
        }

        @Override
        public String toString() {
            return &quot;Computer{&quot; +
                    &quot;brand='&quot; + brand + '\'' +
                    &quot;, price=&quot; + price +
                    &quot;, memorySize=&quot; + memorySize +
                    '}';
        }
    }
}


</code></pre>
<p>这个程序我们运行的时候会报错，因为TreeSet是可排序的，我们的自定义类必须是可排序的，所以</p>
<p>我们要么指定Comparator比较器，要么类实现Comparable接口。</p>
<p>所以我们应该在改为：</p>
<pre><code class="language-java">public class TreeSetTest {
    public static void main(String[] args) {
      //在定义的时候加上Comparator比较器
        TreeSet&lt;Computer&gt; computers = new TreeSet&lt;&gt;(new Comparator&lt;Computer&gt;() {
            @Override
            public int compare(Computer o1, Computer o2) {
                return o1.price - o2.price;
            }
        });
        computers.add(new Computer(&quot;Asus&quot;, 5800, 8));
        computers.add(new Computer(&quot;Lenovo&quot;, 4800, 16));
        computers.add(new Computer(&quot;Dell&quot;, 3800, 8));
        computers.add(new Computer(&quot;Mac&quot;, 15800, 16));
        System.out.println(computers);
    }

    static class Computer {
        String brand;        //品牌
        int price;            //价格
        int memorySize;    //内存大小

        public Computer(String brand, int price, int memorySize) {
            super();
            this.brand = brand;
            this.price = price;
            this.memorySize = memorySize;
        }

        @Override
        public String toString() {
            return &quot;Computer{&quot; +
                    &quot;brand='&quot; + brand + '\'' +
                    &quot;, price=&quot; + price +
                    &quot;, memorySize=&quot; + memorySize +
                    '}';
        }
    }
}


</code></pre>
<h3 id="二指定比较器后添加失败删除方法异常">二.指定比较器后添加失败，删除方法异常。</h3>
<p>如果我们在main方法中，添加一个和比较器的比较对象比较值一样的对象默认为一个对象，不会执行该对象。</p>
<pre><code class="language-java">public static void main(String[] args) {
    TreeSet&lt;Computer&gt; computers = new TreeSet&lt;&gt;(new Comparator&lt;Computer&gt;() {
        @Override
        public int compare(Computer o1, Computer o2) {
            return o1.price - o2.price;
        }
    });
    computers.add(new Computer(&quot;Asus&quot;, 5800, 8));
    computers.add(new Computer(&quot;Lenovo&quot;, 4800, 16));
    computers.add(new Computer(&quot;Dell&quot;, 3800, 8));
    computers.add(new Computer(&quot;Mac&quot;, 15800, 16));
    System.out.println(computers);
  //[Computer{brand='Dell', price=3800, memorySize=8}, Computer{brand='Lenovo', price=4800, memorySize=16}, Computer{brand='Asus', price=5800, memorySize=8}, Computer{brand='Mac', price=15800, memorySize=16}]
    computers.add((new Computer(&quot;Acer&quot;,5800,8)));
    System.out.println(computers);
  //[Computer{brand='Dell', price=3800, memorySize=8}, Computer{brand='Lenovo', price=4800, memorySize=16}, Computer{brand='Asus', price=5800, memorySize=8}, Computer{brand='Mac', price=15800, memorySize=16}]
}

</code></pre>
<p><strong>而如果我们删除一个品牌为小米，price为5800，内存为8的对象时，他会删除价格为5800的华硕电脑。</strong></p>
<p><strong>因为TreeSet执行ComparaTo方法，返回值如果为0，那么它会认为这两个对象是同一对象。如该程序中，华硕电脑和小米电脑一样的价格，它执行比较器返回0，就会认为是同一对象</strong></p>
]]></content>
    </entry>
</feed>